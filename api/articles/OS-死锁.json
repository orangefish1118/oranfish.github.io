{"title":"OS-死锁","uid":"89874e71a8d4fa3b3317f544a3a17f4e","slug":"OS-死锁","date":"2024-06-09T07:25:12.000Z","updated":"2024-06-19T08:04:20.639Z","comments":true,"path":"api/articles/OS-死锁.json","keywords":"博客、橙汁蒸鱼、Orangefish、Oranfish","cover":"/medias/33.jpg","content":"<h2 id=\"1-死锁的概念\"><a href=\"#1-死锁的概念\" class=\"headerlink\" title=\"1.死锁的概念\"></a>1.死锁的概念</h2><p>在多线程编程中，我们为了防止多线程竞争共享资源而导致数据错乱，都会在操作共享资源之前加上互斥锁，只有成功获得到锁的线程，才能操作共享资源，获取不到锁的线程就只能等待，直到锁被释放。</p>\n<p>那么，当两个线程为了保护两个不同的共享资源而使用了两个互斥锁，那么这两个互斥锁应用不当的时候，可能会造成<strong>两个线程都在等待对方释放锁</strong>，在没有外力的作用下，这些线程会一直相互等待，就没办法继续运行，这种情况就是发生了<strong>死锁</strong>。</p>\n<p>死锁只有<strong>同时满足</strong>以下四个条件才会发生：</p>\n<ul>\n<li>互斥条件；</li>\n<li>持有并等待条件；</li>\n<li>不可剥夺条件；</li>\n<li>环路等待条件；</li>\n</ul>\n<h3 id=\"1-1-互斥条件\"><a href=\"#1-1-互斥条件\" class=\"headerlink\" title=\"1.1 互斥条件\"></a>1.1 互斥条件</h3><p>互斥条件是指<strong>多个线程不能同时使用同一个资源</strong>。</p>\n<p>如果线程 A 已经持有的资源，不能再同时被线程 B 持有，如果线程 B 请求获取线程 A 已经占用的资源，那线程 B 只能等待，直到线程 A 释放了资源。</p>\n<h3 id=\"1-2-持有并等待条件\"><a href=\"#1-2-持有并等待条件\" class=\"headerlink\" title=\"1.2 持有并等待条件\"></a>1.2 持有并等待条件</h3><p>持有并等待条件是指，当线程 A 已经持有了资源 1，又想申请资源 2，而资源 2 已经被线程 C 持有了，所以线程 A 就会处于等待状态，但是<strong>线程 A 在等待资源 2 的同时并不会释放自己已经持有的资源 1</strong>。</p>\n<h3 id=\"1-3-不可剥夺条件\"><a href=\"#1-3-不可剥夺条件\" class=\"headerlink\" title=\"1.3 不可剥夺条件\"></a>1.3 不可剥夺条件</h3><p>不可剥夺条件是指，当线程已经持有了资源 ，<strong>在自己使用完之前不能被其他线程获取</strong>，线程 B 如果也想使用此资源，则只能在线程 A 使用完并释放后才能获取。</p>\n<h3 id=\"1-4-环路等待条件\"><a href=\"#1-4-环路等待条件\" class=\"headerlink\" title=\"1.4 环路等待条件\"></a>1.4 环路等待条件</h3><p>环路等待条件指的是，在死锁发生的时候，<strong>两个线程获取资源的顺序构成了环形链</strong>。</p>\n<p>比如，线程 A 已经持有资源 2，而想请求资源 1， 线程 B 已经获取了资源 1，而想请求资源 2，这就形成资源请求等待的环形图。</p>\n<h2 id=\"2-模拟死锁问题的产生\"><a href=\"#2-模拟死锁问题的产生\" class=\"headerlink\" title=\"2.模拟死锁问题的产生\"></a>2.模拟死锁问题的产生</h2><p>我们用代码来模拟死锁问题的产生。</p>\n<p>首先，我们先创建 2 个线程，分别为线程 A 和 线程 B，然后有两个互斥锁，分别是 mutex_A 和 mutex_B，代码如下：</p>\n<div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #C792EA\">pthread_mutex_t</span><span style=\"color: #BABED8\"> mutex_A </span><span style=\"color: #89DDFF\">=</span><span style=\"color: #BABED8\"> PTHREAD_MUTEX_INITIALIZER</span><span style=\"color: #89DDFF\">;</span></span>\n<span class=\"line\"><span style=\"color: #C792EA\">pthread_mutex_t</span><span style=\"color: #BABED8\"> mutex_B </span><span style=\"color: #89DDFF\">=</span><span style=\"color: #BABED8\"> PTHREAD_MUTEX_INITIALIZER</span><span style=\"color: #89DDFF\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #C792EA\">int</span><span style=\"color: #BABED8\"> </span><span style=\"color: #82AAFF\">main</span><span style=\"color: #89DDFF\">()</span></span>\n<span class=\"line\"><span style=\"color: #89DDFF\">&#123;</span></span>\n<span class=\"line\"><span style=\"color: #F07178\">    </span><span style=\"color: #C792EA\">pthread_t</span><span style=\"color: #F07178\"> tidA</span><span style=\"color: #89DDFF\">,</span><span style=\"color: #F07178\"> tidB</span><span style=\"color: #89DDFF\">;</span></span>\n<span class=\"line\"><span style=\"color: #F07178\">    </span></span>\n<span class=\"line\"><span style=\"color: #89DDFF\">    </span><span style=\"color: #676E95; font-style: italic\">//创建两个线程</span></span>\n<span class=\"line\"><span style=\"color: #F07178\">    </span><span style=\"color: #82AAFF\">pthread_create</span><span style=\"color: #89DDFF\">(&amp;</span><span style=\"color: #F07178\">tidA</span><span style=\"color: #89DDFF\">,</span><span style=\"color: #F07178\"> </span><span style=\"color: #89DDFF\">NULL,</span><span style=\"color: #F07178\"> threadA_proc</span><span style=\"color: #89DDFF\">,</span><span style=\"color: #F07178\"> </span><span style=\"color: #89DDFF\">NULL);</span></span>\n<span class=\"line\"><span style=\"color: #F07178\">    </span><span style=\"color: #82AAFF\">pthread_create</span><span style=\"color: #89DDFF\">(&amp;</span><span style=\"color: #F07178\">tidB</span><span style=\"color: #89DDFF\">,</span><span style=\"color: #F07178\"> </span><span style=\"color: #89DDFF\">NULL,</span><span style=\"color: #F07178\"> threadB_proc</span><span style=\"color: #89DDFF\">,</span><span style=\"color: #F07178\"> </span><span style=\"color: #89DDFF\">NULL);</span></span>\n<span class=\"line\"><span style=\"color: #F07178\">    </span></span>\n<span class=\"line\"><span style=\"color: #F07178\">    </span><span style=\"color: #82AAFF\">pthread_join</span><span style=\"color: #89DDFF\">(</span><span style=\"color: #F07178\">tidA</span><span style=\"color: #89DDFF\">,</span><span style=\"color: #F07178\"> </span><span style=\"color: #89DDFF\">NULL);</span></span>\n<span class=\"line\"><span style=\"color: #F07178\">    </span><span style=\"color: #82AAFF\">pthread_join</span><span style=\"color: #89DDFF\">(</span><span style=\"color: #F07178\">tidB</span><span style=\"color: #89DDFF\">,</span><span style=\"color: #F07178\"> </span><span style=\"color: #89DDFF\">NULL);</span></span>\n<span class=\"line\"><span style=\"color: #F07178\">    </span></span>\n<span class=\"line\"><span style=\"color: #F07178\">    </span><span style=\"color: #82AAFF\">printf</span><span style=\"color: #89DDFF\">(</span><span style=\"color: #89DDFF\">&quot;</span><span style=\"color: #C3E88D\">exit</span><span style=\"color: #BABED8\">\\n</span><span style=\"color: #89DDFF\">&quot;</span><span style=\"color: #89DDFF\">);</span></span>\n<span class=\"line\"><span style=\"color: #F07178\">    </span></span>\n<span class=\"line\"><span style=\"color: #F07178\">    </span><span style=\"color: #89DDFF; font-style: italic\">return</span><span style=\"color: #F07178\"> </span><span style=\"color: #F78C6C\">0</span><span style=\"color: #89DDFF\">;</span></span>\n<span class=\"line\"><span style=\"color: #89DDFF\">&#125;</span></span></code></pre></div><p>接下来，我们看下线程 A 函数做了什么。</p>\n<div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #676E95; font-style: italic\">//线程函数 A</span></span>\n<span class=\"line\"><span style=\"color: #C792EA\">void</span><span style=\"color: #BABED8\"> </span><span style=\"color: #89DDFF\">*</span><span style=\"color: #82AAFF\">threadA_proc</span><span style=\"color: #89DDFF\">(</span><span style=\"color: #C792EA\">void</span><span style=\"color: #BABED8\"> </span><span style=\"color: #89DDFF\">*</span><span style=\"color: #BABED8; font-style: italic\">data</span><span style=\"color: #89DDFF\">)</span></span>\n<span class=\"line\"><span style=\"color: #89DDFF\">&#123;</span></span>\n<span class=\"line\"><span style=\"color: #F07178\">    </span><span style=\"color: #82AAFF\">printf</span><span style=\"color: #89DDFF\">(</span><span style=\"color: #89DDFF\">&quot;</span><span style=\"color: #C3E88D\">thread A waiting get ResourceA </span><span style=\"color: #BABED8\">\\n</span><span style=\"color: #89DDFF\">&quot;</span><span style=\"color: #89DDFF\">);</span></span>\n<span class=\"line\"><span style=\"color: #F07178\">    </span><span style=\"color: #82AAFF\">pthread_mutex_lock</span><span style=\"color: #89DDFF\">(&amp;</span><span style=\"color: #F07178\">mutex_A</span><span style=\"color: #89DDFF\">);</span></span>\n<span class=\"line\"><span style=\"color: #F07178\">    </span><span style=\"color: #82AAFF\">printf</span><span style=\"color: #89DDFF\">(</span><span style=\"color: #89DDFF\">&quot;</span><span style=\"color: #C3E88D\">thread A got ResourceA </span><span style=\"color: #BABED8\">\\n</span><span style=\"color: #89DDFF\">&quot;</span><span style=\"color: #89DDFF\">);</span></span>\n<span class=\"line\"><span style=\"color: #F07178\">    </span></span>\n<span class=\"line\"><span style=\"color: #F07178\">    </span><span style=\"color: #82AAFF\">sleep</span><span style=\"color: #89DDFF\">(</span><span style=\"color: #F78C6C\">1</span><span style=\"color: #89DDFF\">);</span></span>\n<span class=\"line\"><span style=\"color: #F07178\">    </span></span>\n<span class=\"line\"><span style=\"color: #F07178\">    </span><span style=\"color: #82AAFF\">printf</span><span style=\"color: #89DDFF\">(</span><span style=\"color: #89DDFF\">&quot;</span><span style=\"color: #C3E88D\">thread A waiting get ResourceB </span><span style=\"color: #BABED8\">\\n</span><span style=\"color: #89DDFF\">&quot;</span><span style=\"color: #89DDFF\">);</span></span>\n<span class=\"line\"><span style=\"color: #F07178\">    </span><span style=\"color: #82AAFF\">pthread_mutex_lock</span><span style=\"color: #89DDFF\">(&amp;</span><span style=\"color: #F07178\">mutex_B</span><span style=\"color: #89DDFF\">);</span></span>\n<span class=\"line\"><span style=\"color: #F07178\">    </span><span style=\"color: #82AAFF\">printf</span><span style=\"color: #89DDFF\">(</span><span style=\"color: #89DDFF\">&quot;</span><span style=\"color: #C3E88D\">thread A got ResourceB </span><span style=\"color: #BABED8\">\\n</span><span style=\"color: #89DDFF\">&quot;</span><span style=\"color: #89DDFF\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #F07178\">    </span><span style=\"color: #82AAFF\">pthread_mutex_unlock</span><span style=\"color: #89DDFF\">(&amp;</span><span style=\"color: #F07178\">mutex_B</span><span style=\"color: #89DDFF\">);</span></span>\n<span class=\"line\"><span style=\"color: #F07178\">    </span><span style=\"color: #82AAFF\">pthread_mutex_unlock</span><span style=\"color: #89DDFF\">(&amp;</span><span style=\"color: #F07178\">mutex_A</span><span style=\"color: #89DDFF\">);</span></span>\n<span class=\"line\"><span style=\"color: #F07178\">    </span><span style=\"color: #89DDFF; font-style: italic\">return</span><span style=\"color: #F07178\"> </span><span style=\"color: #89DDFF\">(</span><span style=\"color: #C792EA\">void</span><span style=\"color: #F07178\"> </span><span style=\"color: #89DDFF\">*)</span><span style=\"color: #F78C6C\">0</span><span style=\"color: #89DDFF\">;</span></span>\n<span class=\"line\"><span style=\"color: #89DDFF\">&#125;</span></span></code></pre></div><p>可以看到，线程 A 函数的过程：</p>\n<ul>\n<li>先获取互斥锁 A，然后睡眠 1 秒；</li>\n<li>再获取互斥锁 B，然后释放互斥锁 B；</li>\n<li>最后释放互斥锁 A；</li>\n</ul>\n<div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #676E95; font-style: italic\">//线程函数 B</span></span>\n<span class=\"line\"><span style=\"color: #C792EA\">void</span><span style=\"color: #BABED8\"> </span><span style=\"color: #89DDFF\">*</span><span style=\"color: #82AAFF\">threadB_proc</span><span style=\"color: #89DDFF\">(</span><span style=\"color: #C792EA\">void</span><span style=\"color: #BABED8\"> </span><span style=\"color: #89DDFF\">*</span><span style=\"color: #BABED8; font-style: italic\">data</span><span style=\"color: #89DDFF\">)</span></span>\n<span class=\"line\"><span style=\"color: #89DDFF\">&#123;</span></span>\n<span class=\"line\"><span style=\"color: #F07178\">    </span><span style=\"color: #82AAFF\">printf</span><span style=\"color: #89DDFF\">(</span><span style=\"color: #89DDFF\">&quot;</span><span style=\"color: #C3E88D\">thread B waiting get ResourceB </span><span style=\"color: #BABED8\">\\n</span><span style=\"color: #89DDFF\">&quot;</span><span style=\"color: #89DDFF\">);</span></span>\n<span class=\"line\"><span style=\"color: #F07178\">    </span><span style=\"color: #82AAFF\">pthread_mutex_lock</span><span style=\"color: #89DDFF\">(&amp;</span><span style=\"color: #F07178\">mutex_B</span><span style=\"color: #89DDFF\">);</span></span>\n<span class=\"line\"><span style=\"color: #F07178\">    </span><span style=\"color: #82AAFF\">printf</span><span style=\"color: #89DDFF\">(</span><span style=\"color: #89DDFF\">&quot;</span><span style=\"color: #C3E88D\">thread B got ResourceB </span><span style=\"color: #BABED8\">\\n</span><span style=\"color: #89DDFF\">&quot;</span><span style=\"color: #89DDFF\">);</span></span>\n<span class=\"line\"><span style=\"color: #F07178\">    </span></span>\n<span class=\"line\"><span style=\"color: #F07178\">    </span><span style=\"color: #82AAFF\">sleep</span><span style=\"color: #89DDFF\">(</span><span style=\"color: #F78C6C\">1</span><span style=\"color: #89DDFF\">);</span></span>\n<span class=\"line\"><span style=\"color: #F07178\">    </span></span>\n<span class=\"line\"><span style=\"color: #F07178\">    </span><span style=\"color: #82AAFF\">printf</span><span style=\"color: #89DDFF\">(</span><span style=\"color: #89DDFF\">&quot;</span><span style=\"color: #C3E88D\">thread B waiting  get ResourceA </span><span style=\"color: #BABED8\">\\n</span><span style=\"color: #89DDFF\">&quot;</span><span style=\"color: #89DDFF\">);</span></span>\n<span class=\"line\"><span style=\"color: #F07178\">    </span><span style=\"color: #82AAFF\">pthread_mutex_lock</span><span style=\"color: #89DDFF\">(&amp;</span><span style=\"color: #F07178\">mutex_A</span><span style=\"color: #89DDFF\">);</span></span>\n<span class=\"line\"><span style=\"color: #F07178\">    </span><span style=\"color: #82AAFF\">printf</span><span style=\"color: #89DDFF\">(</span><span style=\"color: #89DDFF\">&quot;</span><span style=\"color: #C3E88D\">thread B got ResourceA </span><span style=\"color: #BABED8\">\\n</span><span style=\"color: #89DDFF\">&quot;</span><span style=\"color: #89DDFF\">);</span></span>\n<span class=\"line\"><span style=\"color: #F07178\">    </span></span>\n<span class=\"line\"><span style=\"color: #F07178\">    </span><span style=\"color: #82AAFF\">pthread_mutex_unlock</span><span style=\"color: #89DDFF\">(&amp;</span><span style=\"color: #F07178\">mutex_A</span><span style=\"color: #89DDFF\">);</span></span>\n<span class=\"line\"><span style=\"color: #F07178\">    </span><span style=\"color: #82AAFF\">pthread_mutex_unlock</span><span style=\"color: #89DDFF\">(&amp;</span><span style=\"color: #F07178\">mutex_B</span><span style=\"color: #89DDFF\">);</span></span>\n<span class=\"line\"><span style=\"color: #F07178\">    </span><span style=\"color: #89DDFF; font-style: italic\">return</span><span style=\"color: #F07178\"> </span><span style=\"color: #89DDFF\">(</span><span style=\"color: #C792EA\">void</span><span style=\"color: #F07178\"> </span><span style=\"color: #89DDFF\">*)</span><span style=\"color: #F78C6C\">0</span><span style=\"color: #89DDFF\">;</span></span>\n<span class=\"line\"><span style=\"color: #89DDFF\">&#125;</span></span></code></pre></div><p>可以看到，线程 B 函数的过程：</p>\n<ul>\n<li>先获取互斥锁 B，然后睡眠 1 秒；</li>\n<li>再获取互斥锁 A，然后释放互斥锁 A；</li>\n<li>最后释放互斥锁 B；</li>\n</ul>\n<p>然后，我们运行这个程序，运行结果如下：</p>\n<div class=\"language-shell\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">shell</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #FFCB6B\">thread</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">B</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">waiting</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">get</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">ResourceB</span><span style=\"color: #BABED8\"> </span></span>\n<span class=\"line\"><span style=\"color: #FFCB6B\">thread</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">B</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">got</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">ResourceB</span><span style=\"color: #BABED8\"> </span></span>\n<span class=\"line\"><span style=\"color: #FFCB6B\">thread</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">A</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">waiting</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">get</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">ResourceA</span><span style=\"color: #BABED8\"> </span></span>\n<span class=\"line\"><span style=\"color: #FFCB6B\">thread</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">A</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">got</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">ResourceA</span><span style=\"color: #BABED8\"> </span></span>\n<span class=\"line\"><span style=\"color: #FFCB6B\">thread</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">B</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">waiting</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">get</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">ResourceA</span><span style=\"color: #BABED8\"> </span></span>\n<span class=\"line\"><span style=\"color: #FFCB6B\">thread</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">A</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">waiting</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">get</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">ResourceB</span><span style=\"color: #BABED8\"> </span></span>\n<span class=\"line\"><span style=\"color: #FFCB6B\">//</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">阻塞中。。。</span></span></code></pre></div><p>可以看到线程 B 在等待互斥锁 A 的释放，线程 A 在等待互斥锁 B 的释放，双方都在等待对方资源的释放，很明显，产生了死锁问题。</p>\n<h2 id=\"3-利用工具排查死锁问题\"><a href=\"#3-利用工具排查死锁问题\" class=\"headerlink\" title=\"3.利用工具排查死锁问题\"></a>3.利用工具排查死锁问题</h2><p>如果你想排查你的 Java 程序是否死锁，则可以使用 <code>jstack</code> 工具，它是 jdk 自带的线程堆栈分析工具。</p>\n<p>死锁代码例子是 C 写的，在 Linux 下，我们可以使用 <code>pstack</code> + <code>gdb</code> 工具来定位死锁问题。</p>\n<p>pstack 命令可以显示每个线程的栈跟踪信息（函数调用过程），它的使用方式也很简单，只需要 <code>pstack &lt;pid&gt;</code> 就可以了。</p>\n<p>那么，在定位死锁问题时，我们可以多次执行 pstack 命令查看线程的函数调用过程，多次对比结果，确认哪几个线程一直没有变化，且是因为在等待锁，那么大概率是由于死锁问题导致的。</p>\n<p>我用 pstack 输出了我前面模拟死锁问题的进程的所有线程的情况，我多次执行命令后，其结果都一样，如下：</p>\n<div class=\"language-shell\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">shell</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #FFCB6B\">$</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">pstack</span><span style=\"color: #BABED8\"> </span><span style=\"color: #F78C6C\">87746</span></span>\n<span class=\"line\"><span style=\"color: #FFCB6B\">Thread</span><span style=\"color: #BABED8\"> </span><span style=\"color: #F78C6C\">3</span><span style=\"color: #BABED8\"> (Thread </span><span style=\"color: #F78C6C\">0x7f60a610a700</span><span style=\"color: #BABED8\"> (LWP </span><span style=\"color: #F78C6C\">87747</span><span style=\"color: #BABED8\">)):</span></span>\n<span class=\"line\"><span style=\"color: #676E95; font-style: italic\">#0  0x0000003720e0da1d in __lll_lock_wait () from /lib64/libpthread.so.0</span></span>\n<span class=\"line\"><span style=\"color: #676E95; font-style: italic\">#1  0x0000003720e093ca in _L_lock_829 () from /lib64/libpthread.so.0</span></span>\n<span class=\"line\"><span style=\"color: #676E95; font-style: italic\">#2  0x0000003720e09298 in pthread_mutex_lock () from /lib64/libpthread.so.0</span></span>\n<span class=\"line\"><span style=\"color: #676E95; font-style: italic\">#3  0x0000000000400725 in threadA_proc ()</span></span>\n<span class=\"line\"><span style=\"color: #676E95; font-style: italic\">#4  0x0000003720e07893 in start_thread () from /lib64/libpthread.so.0</span></span>\n<span class=\"line\"><span style=\"color: #676E95; font-style: italic\">#5  0x00000037206f4bfd in clone () from /lib64/libc.so.6</span></span>\n<span class=\"line\"><span style=\"color: #FFCB6B\">Thread</span><span style=\"color: #BABED8\"> </span><span style=\"color: #F78C6C\">2</span><span style=\"color: #BABED8\"> (Thread </span><span style=\"color: #F78C6C\">0x7f60a5709700</span><span style=\"color: #BABED8\"> (LWP </span><span style=\"color: #F78C6C\">87748</span><span style=\"color: #BABED8\">)):</span></span>\n<span class=\"line\"><span style=\"color: #676E95; font-style: italic\">#0  0x0000003720e0da1d in __lll_lock_wait () from /lib64/libpthread.so.0</span></span>\n<span class=\"line\"><span style=\"color: #676E95; font-style: italic\">#1  0x0000003720e093ca in _L_lock_829 () from /lib64/libpthread.so.0</span></span>\n<span class=\"line\"><span style=\"color: #676E95; font-style: italic\">#2  0x0000003720e09298 in pthread_mutex_lock () from /lib64/libpthread.so.0</span></span>\n<span class=\"line\"><span style=\"color: #676E95; font-style: italic\">#3  0x0000000000400792 in threadB_proc ()</span></span>\n<span class=\"line\"><span style=\"color: #676E95; font-style: italic\">#4  0x0000003720e07893 in start_thread () from /lib64/libpthread.so.0</span></span>\n<span class=\"line\"><span style=\"color: #676E95; font-style: italic\">#5  0x00000037206f4bfd in clone () from /lib64/libc.so.6</span></span>\n<span class=\"line\"><span style=\"color: #FFCB6B\">Thread</span><span style=\"color: #BABED8\"> </span><span style=\"color: #F78C6C\">1</span><span style=\"color: #BABED8\"> (Thread </span><span style=\"color: #F78C6C\">0x7f60a610c700</span><span style=\"color: #BABED8\"> (LWP </span><span style=\"color: #F78C6C\">87746</span><span style=\"color: #BABED8\">)):</span></span>\n<span class=\"line\"><span style=\"color: #676E95; font-style: italic\">#0  0x0000003720e080e5 in pthread_join () from /lib64/libpthread.so.0</span></span>\n<span class=\"line\"><span style=\"color: #676E95; font-style: italic\">#1  0x0000000000400806 in main ()</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #82AAFF\">....</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #FFCB6B\">$</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">pstack</span><span style=\"color: #BABED8\"> </span><span style=\"color: #F78C6C\">87746</span></span>\n<span class=\"line\"><span style=\"color: #FFCB6B\">Thread</span><span style=\"color: #BABED8\"> </span><span style=\"color: #F78C6C\">3</span><span style=\"color: #BABED8\"> (Thread </span><span style=\"color: #F78C6C\">0x7f60a610a700</span><span style=\"color: #BABED8\"> (LWP </span><span style=\"color: #F78C6C\">87747</span><span style=\"color: #BABED8\">)):</span></span>\n<span class=\"line\"><span style=\"color: #676E95; font-style: italic\">#0  0x0000003720e0da1d in __lll_lock_wait () from /lib64/libpthread.so.0</span></span>\n<span class=\"line\"><span style=\"color: #676E95; font-style: italic\">#1  0x0000003720e093ca in _L_lock_829 () from /lib64/libpthread.so.0</span></span>\n<span class=\"line\"><span style=\"color: #676E95; font-style: italic\">#2  0x0000003720e09298 in pthread_mutex_lock () from /lib64/libpthread.so.0</span></span>\n<span class=\"line\"><span style=\"color: #676E95; font-style: italic\">#3  0x0000000000400725 in threadA_proc ()</span></span>\n<span class=\"line\"><span style=\"color: #676E95; font-style: italic\">#4  0x0000003720e07893 in start_thread () from /lib64/libpthread.so.0</span></span>\n<span class=\"line\"><span style=\"color: #676E95; font-style: italic\">#5  0x00000037206f4bfd in clone () from /lib64/libc.so.6</span></span>\n<span class=\"line\"><span style=\"color: #FFCB6B\">Thread</span><span style=\"color: #BABED8\"> </span><span style=\"color: #F78C6C\">2</span><span style=\"color: #BABED8\"> (Thread </span><span style=\"color: #F78C6C\">0x7f60a5709700</span><span style=\"color: #BABED8\"> (LWP </span><span style=\"color: #F78C6C\">87748</span><span style=\"color: #BABED8\">)):</span></span>\n<span class=\"line\"><span style=\"color: #676E95; font-style: italic\">#0  0x0000003720e0da1d in __lll_lock_wait () from /lib64/libpthread.so.0</span></span>\n<span class=\"line\"><span style=\"color: #676E95; font-style: italic\">#1  0x0000003720e093ca in _L_lock_829 () from /lib64/libpthread.so.0</span></span>\n<span class=\"line\"><span style=\"color: #676E95; font-style: italic\">#2  0x0000003720e09298 in pthread_mutex_lock () from /lib64/libpthread.so.0</span></span>\n<span class=\"line\"><span style=\"color: #676E95; font-style: italic\">#3  0x0000000000400792 in threadB_proc ()</span></span>\n<span class=\"line\"><span style=\"color: #676E95; font-style: italic\">#4  0x0000003720e07893 in start_thread () from /lib64/libpthread.so.0</span></span>\n<span class=\"line\"><span style=\"color: #676E95; font-style: italic\">#5  0x00000037206f4bfd in clone () from /lib64/libc.so.6</span></span>\n<span class=\"line\"><span style=\"color: #FFCB6B\">Thread</span><span style=\"color: #BABED8\"> </span><span style=\"color: #F78C6C\">1</span><span style=\"color: #BABED8\"> (Thread </span><span style=\"color: #F78C6C\">0x7f60a610c700</span><span style=\"color: #BABED8\"> (LWP </span><span style=\"color: #F78C6C\">87746</span><span style=\"color: #BABED8\">)):</span></span>\n<span class=\"line\"><span style=\"color: #676E95; font-style: italic\">#0  0x0000003720e080e5 in pthread_join () from /lib64/libpthread.so.0</span></span>\n<span class=\"line\"><span style=\"color: #676E95; font-style: italic\">#1  0x0000000000400806 in main ()</span></span></code></pre></div><p>可以看到，Thread 2 和 Thread 3 一直阻塞获取锁（<em>pthread_mutex_lock</em>）的过程，而且 pstack 多次输出信息都没有变化，那么可能大概率发生了死锁。</p>\n<p>但是，还不能够确认这两个线程是在互相等待对方的锁的释放，因为我们看不到它们是等在哪个锁对象，于是我们可以使用 gdb 工具进一步确认。</p>\n<p>整个 gdb 调试过程，如下：</p>\n<div class=\"language-shell\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">shell</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #FFCB6B\">//</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">gdb</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">命令</span></span>\n<span class=\"line\"><span style=\"color: #FFCB6B\">$</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">gdb</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">-p</span><span style=\"color: #BABED8\"> </span><span style=\"color: #F78C6C\">87746</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #FFCB6B\">//</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">打印所有的线程信息</span></span>\n<span class=\"line\"><span style=\"color: #89DDFF\">(</span><span style=\"color: #FFCB6B\">gdb</span><span style=\"color: #89DDFF\">)</span><span style=\"color: #BABED8\"> info thread</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">  </span><span style=\"color: #FFCB6B\">3</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">Thread</span><span style=\"color: #BABED8\"> </span><span style=\"color: #F78C6C\">0x7f60a610a700</span><span style=\"color: #BABED8\"> (LWP </span><span style=\"color: #F78C6C\">87747</span><span style=\"color: #BABED8\">)  0x0000003720e0da1d </span><span style=\"color: #89DDFF; font-style: italic\">in</span><span style=\"color: #BABED8\"> </span><span style=\"color: #82AAFF\">__lll_lock_wait</span><span style=\"color: #BABED8\"> </span><span style=\"color: #89DDFF\">()</span><span style=\"color: #BABED8\"> from /lib64/libpthread.so.0</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">  2 Thread 0x7f60a5709700 </span><span style=\"color: #89DDFF\">(</span><span style=\"color: #FFCB6B\">LWP</span><span style=\"color: #BABED8\"> </span><span style=\"color: #F78C6C\">87748</span><span style=\"color: #89DDFF\">)</span><span style=\"color: #BABED8\">  0x0000003720e0da1d </span><span style=\"color: #89DDFF; font-style: italic\">in</span><span style=\"color: #BABED8\"> </span><span style=\"color: #82AAFF\">__lll_lock_wait</span><span style=\"color: #BABED8\"> </span><span style=\"color: #89DDFF\">()</span><span style=\"color: #BABED8\"> from /lib64/libpthread.so.0</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">* 1 Thread 0x7f60a610c700 </span><span style=\"color: #89DDFF\">(</span><span style=\"color: #FFCB6B\">LWP</span><span style=\"color: #BABED8\"> </span><span style=\"color: #F78C6C\">87746</span><span style=\"color: #89DDFF\">)</span><span style=\"color: #BABED8\">  0x0000003720e080e5 </span><span style=\"color: #89DDFF; font-style: italic\">in</span><span style=\"color: #BABED8\"> </span><span style=\"color: #82AAFF\">pthread_join</span><span style=\"color: #BABED8\"> </span><span style=\"color: #89DDFF\">()</span><span style=\"color: #BABED8\"> from /lib64/libpthread.so.0</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">//最左边的 * 表示 gdb 锁定的线程，切换到第二个线程去查看</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #BABED8\">// 切换到第2个线程</span></span>\n<span class=\"line\"><span style=\"color: #89DDFF\">(</span><span style=\"color: #FFCB6B\">gdb</span><span style=\"color: #89DDFF\">)</span><span style=\"color: #BABED8\"> thread 2</span></span>\n<span class=\"line\"><span style=\"color: #89DDFF\">[</span><span style=\"color: #BABED8\">Switching to thread </span><span style=\"color: #F78C6C\">2</span><span style=\"color: #BABED8\"> (Thread </span><span style=\"color: #F78C6C\">0x7f60a5709700</span><span style=\"color: #BABED8\"> (LWP </span><span style=\"color: #F78C6C\">87748</span><span style=\"color: #BABED8\">))</span><span style=\"color: #89DDFF\">]</span><span style=\"color: #BABED8\">#0  0x0000003720e0da1d </span><span style=\"color: #89DDFF; font-style: italic\">in</span><span style=\"color: #BABED8\"> </span><span style=\"color: #82AAFF\">__lll_lock_wait</span><span style=\"color: #BABED8\"> </span><span style=\"color: #89DDFF\">()</span><span style=\"color: #BABED8\"> from /lib64/libpthread.so.0 </span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #BABED8\">// bt 可以打印函数堆栈，却无法看到函数参数，跟 pstack 命令一样 </span></span>\n<span class=\"line\"><span style=\"color: #89DDFF\">(</span><span style=\"color: #FFCB6B\">gdb</span><span style=\"color: #89DDFF\">)</span><span style=\"color: #BABED8\"> bt</span></span>\n<span class=\"line\"><span style=\"color: #676E95; font-style: italic\">#0  0x0000003720e0da1d in __lll_lock_wait () from /lib64/libpthread.so.0</span></span>\n<span class=\"line\"><span style=\"color: #676E95; font-style: italic\">#1  0x0000003720e093ca in _L_lock_829 () from /lib64/libpthread.so.0</span></span>\n<span class=\"line\"><span style=\"color: #676E95; font-style: italic\">#2  0x0000003720e09298 in pthread_mutex_lock () from /lib64/libpthread.so.0</span></span>\n<span class=\"line\"><span style=\"color: #676E95; font-style: italic\">#3  0x0000000000400792 in threadB_proc (data=0x0) at dead_lock.c:25</span></span>\n<span class=\"line\"><span style=\"color: #676E95; font-style: italic\">#4  0x0000003720e07893 in start_thread () from /lib64/libpthread.so.0</span></span>\n<span class=\"line\"><span style=\"color: #676E95; font-style: italic\">#5  0x00000037206f4bfd in clone () from /lib64/libc.so.6</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #FFCB6B\">//</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">打印第三帧信息，每次函数调用都会有压栈的过程，而</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">frame</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">则记录栈中的帧信息</span></span>\n<span class=\"line\"><span style=\"color: #89DDFF\">(</span><span style=\"color: #FFCB6B\">gdb</span><span style=\"color: #89DDFF\">)</span><span style=\"color: #BABED8\"> frame 3</span></span>\n<span class=\"line\"><span style=\"color: #676E95; font-style: italic\">#3  0x0000000000400792 in threadB_proc (data=0x0) at dead_lock.c:25</span></span>\n<span class=\"line\"><span style=\"color: #FFCB6B\">27</span><span style=\"color: #BABED8\">    </span><span style=\"color: #C3E88D\">printf</span><span style=\"color: #89DDFF\">(</span><span style=\"color: #FFCB6B\">&quot;thread B waiting get ResourceA \\n&quot;</span><span style=\"color: #89DDFF\">);</span></span>\n<span class=\"line\"><span style=\"color: #FFCB6B\">28</span><span style=\"color: #BABED8\">    </span><span style=\"color: #C3E88D\">pthread_mutex_lock</span><span style=\"color: #89DDFF\">(&amp;</span><span style=\"color: #FFCB6B\">mutex_A</span><span style=\"color: #89DDFF\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #FFCB6B\">//</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">打印mutex_A的值</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">,</span><span style=\"color: #BABED8\">  </span><span style=\"color: #C3E88D\">__owner表示gdb中标示线程的值，即LWP</span></span>\n<span class=\"line\"><span style=\"color: #89DDFF\">(</span><span style=\"color: #FFCB6B\">gdb</span><span style=\"color: #89DDFF\">)</span><span style=\"color: #BABED8\"> p mutex_A</span></span>\n<span class=\"line\"><span style=\"color: #BABED8; font-style: italic\">$1</span><span style=\"color: #BABED8\"> = </span><span style=\"color: #89DDFF\">&#123;</span><span style=\"color: #FFCB6B\">__data</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">=</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">&#123;__lock</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">=</span><span style=\"color: #BABED8\"> </span><span style=\"color: #F78C6C\">2</span><span style=\"color: #C3E88D\">,</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">__count</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">=</span><span style=\"color: #BABED8\"> </span><span style=\"color: #F78C6C\">0</span><span style=\"color: #C3E88D\">,</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">__owner</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">=</span><span style=\"color: #BABED8\"> </span><span style=\"color: #F78C6C\">87747</span><span style=\"color: #C3E88D\">,</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">__nusers</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">=</span><span style=\"color: #BABED8\"> </span><span style=\"color: #F78C6C\">1</span><span style=\"color: #C3E88D\">,</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">__kind</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">=</span><span style=\"color: #BABED8\"> </span><span style=\"color: #F78C6C\">0</span><span style=\"color: #C3E88D\">,</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">__spins</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">=</span><span style=\"color: #BABED8\"> </span><span style=\"color: #F78C6C\">0</span><span style=\"color: #C3E88D\">,</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">__list</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">=</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">&#123;__prev</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">=</span><span style=\"color: #BABED8\"> </span><span style=\"color: #F78C6C\">0x0</span><span style=\"color: #C3E88D\">,</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">__next</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">=</span><span style=\"color: #BABED8\"> </span><span style=\"color: #F78C6C\">0x0</span><span style=\"color: #C3E88D\">&#125;&#125;,</span><span style=\"color: #BABED8\"> </span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">  </span><span style=\"color: #FFCB6B\">__size</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">=</span><span style=\"color: #BABED8\"> </span><span style=\"color: #89DDFF\">&quot;</span><span style=\"color: #C3E88D\">\\002\\000\\000\\000\\000\\000\\000\\000\\303V\\001\\000\\001</span><span style=\"color: #89DDFF\">&quot;</span><span style=\"color: #C3E88D\">,</span><span style=\"color: #BABED8\"> </span><span style=\"color: #89DDFF\">&#39;</span><span style=\"color: #C3E88D\">\\000</span><span style=\"color: #89DDFF\">&#39;</span><span style=\"color: #BABED8\"> </span><span style=\"color: #89DDFF\">&lt;</span><span style=\"color: #C3E88D\">repeats</span><span style=\"color: #BABED8\"> </span><span style=\"color: #F78C6C\">26</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">time</span><span style=\"color: #BABED8\">s</span><span style=\"color: #89DDFF\">&gt;</span><span style=\"color: #C3E88D\">,</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">__align</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">=</span><span style=\"color: #BABED8\"> </span><span style=\"color: #F78C6C\">2</span><span style=\"color: #C3E88D\">&#125;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #FFCB6B\">//</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">打印mutex_B的值</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">,</span><span style=\"color: #BABED8\">  </span><span style=\"color: #C3E88D\">__owner表示gdb中标示线程的值，即LWP</span></span>\n<span class=\"line\"><span style=\"color: #89DDFF\">(</span><span style=\"color: #FFCB6B\">gdb</span><span style=\"color: #89DDFF\">)</span><span style=\"color: #BABED8\"> p mutex_B</span></span>\n<span class=\"line\"><span style=\"color: #BABED8; font-style: italic\">$2</span><span style=\"color: #BABED8\"> = </span><span style=\"color: #89DDFF\">&#123;</span><span style=\"color: #FFCB6B\">__data</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">=</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">&#123;__lock</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">=</span><span style=\"color: #BABED8\"> </span><span style=\"color: #F78C6C\">2</span><span style=\"color: #C3E88D\">,</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">__count</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">=</span><span style=\"color: #BABED8\"> </span><span style=\"color: #F78C6C\">0</span><span style=\"color: #C3E88D\">,</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">__owner</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">=</span><span style=\"color: #BABED8\"> </span><span style=\"color: #F78C6C\">87748</span><span style=\"color: #C3E88D\">,</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">__nusers</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">=</span><span style=\"color: #BABED8\"> </span><span style=\"color: #F78C6C\">1</span><span style=\"color: #C3E88D\">,</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">__kind</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">=</span><span style=\"color: #BABED8\"> </span><span style=\"color: #F78C6C\">0</span><span style=\"color: #C3E88D\">,</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">__spins</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">=</span><span style=\"color: #BABED8\"> </span><span style=\"color: #F78C6C\">0</span><span style=\"color: #C3E88D\">,</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">__list</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">=</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">&#123;__prev</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">=</span><span style=\"color: #BABED8\"> </span><span style=\"color: #F78C6C\">0x0</span><span style=\"color: #C3E88D\">,</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">__next</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">=</span><span style=\"color: #BABED8\"> </span><span style=\"color: #F78C6C\">0x0</span><span style=\"color: #C3E88D\">&#125;&#125;,</span><span style=\"color: #BABED8\"> </span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">  </span><span style=\"color: #FFCB6B\">__size</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">=</span><span style=\"color: #BABED8\"> </span><span style=\"color: #89DDFF\">&quot;</span><span style=\"color: #C3E88D\">\\002\\000\\000\\000\\000\\000\\000\\000\\304V\\001\\000\\001</span><span style=\"color: #89DDFF\">&quot;</span><span style=\"color: #C3E88D\">,</span><span style=\"color: #BABED8\"> </span><span style=\"color: #89DDFF\">&#39;</span><span style=\"color: #C3E88D\">\\000</span><span style=\"color: #89DDFF\">&#39;</span><span style=\"color: #BABED8\"> </span><span style=\"color: #89DDFF\">&lt;</span><span style=\"color: #C3E88D\">repeats</span><span style=\"color: #BABED8\"> </span><span style=\"color: #F78C6C\">26</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">time</span><span style=\"color: #BABED8\">s</span><span style=\"color: #89DDFF\">&gt;</span><span style=\"color: #C3E88D\">,</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">__align</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">=</span><span style=\"color: #BABED8\"> </span><span style=\"color: #F78C6C\">2</span><span style=\"color: #C3E88D\">&#125;</span><span style=\"color: #BABED8\">  </span></span></code></pre></div><p>我来解释下，上面的调试过程：</p>\n<ol>\n<li>通过 <code>info thread</code> 打印了所有的线程信息，可以看到有 3 个线程，一个是主线程（LWP 87746），另外两个都是我们自己创建的线程（LWP 87747 和 87748）；</li>\n<li>通过 <code>thread 2</code>，将切换到第 2 个线程（LWP 87748）；</li>\n<li>通过 <code>bt</code>，打印线程的调用栈信息，可以看到有 threadB_proc 函数，说明这个是线程 B 函数，也就说 LWP 87748 是线程 B;</li>\n<li>通过 <code>frame 3</code>，打印调用栈中的第三个帧的信息，可以看到线程 B 函数，在获取互斥锁 A 的时候阻塞了；</li>\n<li>通过 <code>p mutex_A</code>，打印互斥锁 A 对象信息，可以看到它被 LWP 为 87747（线程 A） 的线程持有着；</li>\n<li>通过 <code>p mutex_B</code>，打印互斥锁 B 对象信息，可以看到他被 LWP 为 87748 （线程 B） 的线程持有着；</li>\n</ol>\n<p>因为线程 B 在等待线程 A 所持有的 mutex_A, 而同时线程 A 又在等待线程 B 所拥有的mutex_B, 所以可以断定该程序发生了死锁。</p>\n<h2 id=\"4-避免死锁问题的发生\"><a href=\"#4-避免死锁问题的发生\" class=\"headerlink\" title=\"4.避免死锁问题的发生\"></a>4.避免死锁问题的发生</h2><p>前面我们提到，产生死锁的四个必要条件是：互斥条件、持有并等待条件、不可剥夺条件、环路等待条件。</p>\n<p>那么避免死锁问题就只需要破环其中一个条件就可以，最常见的并且可行的就是<strong>使用资源有序分配法，来破环环路等待条件</strong>。</p>\n<p>那什么是资源有序分配法呢？</p>\n<p>线程 A 和 线程 B 获取资源的顺序要一样，当线程 A 是先尝试获取资源 A，然后尝试获取资源 B 的时候，线程 B 同样也是先尝试获取资源 A，然后尝试获取资源 B。也就是说，线程 A 和 线程 B 总是以相同的顺序申请自己想要的资源。</p>\n<p>我们使用资源有序分配法的方式来修改前面发生死锁的代码，我们可以不改动线程 A 的代码。</p>\n<p>我们先要清楚线程 A 获取资源的顺序，它是先获取互斥锁 A，然后获取互斥锁 B。</p>\n<p>所以我们只需将线程 B 改成以相同顺序的获取资源，就可以打破死锁了。</p>\n<p>线程 B 函数改进后的代码如下：</p>\n<div class=\"language-c\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">c</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #676E95; font-style: italic\">//线程 B 函数，同线程 A 一样，先获取互斥锁 A，然后获取互斥锁 B</span></span>\n<span class=\"line\"><span style=\"color: #C792EA\">void</span><span style=\"color: #BABED8\"> </span><span style=\"color: #89DDFF\">*</span><span style=\"color: #82AAFF\">threadB_proc</span><span style=\"color: #89DDFF\">(</span><span style=\"color: #C792EA\">void</span><span style=\"color: #BABED8\"> </span><span style=\"color: #89DDFF\">*</span><span style=\"color: #BABED8; font-style: italic\">data</span><span style=\"color: #89DDFF\">)</span></span>\n<span class=\"line\"><span style=\"color: #89DDFF\">&#123;</span></span>\n<span class=\"line\"><span style=\"color: #F07178\">    </span><span style=\"color: #82AAFF\">printf</span><span style=\"color: #89DDFF\">(</span><span style=\"color: #89DDFF\">&quot;</span><span style=\"color: #C3E88D\">thread B waiting get ResourceA </span><span style=\"color: #BABED8\">\\n</span><span style=\"color: #89DDFF\">&quot;</span><span style=\"color: #89DDFF\">);</span></span>\n<span class=\"line\"><span style=\"color: #F07178\">    </span><span style=\"color: #82AAFF\">pthread_mutex_lock</span><span style=\"color: #89DDFF\">(&amp;</span><span style=\"color: #F07178\">mutex_A</span><span style=\"color: #89DDFF\">);</span></span>\n<span class=\"line\"><span style=\"color: #F07178\">    </span><span style=\"color: #82AAFF\">printf</span><span style=\"color: #89DDFF\">(</span><span style=\"color: #89DDFF\">&quot;</span><span style=\"color: #C3E88D\">thread B got ResourceA </span><span style=\"color: #BABED8\">\\n</span><span style=\"color: #89DDFF\">&quot;</span><span style=\"color: #89DDFF\">);</span></span>\n<span class=\"line\"><span style=\"color: #F07178\">    </span></span>\n<span class=\"line\"><span style=\"color: #F07178\">    </span><span style=\"color: #82AAFF\">sleep</span><span style=\"color: #89DDFF\">(</span><span style=\"color: #F78C6C\">1</span><span style=\"color: #89DDFF\">);</span></span>\n<span class=\"line\"><span style=\"color: #F07178\">    </span></span>\n<span class=\"line\"><span style=\"color: #F07178\">    </span><span style=\"color: #82AAFF\">printf</span><span style=\"color: #89DDFF\">(</span><span style=\"color: #89DDFF\">&quot;</span><span style=\"color: #C3E88D\">thread B waiting  get ResourceB </span><span style=\"color: #BABED8\">\\n</span><span style=\"color: #89DDFF\">&quot;</span><span style=\"color: #89DDFF\">);</span></span>\n<span class=\"line\"><span style=\"color: #F07178\">    </span><span style=\"color: #82AAFF\">pthread_mutex_lock</span><span style=\"color: #89DDFF\">(&amp;</span><span style=\"color: #F07178\">mutex_B</span><span style=\"color: #89DDFF\">);</span></span>\n<span class=\"line\"><span style=\"color: #F07178\">    </span><span style=\"color: #82AAFF\">printf</span><span style=\"color: #89DDFF\">(</span><span style=\"color: #89DDFF\">&quot;</span><span style=\"color: #C3E88D\">thread B got ResourceB </span><span style=\"color: #BABED8\">\\n</span><span style=\"color: #89DDFF\">&quot;</span><span style=\"color: #89DDFF\">);</span></span>\n<span class=\"line\"><span style=\"color: #F07178\">    </span></span>\n<span class=\"line\"><span style=\"color: #F07178\">    </span><span style=\"color: #82AAFF\">pthread_mutex_unlock</span><span style=\"color: #89DDFF\">(&amp;</span><span style=\"color: #F07178\">mutex_B</span><span style=\"color: #89DDFF\">);</span></span>\n<span class=\"line\"><span style=\"color: #F07178\">    </span><span style=\"color: #82AAFF\">pthread_mutex_unlock</span><span style=\"color: #89DDFF\">(&amp;</span><span style=\"color: #F07178\">mutex_A</span><span style=\"color: #89DDFF\">);</span></span>\n<span class=\"line\"><span style=\"color: #F07178\">    </span><span style=\"color: #89DDFF; font-style: italic\">return</span><span style=\"color: #F07178\"> </span><span style=\"color: #89DDFF\">(</span><span style=\"color: #C792EA\">void</span><span style=\"color: #F07178\"> </span><span style=\"color: #89DDFF\">*)</span><span style=\"color: #F78C6C\">0</span><span style=\"color: #89DDFF\">;</span></span>\n<span class=\"line\"><span style=\"color: #89DDFF\">&#125;</span></span></code></pre></div><p>执行结果如下，可以看，没有发生死锁。</p>\n<div class=\"language-shell\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">shell</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #FFCB6B\">thread</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">B</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">waiting</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">get</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">ResourceA</span><span style=\"color: #BABED8\"> </span></span>\n<span class=\"line\"><span style=\"color: #FFCB6B\">thread</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">B</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">got</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">ResourceA</span><span style=\"color: #BABED8\"> </span></span>\n<span class=\"line\"><span style=\"color: #FFCB6B\">thread</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">A</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">waiting</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">get</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">ResourceA</span><span style=\"color: #BABED8\"> </span></span>\n<span class=\"line\"><span style=\"color: #FFCB6B\">thread</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">B</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">waiting</span><span style=\"color: #BABED8\">  </span><span style=\"color: #C3E88D\">get</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">ResourceB</span><span style=\"color: #BABED8\"> </span></span>\n<span class=\"line\"><span style=\"color: #FFCB6B\">thread</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">B</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">got</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">ResourceB</span><span style=\"color: #BABED8\"> </span></span>\n<span class=\"line\"><span style=\"color: #FFCB6B\">thread</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">A</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">got</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">ResourceA</span><span style=\"color: #BABED8\"> </span></span>\n<span class=\"line\"><span style=\"color: #FFCB6B\">thread</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">A</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">waiting</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">get</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">ResourceB</span><span style=\"color: #BABED8\"> </span></span>\n<span class=\"line\"><span style=\"color: #FFCB6B\">thread</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">A</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">got</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C3E88D\">ResourceB</span></span>\n<span class=\"line\"><span style=\"color: #82AAFF\">exit</span></span></code></pre></div><p>简单来说，死锁问题的产生是由两个或者以上线程并行执行的时候，争夺资源而互相等待造成的。</p>\n<p>死锁只有同时满足互斥、持有并等待、不可剥夺、环路等待这四个条件的时候才会发生。</p>\n<p>所以要避免死锁问题，就是要破坏其中一个条件即可，最常用的方法就是使用资源有序分配法来破坏环路等待条件。</p>\n<h2 id=\"5-互斥锁与自选锁\"><a href=\"#5-互斥锁与自选锁\" class=\"headerlink\" title=\"5.互斥锁与自选锁\"></a>5.互斥锁与自选锁</h2><p>多线程访问共享资源的时候，避免不了资源竞争而导致数据错乱的问题，所以我们通常为了解决这一问题，都会在访问共享资源之前加锁。为了选择合适的锁，我们不仅需要清楚知道加锁的成本开销有多大，还需要分析业务场景中访问的共享资源的方式，再来还要考虑并发访问共享资源时的冲突概率。</p>\n<p>最底层的两种就是会「互斥锁和自旋锁」，有很多高级的锁都是基于它们实现的，你可以认为它们是各种锁的地基，所以我们必须清楚它俩之间的区别和应用。</p>\n<p>加锁的目的就是保证共享资源在任意时间里，只有一个线程访问，这样就可以避免多线程导致共享数据错乱的问题。</p>\n<p>当已经有一个线程加锁后，其他线程加锁则就会失败，互斥锁和自旋锁对于加锁失败后的处理方式是不一样的：</p>\n<ul>\n<li><strong>互斥锁</strong>加锁失败后，线程会<strong>释放 CPU</strong> ，给其他线程；</li>\n<li><strong>自旋锁</strong>加锁失败后，线程会<strong>忙等待</strong>，直到它拿到锁；</li>\n</ul>\n<p>互斥锁是一种「独占锁」，比如当线程 A 加锁成功后，此时互斥锁已经被线程 A 独占了，只要线程 A 没有释放手中的锁，线程 B 加锁就会失败，于是就会释放 CPU 让给其他线程，<strong>既然线程 B 释放掉了 CPU，自然线程 B 加锁的代码就会被阻塞</strong>。</p>\n<p><strong>对于互斥锁加锁失败而阻塞的现象，是由操作系统内核实现的</strong>。当加锁失败时，内核会将线程置为「睡眠」状态，等到锁被释放后，内核会在合适的时机唤醒线程，当这个线程成功获取到锁后，于是就可以继续执行。如下图：</p>\n<img src=\"/oranfish.github.io/oranfish.github.io/posts/0/%E4%BA%92%E6%96%A5%E9%94%81%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png\" alt=\"img\" style=\"zoom:50%;\">\n\n<p>所以，互斥锁加锁失败时，会从用户态陷入到内核态，让内核帮我们切换线程，虽然简化了使用锁的难度，但是存在一定的性能开销成本。</p>\n<p>那这个开销成本是什么呢？会有<strong>两次线程上下文切换的成本</strong>：</p>\n<ul>\n<li>当线程加锁失败时，内核会把线程的状态从「运行」状态设置为「睡眠」状态，然后把 CPU 切换给其他线程运行；</li>\n<li>接着，当锁被释放时，之前「睡眠」状态的线程会变为「就绪」状态，然后内核会在合适的时间，把 CPU 切换给该线程运行。</li>\n</ul>\n<p>线程的上下文切换的是什么？当两个线程是属于同一个进程，<strong>因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据。</strong></p>\n<p>上下切换的耗时有大佬统计过，大概在几十纳秒到几微秒之间，如果你锁住的代码执行时间比较短，那可能上下文切换的时间都比你锁住的代码执行时间还要长。</p>\n<p>所以，<strong>如果你能确定被锁住的代码执行时间很短，就不应该用互斥锁，而应该选用自旋锁，否则使用互斥锁。</strong></p>\n<p>自旋锁是通过 CPU 提供的 <code>CAS</code> 函数（<em>Compare And Swap</em>），在「用户态」完成加锁和解锁操作，不会主动产生线程上下文切换，所以相比互斥锁来说，会快一些，开销也小一些。</p>\n<p>一般加锁的过程，包含两个步骤：</p>\n<ul>\n<li>第一步，查看锁的状态，如果锁是空闲的，则执行第二步；</li>\n<li>第二步，将锁设置为当前线程持有；</li>\n</ul>\n<p>CAS 函数就把这两个步骤合并成一条硬件级指令，形成<strong>原子指令</strong>，这样就保证了这两个步骤是不可分割的，要么一次性执行完两个步骤，要么两个步骤都不执行。</p>\n<p>比如，设锁为变量 lock，整数 0 表示锁是空闲状态，整数 pid 表示线程 ID，那么 CAS(lock, 0, pid) 就表示自旋锁的加锁操作，CAS(lock, pid, 0) 则表示解锁操作。</p>\n<p>使用自旋锁的时候，当发生多线程竞争锁的情况，加锁失败的线程会「忙等待」，直到它拿到锁。这里的「忙等待」可以用 <code>while</code> 循环等待实现，不过最好是使用 CPU 提供的 <code>PAUSE</code> 指令来实现「忙等待」，因为可以减少循环等待时的耗电量。</p>\n<p>自旋锁是最比较简单的一种锁，一直自旋，利用 CPU 周期，直到锁可用。<strong>需要注意，在单核 CPU 上，需要抢占式的调度器（即不断通过时钟中断一个线程，运行其他线程）。否则，自旋锁在单 CPU 上无法使用，因为一个自旋的线程永远不会放弃 CPU。</strong></p>\n<p>自旋锁开销少，在多核系统下一般不会主动产生线程切换，适合异步、协程等在用户态切换请求的编程方式，但如果被锁住的代码执行时间过长，自旋的线程会长时间占用 CPU 资源，所以自旋的时间和被锁住的代码执行的时间是成「正比」的关系，我们需要清楚的知道这一点。</p>\n<p>自旋锁与互斥锁使用层面比较相似，但实现层面上完全不同：<strong>当加锁失败时，互斥锁用「线程切换」来应对，自旋锁则用「忙等待」来应对</strong>。</p>\n<p>它俩是锁的最基本处理方式，更高级的锁都会选择其中一个来实现，比如读写锁既可以选择互斥锁实现，也可以基于自旋锁实现。</p>\n<h2 id=\"6-读写锁\"><a href=\"#6-读写锁\" class=\"headerlink\" title=\"6.读写锁\"></a>6.读写锁</h2><p>读写锁从字面意思我们也可以知道，它由「读锁」和「写锁」两部分构成，如果只读取共享资源用「读锁」加锁，如果要修改共享资源则用「写锁」加锁。</p>\n<p>所以，<strong>读写锁适用于能明确区分读操作和写操作的场景</strong>。</p>\n<p>读写锁的工作原理是：</p>\n<ul>\n<li>当「写锁」没有被线程持有时，多个线程能够并发地持有读锁，这大大提高了共享资源的访问效率，因为「读锁」是用于读取共享资源的场景，所以多个线程同时持有读锁也不会破坏共享资源的数据。</li>\n<li>但是，一旦「写锁」被线程持有后，读线程的获取读锁的操作会被阻塞，而且其他写线程的获取写锁的操作也会被阻塞。</li>\n</ul>\n<p>所以说，写锁是独占锁，因为任何时刻只能有一个线程持有写锁，类似互斥锁和自旋锁，而读锁是共享锁，因为读锁可以被多个线程同时持有。</p>\n<p>知道了读写锁的工作原理后，我们可以发现，<strong>读写锁在读多写少的场景，能发挥出优势</strong>。</p>\n<p>另外，根据实现的不同，读写锁可以分为「读优先锁」和「写优先锁」。</p>\n<p>读优先锁期望的是，读锁能被更多的线程持有，以便提高读线程的并发性，它的工作方式是：当读线程 A 先持有了读锁，写线程 B 在获取写锁的时候，会被阻塞，并且在阻塞过程中，后续来的读线程 C 仍然可以成功获取读锁，最后直到读线程 A 和 C 释放读锁后，写线程 B 才可以成功获取写锁。如下图：</p>\n<img src=\"/oranfish.github.io/oranfish.github.io/posts/0/%E8%AF%BB%E4%BC%98%E5%85%88%E9%94%81%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png\" alt=\"img\" style=\"zoom:33%;\">\n\n<p>而「写优先锁」是优先服务写线程，其工作方式是：当读线程 A 先持有了读锁，写线程 B 在获取写锁的时候，会被阻塞，并且在阻塞过程中，后续来的读线程 C 获取读锁时会失败，于是读线程 C 将被阻塞在获取读锁的操作，这样只要读线程 A 释放读锁后，写线程 B 就可以成功获取写锁。如下图：</p>\n<img src=\"/oranfish.github.io/oranfish.github.io/posts/0/%E5%86%99%E4%BC%98%E5%85%88%E9%94%81%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png\" alt=\"img\" style=\"zoom: 33%;\">\n\n<p>读优先锁对于读线程并发性更好，但也不是没有问题。我们试想一下，如果一直有读线程获取读锁，那么写线程将永远获取不到写锁，这就造成了写线程「饥饿」的现象。</p>\n<p>写优先锁可以保证写线程不会饿死，但是如果一直有写线程获取写锁，读线程也会被「饿死」。</p>\n<p>既然不管优先读锁还是写锁，对方可能会出现饿死问题，那么我们就不偏袒任何一方，搞个「公平读写锁」。</p>\n<p><strong>公平读写锁比较简单的一种方式是：用队列把获取锁的线程排队，不管是写线程还是读线程都按照先进先出的原则加锁即可，这样读线程仍然可以并发，也不会出现「饥饿」的现象。</strong></p>\n<p>互斥锁和自旋锁都是最基本的锁，读写锁可以根据场景来选择这两种锁其中的一个进行实现。</p>\n<h2 id=\"7-乐观锁和悲观锁\"><a href=\"#7-乐观锁和悲观锁\" class=\"headerlink\" title=\"7.乐观锁和悲观锁\"></a>7.乐观锁和悲观锁</h2><p>前面提到的互斥锁、自旋锁、读写锁，都是属于悲观锁。</p>\n<p>悲观锁做事比较悲观，它认为<strong>多线程同时修改共享资源的概率比较高，于是很容易出现冲突，所以访问共享资源前，先要上锁</strong>。</p>\n<p>那相反的，如果多线程同时修改共享资源的概率比较低，就可以采用乐观锁。</p>\n<p>乐观锁做事比较乐观，它假定冲突的概率很低，它的工作方式是：<strong>先修改完共享资源，再验证这段时间内有没有发生冲突，如果没有其他线程在修改资源，那么操作完成，如果发现有其他线程已经修改过这个资源，就放弃本次操作</strong>。</p>\n<p>放弃后如何重试，这跟业务场景息息相关，虽然重试的成本很高，但是冲突的概率足够低的话，还是可以接受的。</p>\n<p>可见，乐观锁的心态是，不管三七二十一，先改了资源再说。另外，你会发现<strong>乐观锁全程并没有加锁，所以它也叫无锁编程</strong>。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>这里举一个场景例子：在线文档。</p>\n<p>我们都知道在线文档可以同时多人编辑的，如果使用了悲观锁，那么只要有一个用户正在编辑文档，此时其他用户就无法打开相同的文档了，这用户体验当然不好了。</p>\n<p>那实现多人同时编辑，实际上是用了乐观锁，它允许多个用户打开同一个文档进行编辑，编辑完提交之后才验证修改的内容是否有冲突。</p>\n<p>怎么样才算发生冲突？这里举个例子，比如用户 A 先在浏览器编辑文档，之后用户 B 在浏览器也打开了相同的文档进行编辑，但是用户 B 比用户 A 提交早，这一过程用户 A 是不知道的，当 A 提交修改完的内容时，那么 A 和 B 之间并行修改的地方就会发生冲突。</p>\n<p>服务端要怎么验证是否冲突了呢？通常方案如下：</p>\n<ul>\n<li>由于发生冲突的概率比较低，所以先让用户编辑文档，但是浏览器在下载文档时会记录下服务端返回的文档版本号；</li>\n<li>当用户提交修改时，发给服务端的请求会带上原始文档版本号，服务器收到后将它与当前版本号进行比较，如果版本号不一致则提交失败，如果版本号一致则修改成功，然后服务端版本号更新到最新的版本号。</li>\n</ul></blockquote>\n<p>实际上，我们常见的 SVN 和 Git 也是用了乐观锁的思想，先让用户编辑代码，然后提交的时候，通过版本号来判断是否产生了冲突，发生了冲突的地方，需要我们自己修改后，再重新提交。</p>\n<p>乐观锁虽然去除了加锁解锁的操作，但是一旦发生冲突，重试的成本非常高，所以<strong>只有在冲突概率非常低，且加锁成本非常高的场景时，才考虑使用乐观锁。</strong></p>\n<h2 id=\"8-总结\"><a href=\"#8-总结\" class=\"headerlink\" title=\"8.总结\"></a>8.总结</h2><p>开发过程中，最常见的就是互斥锁的了，互斥锁加锁失败时，会用「线程切换」来应对，当加锁失败的线程再次加锁成功后的这一过程，会有两次线程上下文切换的成本，性能损耗比较大。</p>\n<p>如果我们明确知道被锁住的代码的执行时间很短，那我们应该选择开销比较小的自旋锁，因为自旋锁加锁失败时，并不会主动产生线程切换，而是一直忙等待，直到获取到锁，那么如果被锁住的代码执行时间很短，那这个忙等待的时间相对应也很短。</p>\n<p>如果能区分读操作和写操作的场景，那读写锁就更合适了，它允许多个读线程可以同时持有读锁，提高了读的并发性。根据偏袒读方还是写方，可以分为读优先锁和写优先锁，读优先锁并发性很强，但是写线程会被饿死，而写优先锁会优先服务写线程，读线程也可能会被饿死，那为了避免饥饿的问题，于是就有了公平读写锁，它是用队列把请求锁的线程排队，并保证先入先出的原则来对线程加锁，这样便保证了某种线程不会被饿死，通用性也更好点。</p>\n<p>互斥锁和自旋锁都是最基本的锁，读写锁可以根据场景来选择这两种锁其中的一个进行实现。</p>\n<p>另外，互斥锁、自旋锁、读写锁都属于悲观锁，悲观锁认为并发访问共享资源时，冲突概率可能非常高，所以在访问共享资源前，都需要先加锁。</p>\n<p>相反的，如果并发访问共享资源时，冲突概率非常低的话，就可以使用乐观锁，它的工作方式是，在访问共享资源时，不用先加锁，修改完共享资源后，再验证这段时间内有没有发生冲突，如果没有其他线程在修改资源，那么操作完成，如果发现有其他线程已经修改过这个资源，就放弃本次操作。</p>\n<p>但是，一旦冲突概率上升，就不适合使用乐观锁了，因为它解决冲突的重试成本非常高。</p>\n<p>不管使用的哪种锁，我们的加锁的代码范围应该尽可能的小，也就是加锁的粒度要小，这样执行速度会比较快。再来，使用上了合适的锁，就会快上加快了。</p>\n","text":"1.死锁的概念在多线程编程中，我们为了防止多线程竞争共享资源而导致数据错乱，都会在操作共享资源之前加上互斥锁，只有成功获得到锁的线程，才能操作共享资源，获取不到...","permalink":"/post/OS-死锁","photos":[],"count_time":{"symbolsCount":"13k","symbolsTime":"12 mins."},"categories":[{"name":"Study","slug":"Study","count":30,"path":"api/categories/Study.json"}],"tags":[{"name":"学习","slug":"学习","count":20,"path":"api/tags/学习.json"},{"name":"操作系统","slug":"操作系统","count":9,"path":"api/tags/操作系统.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E6%AD%BB%E9%94%81%E7%9A%84%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">1.死锁的概念</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-1-%E4%BA%92%E6%96%A5%E6%9D%A1%E4%BB%B6\"><span class=\"toc-text\">1.1 互斥条件</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-2-%E6%8C%81%E6%9C%89%E5%B9%B6%E7%AD%89%E5%BE%85%E6%9D%A1%E4%BB%B6\"><span class=\"toc-text\">1.2 持有并等待条件</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-3-%E4%B8%8D%E5%8F%AF%E5%89%A5%E5%A4%BA%E6%9D%A1%E4%BB%B6\"><span class=\"toc-text\">1.3 不可剥夺条件</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-4-%E7%8E%AF%E8%B7%AF%E7%AD%89%E5%BE%85%E6%9D%A1%E4%BB%B6\"><span class=\"toc-text\">1.4 环路等待条件</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E6%A8%A1%E6%8B%9F%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98%E7%9A%84%E4%BA%A7%E7%94%9F\"><span class=\"toc-text\">2.模拟死锁问题的产生</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-%E5%88%A9%E7%94%A8%E5%B7%A5%E5%85%B7%E6%8E%92%E6%9F%A5%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">3.利用工具排查死锁问题</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98%E7%9A%84%E5%8F%91%E7%94%9F\"><span class=\"toc-text\">4.避免死锁问题的发生</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-%E4%BA%92%E6%96%A5%E9%94%81%E4%B8%8E%E8%87%AA%E9%80%89%E9%94%81\"><span class=\"toc-text\">5.互斥锁与自选锁</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-%E8%AF%BB%E5%86%99%E9%94%81\"><span class=\"toc-text\">6.读写锁</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#7-%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81\"><span class=\"toc-text\">7.乐观锁和悲观锁</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#8-%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">8.总结</span></a></li></ol>","author":{"name":"Fioransh","slug":"blog-author","avatar":"/medias/2.jpg","link":"/","description":"<p> 学而无知，无知而学 <p> <p> Anime is trash and so am I. <p>","socials":{"github":"https://github.com/orangefish1118","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/14481775?spm_id_from=333.1007.0.0"},"gitee":{"icon":"/svg/gitee.svg","link":"https://gitee.com/Orangefish-cyc"},"mail":{"icon":"/svg/email.svg","link":"mailto:1263938020@qq.com"}}}},"mapped":true,"hidden":false,"prev_post":{"title":"OS-进程线程基础知识","uid":"193fbfa2337e88e92d38c2ae6126c3d1","slug":"OS-进程线程基础知识","date":"2024-06-09T08:44:12.000Z","updated":"2024-06-19T08:03:00.479Z","comments":true,"path":"api/articles/OS-进程线程基础知识.json","keywords":"博客、橙汁蒸鱼、Orangefish、Oranfish","cover":"/medias/31.jpg","text":"1.进程执行文件后将其装载到内存中，通过CPU执行程序中的每一条指令，那么这个运行中的程序，就被称为「进程」（Process） 当进程要从硬盘读取数据时，CPU...","permalink":"/post/OS-进程线程基础知识","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[{"name":"Study","slug":"Study","count":30,"path":"api/categories/Study.json"}],"tags":[{"name":"学习","slug":"学习","count":20,"path":"api/tags/学习.json"},{"name":"操作系统","slug":"操作系统","count":9,"path":"api/tags/操作系统.json"}],"author":{"name":"Fioransh","slug":"blog-author","avatar":"/medias/2.jpg","link":"/","description":"<p> 学而无知，无知而学 <p> <p> Anime is trash and so am I. <p>","socials":{"github":"https://github.com/orangefish1118","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/14481775?spm_id_from=333.1007.0.0"},"gitee":{"icon":"/svg/gitee.svg","link":"https://gitee.com/Orangefish-cyc"},"mail":{"icon":"/svg/email.svg","link":"mailto:1263938020@qq.com"}}}}},"next_post":{"title":"OS-同步与互斥","uid":"ab980e069c750cd15253a6b530b876d9","slug":"OS-同步与互斥","date":"2024-06-09T05:25:12.000Z","updated":"2024-06-19T08:04:42.743Z","comments":true,"path":"api/articles/OS-同步与互斥.json","keywords":"博客、橙汁蒸鱼、Orangefish、Oranfish","cover":"/medias/34.jpg","text":"1.竞争与合作1.1 入门在单核 CPU 系统里，为了实现多个程序同时运行的假象，操作系统通常以时间片调度的方式，让每个进程执行每次执行一个时间片，时间片用完了...","permalink":"/post/OS-同步与互斥","photos":[],"count_time":{"symbolsCount":"6.9k","symbolsTime":"6 mins."},"categories":[{"name":"Study","slug":"Study","count":30,"path":"api/categories/Study.json"}],"tags":[{"name":"学习","slug":"学习","count":20,"path":"api/tags/学习.json"},{"name":"操作系统","slug":"操作系统","count":9,"path":"api/tags/操作系统.json"}],"author":{"name":"Fioransh","slug":"blog-author","avatar":"/medias/2.jpg","link":"/","description":"<p> 学而无知，无知而学 <p> <p> Anime is trash and so am I. <p>","socials":{"github":"https://github.com/orangefish1118","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/14481775?spm_id_from=333.1007.0.0"},"gitee":{"icon":"/svg/gitee.svg","link":"https://gitee.com/Orangefish-cyc"},"mail":{"icon":"/svg/email.svg","link":"mailto:1263938020@qq.com"}}}}}}