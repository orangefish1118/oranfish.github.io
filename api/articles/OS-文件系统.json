{"title":"OS-文件系统","uid":"a309e6723d5eeefad0a013dac5e81168","slug":"OS-文件系统","date":"2024-06-07T06:25:12.000Z","updated":"2024-06-19T08:05:06.140Z","comments":true,"path":"api/articles/OS-文件系统.json","keywords":"博客、橙汁蒸鱼、Orangefish、Oranfish","cover":"/medias/35.jpg","content":"<h2 id=\"1-文件系统的基本组成\"><a href=\"#1-文件系统的基本组成\" class=\"headerlink\" title=\"1.文件系统的基本组成\"></a>1.文件系统的基本组成</h2><p>文件系统是操作系统中负责管理持久数据的子系统，负责把用户文件存到磁盘硬件。</p>\n<p>文件系统的基本数据单位是文件，它的目的是对磁盘上的文件进行组织管理，那组织的方式不同，就会形成不同的文件系统。</p>\n<p>Linux 最经典的一句话是：「<strong>一切皆文件</strong>」</p>\n<p>Linux 文件系统会为每个文件分配两个数据结构：<strong>索引节点（*index node*）和目录项（*directory entry*）</strong>，它们主要用来记录文件的元信息和目录层次结构。</p>\n<ul>\n<li>索引节点，也就是 <em>inode</em>，用来记录文件的元信息，比如 inode 编号、文件大小、访问权限、创建时间、修改时间、<strong>数据在磁盘的位置</strong>等等。索引节点是文件的<strong>唯一</strong>标识，它们之间一一对应，也同样都会被存储在硬盘中，所以<strong>索引节点同样占用磁盘空间</strong>。</li>\n<li>目录项，也就是 <em>dentry</em>，用来记录文件的名字、<strong>索引节点指针</strong>以及与其他目录项的层级关联关系。多个目录项关联起来，就会形成目录结构，但它与索引节点不同的是，<strong>目录项是由内核维护的一个数据结构，不存放于磁盘，而是缓存在内存</strong>。</li>\n</ul>\n<p>索引节点唯一标识一个文件，目录项记录文件名字，目录项和索引节点关系为多对一，一个文件可以有多个别名。</p>\n<p>目录也是文件，也是索引节点唯一，普通文件在磁盘保存的是文件数据，目录文件保存的是子目录或文件。</p>\n<h3 id=\"1-1-目录项和目录区别\"><a href=\"#1-1-目录项和目录区别\" class=\"headerlink\" title=\"1.1 目录项和目录区别\"></a>1.1 目录项和目录区别</h3><p>目录是文件，持久化存储在磁盘。目录项是内核一个数据结构，缓存在内存。</p>\n<p>如果查询目录频繁从磁盘读，效率会很低，所以内核会把已经读过的目录用目录项这个数据结构缓存在内存，下次再次读到相同的目录时，只需从内存读就可以，大大提高了文件系统的效率。</p>\n<p>目录项这个数据结构不只是表示目录，也是可以表示文件的。</p>\n<h3 id=\"1-2-文件数据如何存储在磁盘\"><a href=\"#1-2-文件数据如何存储在磁盘\" class=\"headerlink\" title=\"1.2 文件数据如何存储在磁盘\"></a>1.2 文件数据如何存储在磁盘</h3><p>磁盘读写最小单位是<strong>扇区</strong>，扇区大小为521B</p>\n<p>文件系统把多个扇区组成一个<strong>逻辑块</strong>，每次读写的最小单位就是逻辑块。</p>\n<p>Linux中逻辑块大小为4KB，也就是一次性读写8个扇区，提高读写效率。</p>\n<img src=\"/oranfish.github.io/oranfish.github.io/posts/0/%E7%9B%AE%E5%BD%95%E9%A1%B9%E5%92%8C%E7%B4%A2%E5%BC%95%E5%85%B3%E7%B3%BB%E5%9B%BE.png\" alt=\"img\" style=\"zoom:50%;\">\n\n<p>索引节点是存储在硬盘上的数据，那么为了加速文件的访问，通常会把索引节点加载到内存中</p>\n<p>磁盘进行格式化的时候，会被分成三个存储区域，分别是超级块、索引节点区和数据块区。</p>\n<ul>\n<li><em>超级块</em>，用来存储文件系统的详细信息，比如块个数、块大小、空闲块等等。</li>\n<li><em>索引节点区</em>，用来存储索引节点；</li>\n<li><em>数据块区</em>，用来存储文件或目录数据；</li>\n</ul>\n<p>当需要使用的时候，才将其加载进内存，它们加载进内存的时机是不同的：</p>\n<ul>\n<li>超级块：当文件系统挂载时进入内存；</li>\n<li>索引节点区：当文件被访问时进入内存；</li>\n</ul>\n<h2 id=\"2-虚拟文件系统\"><a href=\"#2-虚拟文件系统\" class=\"headerlink\" title=\"2.虚拟文件系统\"></a>2.虚拟文件系统</h2><p>文件系统的种类众多，而操作系统希望<strong>对用户提供一个统一的接口</strong>，于是在用户层与文件系统层引入了中间层，这个中间层就称为<strong>虚拟文件系统（*Virtual File System，VFS*）。</strong></p>\n<p>VFS 定义了一组所有文件系统都支持的数据结构和标准接口。</p>\n<img src=\"/oranfish.github.io/oranfish.github.io/posts/0/%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F.png\" alt=\"img\" style=\"zoom:33%;\">\n\n<p>Linux 支持的文件系统根据存储位置的不同，可以把文件系统分为三类：</p>\n<ul>\n<li><em>磁盘的文件系统</em>：直接把数据存储在磁盘中，比如 Ext 2&#x2F;3&#x2F;4、XFS 等都是这类文件系统。</li>\n<li><em>内存的文件系统</em>：这类文件系统的数据不是存储在硬盘的，而是占用内存空间，我们经常用到的 <code>/proc</code> 和 <code>/sys</code> 文件系统都属于这一类，读写这类文件，实际上是读写内核中相关的数据。</li>\n<li><em>网络的文件系统</em>：用来访问其他计算机主机数据的文件系统，比如 NFS、SMB 等等。</li>\n</ul>\n<p>文件系统首先要先挂载到某个目录才可以正常使用，比如 Linux 系统在启动时，会把文件系统挂载到根目录。</p>\n<h2 id=\"3-文件的使用\"><a href=\"#3-文件的使用\" class=\"headerlink\" title=\"3.文件的使用\"></a>3.文件的使用</h2><p>文件打开过程：</p>\n<ul>\n<li>首先用 <code>open</code> 系统调用打开文件，<code>open</code> 的参数中包含文件的路径名和文件名。</li>\n<li>使用 <code>write</code> 写数据，其中 <code>write</code> 使用 <code>open</code> 所返回的<strong>文件描述符</strong>，并不使用文件名作为参数。</li>\n<li>使用完文件后，要用 <code>close</code> 系统调用关闭文件，避免资源的泄露。</li>\n</ul>\n<p>打开文件后，系统会跟踪打开的所有文件，所谓跟踪即是操作系统为每个进程维护一个打开文件表，文件表里的每一项代表「<strong>文件描述符</strong>」，所以说文件描述符是打开文件的标识。</p>\n<p>操作系统在打开文件表中维护着打开文件的状态和信息：</p>\n<ul>\n<li>文件指针：系统跟踪上次读写位置作为当前文件位置指针，这种指针对打开文件的某个进程来说是唯一的；</li>\n<li>文件打开计数器：文件关闭时，操作系统必须重用其打开文件表条目，否则表内空间不够用。因为多个进程可能打开同一个文件，所以系统在删除打开文件条目之前，必须等待最后一个进程关闭文件，该计数器跟踪打开和关闭的数量，当该计数为 0 时，系统关闭文件，删除该条目；</li>\n<li>文件磁盘位置：绝大多数文件操作都要求系统修改文件数据，该信息保存在内存中，以免每个操作都从磁盘中读取；</li>\n<li>访问权限：每个进程打开文件都需要有一个访问模式（创建、只读、读写、添加等），该信息保存在进程的打开文件表中，以便操作系统能允许或拒绝之后的 I&#x2F;O 请求；</li>\n</ul>\n<p>在用户视角里，文件就是一个持久化的数据结构，但操作系统并不会关心你想存在磁盘上的任何的数据结构，操作系统的视角是如何把文件数据和磁盘块对应起来。</p>\n<p>所以，用户和操作系统对文件的读写操作是有差异的，用户习惯以字节的方式读写文件，而操作系统则是以数据块来读写文件，那屏蔽掉这种差异的工作就是文件系统了。</p>\n<p>我们来分别看一下，读文件和写文件的过程：</p>\n<ul>\n<li>当用户进程从文件读取 1 个字节大小的数据时，文件系统则需要获取字节所在的数据块，再返回数据块对应的用户进程所需的数据部分。</li>\n<li>当用户进程把 1 个字节大小的数据写进文件时，文件系统则找到需要写入数据的数据块的位置，然后修改数据块中对应的部分，最后再把数据块写回磁盘。</li>\n</ul>\n<p>所以说，<strong>文件系统的基本操作单位是数据块</strong>。</p>\n<h2 id=\"4-文件的存储\"><a href=\"#4-文件的存储\" class=\"headerlink\" title=\"4.文件的存储\"></a>4.文件的存储</h2><p>文件的数据存储在硬盘上，数据在磁盘上的存放方式有以下两种：</p>\n<ul>\n<li><strong>连续空间</strong>存放方式</li>\n<li><strong>非连续空间</strong>存放方式</li>\n</ul>\n<p>其中，非连续空间存放方式又可以分为<strong>「链表方式」</strong>和<strong>「索引方式」</strong>，重点分析它们的存储效率和读写性能。</p>\n<h3 id=\"4-1-连续空间存放方式\"><a href=\"#4-1-连续空间存放方式\" class=\"headerlink\" title=\"4.1 连续空间存放方式\"></a>4.1 连续空间存放方式</h3><p><strong>文件存放在磁盘「连续的」物理空间中</strong>。这种模式下，文件的数据都是紧密相连，<strong>读写效率很高</strong>，因为一次磁盘寻道就可以读出整个文件。</p>\n<p>使用连续存放方式前提：必须知道文件的大小。</p>\n<p><strong>文件头里需要指定「起始块的位置」和「长度」</strong>，有了这两个信息就可以很好的表示文件存放方式是一块连续的磁盘空间。</p>\n<p>注意，此处说的文件头，就类似于 Linux 的 inode。</p>\n<img src=\"/oranfish.github.io/oranfish.github.io/posts/0/%E8%BF%9E%E7%BB%AD%E7%A9%BA%E9%97%B4%E5%AD%98%E6%94%BE%E6%96%B9%E5%BC%8F.png\" alt=\"连续空间存放方式\" style=\"zoom:50%;\">\n\n<p>连续空间存放的方式虽然读写效率高，<strong>但是有「磁盘空间碎片」和「文件长度不易扩展」的缺陷。</strong></p>\n<p>磁盘空间碎片与之前的内部存储碎片相似，文件存放小于空间空缺可以存放，存放后的剩余空间为碎片，大于则不能存放。</p>\n<p>文件长度扩展不方便，唯一的方式也是挪动，效率低下。</p>\n<p>使用非连续空间存放方式可以来解决这些缺陷。</p>\n<h3 id=\"4-2-非连续空间存放方式\"><a href=\"#4-2-非连续空间存放方式\" class=\"headerlink\" title=\"4.2 非连续空间存放方式\"></a>4.2 非连续空间存放方式</h3><p>非连续空间存放方式分为<strong>「链表方式」</strong>和<strong>「索引方式」</strong>。</p>\n<h4 id=\"4-2-1-链表方式\"><a href=\"#4-2-1-链表方式\" class=\"headerlink\" title=\"4.2.1 链表方式\"></a>4.2.1 链表方式</h4><p>链表的方式存放是<strong>离散的，不用连续的</strong>，于是就可以<strong>消除磁盘碎片</strong>，可大大提高磁盘空间的利用率，同时<strong>文件的长度可以动态扩展</strong>。根据实现的方式的不同，链表可分为「<strong>隐式链表</strong>」和「<strong>显式链接</strong>」两种形式。</p>\n<p><strong>隐式链表：</strong></p>\n<p>文件要以「<strong>隐式链表</strong>」的方式存放的话，<strong>实现的方式是文件头要包含「第一块」和「最后一块」的位置，并且每个数据块里面留出一个指针空间，用来存放下一个数据块的位置</strong>，这样一个数据块连着一个数据块，从链头开始就可以顺着指针找到所有的数据块，所以存放的方式可以是不连续的。</p>\n<img src=\"/oranfish.github.io/oranfish.github.io/posts/0/%E9%9D%9E%E8%BF%9E%E7%BB%AD%E7%A9%BA%E9%97%B4%E5%AD%98%E6%94%BE%E6%96%B9%E5%BC%8F-%E9%93%BE%E8%A1%A8%E6%96%B9%E5%BC%8F.png\" alt=\"隐式链表\" style=\"zoom:50%;\">\n\n<p>隐式链表的存放方式的<strong>缺点在于无法直接访问数据块，只能通过指针顺序访问文件，以及数据块指针消耗了一定的存储空间</strong>。隐式链接分配的<strong>稳定性较差</strong>，系统在运行过程中由于软件或者硬件错误<strong>导致链表中的指针丢失或损坏，会导致文件数据的丢失。</strong></p>\n<p><strong>显式链表：</strong></p>\n<p>如果取出每个磁盘块的指针，把它放在内存的一个表中，就可以解决上述隐式链表的两个不足。这种实现方式是「<strong>显式链接</strong>」，它指<strong>把用于链接文件各数据块的指针，显式地存放在内存的一张链接表中</strong>，该表在整个磁盘仅设置一张，<strong>每个表项中存放链接指针，指向下一个数据块号</strong>。</p>\n<p>内存中的这样一个表格称为<strong>文件分配表（*File Allocation Table，FAT*）</strong>。</p>\n<img src=\"/oranfish.github.io/oranfish.github.io/posts/0/%E6%96%87%E4%BB%B6%E5%88%86%E9%85%8D%E8%A1%A8.png\" alt=\"显式链接\" style=\"zoom:25%;\">\n\n<p>由于查找记录的过程是在内存中进行的，因而不仅显著地<strong>提高了检索速度</strong>，而且<strong>大大减少了访问磁盘的次数</strong>。但也正是整个表都存放在内存中的关系，它的主要的缺点是<strong>不适用于大磁盘</strong>。</p>\n<h4 id=\"4-2-2-索引方式\"><a href=\"#4-2-2-索引方式\" class=\"headerlink\" title=\"4.2.2 索引方式\"></a>4.2.2 索引方式</h4><p>索引的实现是为每个文件创建一个「<strong>索引数据块</strong>」，里面存放的是<strong>指向文件数据块的指针列表</strong>，说白了就像书的目录一样，要找哪个章节的内容，看目录查就可以。</p>\n<p><strong>文件头需要包含指向「索引数据块」的指针</strong>，这样就可以通过文件头知道索引数据块的位置，再通过索引数据块里的索引信息找到对应的数据块。</p>\n<p>创建文件时，索引块的所有指针都设为空。当首次写入第 i 块时，先从空闲空间中取得一个块，再将其地址写到索引块的第 i 个条目。</p>\n<img src=\"/oranfish.github.io/oranfish.github.io/posts/0/%E9%9D%9E%E8%BF%9E%E7%BB%AD%E7%A9%BA%E9%97%B4%E5%AD%98%E6%94%BE%E6%96%B9%E5%BC%8F-%E7%B4%A2%E5%BC%95%E6%96%B9%E5%BC%8F.png\" alt=\"索引的方式\" style=\"zoom:33%;\">\n\n<p>索引的方式优点在于：</p>\n<ul>\n<li>文件的创建、增大、缩小很方便；</li>\n<li>不会有碎片的问题；</li>\n<li>支持顺序读写和随机读写；</li>\n</ul>\n<p>由于索引数据也是存放在磁盘块的，如果文件很小，明明只需一块就可以存放的下，但还是需要额外分配一块来存放索引数据，所以缺陷之一就是存储索引带来的开销。</p>\n<p>如何处理过大文件（大于一个索引数据块）：</p>\n<p>链表 + 索引的组合，这种组合称为「<strong>链式索引块</strong>」，它的实现方式是<strong>在索引数据块留出一个存放下一个索引数据块的指针</strong>，于是当一个索引数据块的索引信息用完了，就可以通过指针的方式，找到下一个索引数据块的信息。那这种方式也会出现前面提到的链表方式的问题，万一某个指针损坏了，后面的数据也就会无法读取了。</p>\n<img src=\"/oranfish.github.io/oranfish.github.io/posts/0/%E9%93%BE%E5%BC%8F%E7%B4%A2%E5%BC%95%E5%9D%97.png\" alt=\"链式索引块\" style=\"zoom:33%;\">\n\n<p>还有另外一种组合方式是索引 + 索引的方式，这种组合称为「<strong>多级索引块</strong>」，实现方式是<strong>通过一个索引块来存放多个索引数据块</strong>，一层套一层索引。</p>\n<img src=\"/oranfish.github.io/oranfish.github.io/posts/0/%E5%A4%9A%E7%BA%A7%E7%B4%A2%E5%BC%95%E5%9D%97.png\" alt=\"多级索引块\" style=\"zoom:33%;\">\n\n\n\n<h3 id=\"4-3-Unix文件的实现方式\"><a href=\"#4-3-Unix文件的实现方式\" class=\"headerlink\" title=\"4.3 Unix文件的实现方式\"></a>4.3 Unix文件的实现方式</h3><img src=\"/oranfish.github.io/oranfish.github.io/posts/0/%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F%E6%AF%94%E8%BE%83.png\" alt=\"img\" style=\"zoom:50%;\">\n\n<p>那早期 Unix 文件系统是组合了前面的文件存放方式的优点</p>\n<img src=\"/oranfish.github.io/oranfish.github.io/posts/0/Unix%20%E5%A4%9A%E7%BA%A7%E7%B4%A2%E5%BC%95.png\" alt=\"早期 Unix 文件系统\" style=\"zoom:25%;\">\n\n<p>它是根据文件的大小，存放的方式会有所变化：</p>\n<ul>\n<li>如果存放文件所需的数据块小于 10 块，则采用直接查找的方式；</li>\n<li>如果存放文件所需的数据块超过 10 块，则采用一级间接索引方式；</li>\n<li>如果前面两种方式都不够存放大文件，则采用二级间接索引方式；</li>\n<li>如果二级间接索引也不够存放大文件，这采用三级间接索引方式；</li>\n</ul>\n<p>那么，文件头（<em>Inode</em>）就需要包含 13 个指针：</p>\n<ul>\n<li>10 个指向数据块的指针；</li>\n<li>第 11 个指向索引块的指针；</li>\n<li>第 12 个指向二级索引块的指针；</li>\n<li>第 13 个指向三级索引块的指针；</li>\n</ul>\n<p>所以，这种方式能很灵活地支持小文件和大文件的存放：</p>\n<ul>\n<li>对于小文件使用直接查找的方式可减少索引数据块的开销；</li>\n<li>对于大文件则以多级索引的方式来支持，所以大文件在访问数据块时需要大量查询；</li>\n</ul>\n<h2 id=\"5-空闲空间管理\"><a href=\"#5-空闲空间管理\" class=\"headerlink\" title=\"5.空闲空间管理\"></a>5.空闲空间管理</h2><p>针对磁盘的空闲空间也是要引入管理的机制，接下来介绍几种常见的方法：</p>\n<ul>\n<li>空闲表法</li>\n<li>空闲链表法</li>\n<li>位图法</li>\n</ul>\n<h3 id=\"5-1-空闲表法\"><a href=\"#5-1-空闲表法\" class=\"headerlink\" title=\"5.1 空闲表法\"></a>5.1 空闲表法</h3><p>空闲表法就是为所有空闲空间建立一张表，表内容包括空闲区的第一个块号和该空闲区的块个数，注意，这个方式是连续分配的。</p>\n<p>当请求分配磁盘空间时，系统依次扫描空闲表里的内容，直到找到一个合适的空闲区域为止。当用户撤销一个文件时，系统回收文件空间。这时，也需顺序扫描空闲表，寻找一个空闲表条目并将释放空间的第一个物理块号及它占用的块数填到这个条目中。</p>\n<p>这种方法仅当有少量的空闲区时才有较好的效果。因为，如果存储空间中有着大量的小的空闲区，则空闲表变得很大，这样查询效率会很低。另外，这种分配技术适用于建立连续文件。</p>\n<img src=\"/oranfish.github.io/oranfish.github.io/posts/0/%E7%A9%BA%E9%97%B2%E8%A1%A8%E6%B3%95.png\" alt=\"空闲表法\" style=\"zoom:33%;\">\n\n\n\n<h3 id=\"5-2-空闲链表法\"><a href=\"#5-2-空闲链表法\" class=\"headerlink\" title=\"5.2 空闲链表法\"></a>5.2 空闲链表法</h3><p>我们也可以使用「链表」的方式来管理空闲空间，每一个空闲块里有一个指针指向下一个空闲块，这样也能很方便的找到空闲块并管理起来。</p>\n<p>当创建文件需要一块或几块时，就从链头上依次取下一块或几块。反之，当回收空间时，把这些空闲块依次接到链头上。</p>\n<p>这种技术只要在主存中保存一个指针，令它指向第一个空闲块。其特点是简单，但不能随机访问，工作效率低，因为每当在链上增加或移动空闲块时需要做很多 I&#x2F;O 操作，同时数据块的指针消耗了一定的存储空间。</p>\n<p>空闲表法和空闲链表法都不适合用于大型文件系统，因为这会使空闲表或空闲链表太大。</p>\n<img src=\"/oranfish.github.io/oranfish.github.io/posts/0/%E7%A9%BA%E9%97%B2%E5%9D%97%E9%93%BE%E8%A1%A8.png\" alt=\"空闲链表法\" style=\"zoom:50%;\">\n\n\n\n<h3 id=\"5-3-位图法\"><a href=\"#5-3-位图法\" class=\"headerlink\" title=\"5.3 位图法\"></a>5.3 位图法</h3><p>位图是利用二进制的一位来表示磁盘中一个盘块的使用情况，磁盘上所有的盘块都有一个二进制位与之对应。</p>\n<p>当值为 0 时，表示对应的盘块空闲，值为 1 时，表示对应的盘块已分配。它形式如下：</p>\n<div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #babed8\">1111110011111110001110110111111100111 ...</span></span></code></pre></div><p>在 Linux 文件系统就采用了位图的方式来管理空闲空间，不仅用于数据空闲块的管理，还用于 inode 空闲块的管理，因为 inode 也是存储在磁盘的，自然也要有对其管理。</p>\n<h2 id=\"6-文件系统的结构\"><a href=\"#6-文件系统的结构\" class=\"headerlink\" title=\"6.文件系统的结构\"></a>6.文件系统的结构</h2><p>前面提到 Linux 是用位图的方式管理空闲空间，用户在创建一个新文件时，Linux 内核会通过 inode 的位图找到空闲可用的 inode，并进行分配。要存储数据时，会通过块的位图找到空闲的块，并分配，但仔细计算一下还是有问题的。</p>\n<p>数据块的位图是放在磁盘块里的，假设是放在一个块里，一个块 4K，每位表示一个数据块，共可以表示 <code>4 * 1024 * 8 = 2^15</code> 个空闲块，由于 1 个数据块是 4K 大小，那么最大可以表示的空间为 <code>2^15 * 4 * 1024 = 2^27</code> 个 byte，也就是 128M。</p>\n<p>也就是说按照上面的结构，如果采用「一个块的位图 + 一系列的块」，外加「一个块的 inode 的位图 + 一系列的 inode 的结构」能表示的最大空间也就 128M，这太少了，现在很多文件都比这个大。</p>\n<p>在 Linux 文件系统，把这个结构称为一个<strong>块组</strong>，那么有 N 多的块组，就能够表示 N 大的文件。</p>\n<p>下图给出了 Linux Ext2 整个文件系统的结构和块组的内容，文件系统都由大量块组组成，在硬盘上相继排布：</p>\n<p><img src=\"/oranfish.github.io/oranfish.github.io/posts/0/OS-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/%E5%9D%97%E7%BB%84.png\" alt=\"img\"></p>\n<p>最前面的第一个块是引导块，在系统启动时用于启用引导，接着后面就是一个一个连续的块组了，块组的内容如下：</p>\n<ul>\n<li><em>超级块</em>，包含的是文件系统的重要信息，比如 inode 总个数、块总个数、每个块组的 inode 个数、每个块组的块个数等等。</li>\n<li><em>块组描述符</em>，包含文件系统中各个块组的状态，比如块组中空闲块和 inode 的数目等，每个块组都包含了文件系统中「所有块组的组描述符信息」。</li>\n<li><em>数据位图和 inode 位图</em>， 用于表示对应的数据块或 inode 是空闲的，还是被使用中。</li>\n<li><em>inode 列表</em>，包含了块组中所有的 inode，inode 用于保存文件系统中与各个文件和目录相关的所有元数据。</li>\n<li><em>数据块</em>，包含文件的有用数据。</li>\n</ul>\n<p>你可以会发现每个块组里有很多重复的信息，比如<strong>超级块和块组描述符表，这两个都是全局信息，而且非常的重要</strong>，这么做是有两个原因：</p>\n<ul>\n<li>如果系统崩溃破坏了超级块或块组描述符，有关文件系统结构和内容的所有信息都会丢失。如果有冗余的副本，该信息是可能恢复的。</li>\n<li>通过使文件和管理数据尽可能接近，减少了磁头寻道和旋转，这可以提高文件系统的性能。</li>\n</ul>\n<p>不过，Ext2 的后续版本采用了稀疏技术。该做法是，超级块和块组描述符表不再存储到文件系统的每个块组中，而是只写入到块组 0、块组 1 和其他 ID 可以表示为 3、 5、7 的幂的块组中。</p>\n<h2 id=\"7-目录的存储\"><a href=\"#7-目录的存储\" class=\"headerlink\" title=\"7.目录的存储\"></a>7.目录的存储</h2><p>基于 Linux 一切皆文件的设计思想，目录其实也是个文件，你甚至可以通过 <code>vim</code> 打开它，它也有 inode，inode 里面也是指向一些块。</p>\n<p>和普通文件不同的是，<strong>普通文件的块里面保存的是文件数据，而目录文件的块里面保存的是目录里面一项一项的文件信息。</strong></p>\n<p>在目录文件的块中，最简单的保存格式就是<strong>列表</strong>，就是一项一项地将目录下的文件信息（如文件名、文件 inode、文件类型等）列在表里。</p>\n<p>列表中每一项就代表该目录下的文件的文件名和对应的 inode，通过这个 inode，就可以找到真正的文件。</p>\n<img src=\"/oranfish.github.io/oranfish.github.io/posts/0/%E7%9B%AE%E5%BD%95%E5%93%88%E5%B8%8C%E8%A1%A8.png\" alt=\"目录格式哈希表\" style=\"zoom:33%;\">\n\n<p>如果一个目录有超级多的文件，我们要想在这个目录下找文件，按照列表一项一项的找，效率就不高了。</p>\n<p>于是，保存目录的格式改成<strong>哈希表</strong>，对文件名进行哈希计算，把哈希值保存起来，如果我们要查找一个目录下面的文件名，可以通过名称取哈希。如果哈希能够匹配上，就说明这个文件的信息在相应的块里面。</p>\n<p>Linux 系统的 ext 文件系统就是采用了哈希表，来保存目录的内容，这种方法的优点是查找非常迅速，插入和删除也较简单，不过需要一些预备措施来避免哈希冲突。</p>\n<p>目录查询是通过在磁盘上反复搜索完成，需要不断地进行 I&#x2F;O 操作，开销较大。所以，为了减少 I&#x2F;O 操作，把当前使用的文件目录缓存在内存，以后要使用该文件时只要在内存中操作，从而降低了磁盘操作次数，提高了文件系统的访问速度。</p>\n<h2 id=\"8-软链接和硬链接\"><a href=\"#8-软链接和硬链接\" class=\"headerlink\" title=\"8.软链接和硬链接\"></a>8.软链接和硬链接</h2><p>有时候我们希望给某个文件取个别名，那么在 Linux 中可以通过<strong>硬链接（*Hard Link*）</strong> 和<strong>软链接（*Symbolic Link*）</strong> 的方式来实现，它们都是比较特殊的文件，但是实现方式也是不相同的。</p>\n<p>硬链接是<strong>多个目录项中的「索引节点」指向一个文件</strong>，也就是指向同一个 inode，但是 inode 是不可能跨越文件系统的，每个文件系统都有各自的 inode 数据结构和列表，所以<strong>硬链接是不可用于跨文件系统的</strong>。由于多个目录项都是指向一个 inode，那么<strong>只有删除文件的所有硬链接以及源文件时，系统才会彻底删除该文件。</strong></p>\n<img src=\"/oranfish.github.io/oranfish.github.io/posts/0/%E7%A1%AC%E9%93%BE%E6%8E%A5-2.png\" alt=\"硬链接\" style=\"zoom:50%;\">\n\n<p>软链接相当于重新创建一个文件，这个文件有<strong>独立的 inode</strong>，但是这个<strong>文件的内容是另外一个文件的路径</strong>，所以访问软链接的时候，实际上相当于访问到了另外一个文件，所以<strong>软链接是可以跨文件系统的</strong>，甚至<strong>目标文件被删除了，链接文件还是在的，只不过指向的文件找不到了而已。</strong></p>\n<img src=\"/oranfish.github.io/oranfish.github.io/posts/0/%E8%BD%AF%E9%93%BE%E6%8E%A5.png\" alt=\"软链接\" style=\"zoom: 50%;\">\n\n\n\n<h2 id=\"9-文件I-O\"><a href=\"#9-文件I-O\" class=\"headerlink\" title=\"9.文件I&#x2F;O\"></a>9.文件I&#x2F;O</h2><h3 id=\"9-1-缓存与非缓存I-O\"><a href=\"#9-1-缓存与非缓存I-O\" class=\"headerlink\" title=\"9.1 缓存与非缓存I&#x2F;O\"></a>9.1 缓存与非缓存I&#x2F;O</h3><p>文件操作的标准库是可以实现数据的缓存，那么<strong>根据「是否利用标准库缓冲」，可以把文件 I&#x2F;O 分为缓冲 I&#x2F;O 和非缓冲 I&#x2F;O</strong>：</p>\n<ul>\n<li>缓冲 I&#x2F;O，利用的是标准库的缓存实现文件的加速访问，而标准库再通过系统调用访问文件。</li>\n<li>非缓冲 I&#x2F;O，直接通过系统调用访问文件，不经过标准库缓存。</li>\n</ul>\n<p>这里所说的「缓冲」特指标准库内部实现的缓冲。</p>\n<p>比方说，很多程序遇到换行时才真正输出，而换行前的内容，其实就是被标准库暂时缓存了起来，这样做的目的是，减少系统调用的次数，毕竟系统调用是有 CPU 上下文切换的开销的。</p>\n<h3 id=\"9-2-直接与非直接I-O\"><a href=\"#9-2-直接与非直接I-O\" class=\"headerlink\" title=\"9.2 直接与非直接I&#x2F;O\"></a>9.2 直接与非直接I&#x2F;O</h3><p>Linux 内核为了减少磁盘 I&#x2F;O 次数，在系统调用后，会把用户数据拷贝到内核中缓存起来，这个内核缓存空间也就是「页缓存」，只有当缓存满足某些条件的时候，才发起磁盘 I&#x2F;O 的请求。</p>\n<p><strong>根据是「否利用操作系统的缓存」，可以把文件 I&#x2F;O 分为直接 I&#x2F;O 与非直接 I&#x2F;O</strong>：</p>\n<ul>\n<li>直接 I&#x2F;O，不会发生内核缓存和用户程序之间数据复制，而是直接经过文件系统访问磁盘。</li>\n<li>非直接 I&#x2F;O，读操作时，数据从内核缓存中拷贝给用户程序，写操作时，数据从用户程序拷贝给内核缓存，再由内核决定什么时候写入数据到磁盘。</li>\n</ul>\n<p>如果你在使用文件操作类的系统调用函数时，指定了 <code>O_DIRECT</code> 标志，则表示使用直接 I&#x2F;O。如果没有设置过，默认使用的是非直接 I&#x2F;O。</p>\n<p>以下几种场景会触发内核缓存的数据写入磁盘：</p>\n<ul>\n<li>在调用 <code>write</code> 的最后，当发现内核缓存的数据太多的时候，内核会把数据写到磁盘上；</li>\n<li>用户主动调用 <code>sync</code>，内核缓存会刷到磁盘上；</li>\n<li>当内存十分紧张，无法再分配页面时，也会把内核缓存的数据刷到磁盘上；</li>\n<li>内核缓存的数据的缓存时间超过某个时间时，也会把数据刷到磁盘上；</li>\n</ul>\n<h3 id=\"9-3-阻塞与非阻塞I-O-VS-同步与异步I-O\"><a href=\"#9-3-阻塞与非阻塞I-O-VS-同步与异步I-O\" class=\"headerlink\" title=\"9.3 阻塞与非阻塞I&#x2F;O VS  同步与异步I&#x2F;O\"></a>9.3 阻塞与非阻塞I&#x2F;O VS  同步与异步I&#x2F;O</h3><p><strong>阻塞 I&#x2F;O</strong>，当用户程序执行 <code>read</code> ，线程会被阻塞，一直等到内核数据准备好，并把数据从内核缓冲区拷贝到应用程序的缓冲区中，当拷贝过程完成，<code>read</code> 才会返回。</p>\n<p>注意，<strong>阻塞等待的是「内核数据准备好」和「数据从内核态拷贝到用户态」这两个过程</strong>。</p>\n<img src=\"/oranfish.github.io/oranfish.github.io/posts/0/%E9%98%BB%E5%A1%9E%20I_O.png\" alt=\"阻塞 I/O\" style=\"zoom:50%;\">\n\n<p><strong>非阻塞 I&#x2F;O</strong>，非阻塞的 read 请求在数据未准备好的情况下立即返回，可以继续往下执行，此时应用程序不断轮询内核，直到数据准备好，内核将数据拷贝到应用程序缓冲区，<code>read</code> 调用才可以获取到结果。</p>\n<img src=\"/oranfish.github.io/oranfish.github.io/posts/0/%E9%9D%9E%E9%98%BB%E5%A1%9E%20I_O%20.png\" alt=\"非阻塞 I/O\" style=\"zoom:50%;\">\n\n<p>注意，<strong>这里最后一次 read 调用，获取数据的过程，是一个同步的过程，是需要等待的过程。这里的同步指的是内核态的数据拷贝到用户程序的缓存区这个过程。</strong></p>\n<p>为了解决程序每次轮询内核的I&#x2F;O上是否准备好的问题，产生了<strong>I&#x2F;O多路复用</strong>技术，如 select、poll，它是通过 I&#x2F;O 事件分发，当内核数据准备好时，再以事件通知应用程序进行操作。</p>\n<p>这个做法大大改善了 CPU 的利用率，因为当调用了 I&#x2F;O 多路复用接口，如果没有事件发生，那么当前线程就会发生阻塞，这时 CPU 会切换其他线程执行任务，等内核发现有事件到来的时候，会唤醒阻塞在 I&#x2F;O 多路复用接口的线程，然后用户可以进行后续的事件处理。</p>\n<p>整个流程要比阻塞 IO 要复杂，似乎也更浪费性能。但 <strong>I&#x2F;O 多路复用接口最大的优势在于，用户可以在一个线程内同时处理多个 socket 的 IO 请求</strong>。</p>\n<p>用户可以注册多个 socket，然后不断地调用 I&#x2F;O 多路复用接口读取被激活的 socket，即可达到在同一个线程内同时处理多个 IO 请求的目的。而在同步阻塞模型中，必须通过多线程的方式才能达到这个目的。</p>\n<p>下图是使用 select I&#x2F;O 多路复用过程。注意，<code>read</code> 获取数据的过程（数据从内核态拷贝到用户态的过程），也是一个<strong>同步的过程</strong>，需要等待：</p>\n<img src=\"/oranfish.github.io/oranfish.github.io/posts/0/%E5%9F%BA%E4%BA%8E%E9%9D%9E%E9%98%BB%E5%A1%9E%20I_O%20%E7%9A%84%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.png\" alt=\"I/O 多路复用\" style=\"zoom:50%;\">\n\n<p>实际上，无论是阻塞 I&#x2F;O、非阻塞 I&#x2F;O，还是基于非阻塞 I&#x2F;O 的多路复用<strong>都是同步调用。因为它们在 read 调用时，内核将数据从内核空间拷贝到应用程序空间，过程都是需要等待的，也就是说这个过程是同步的，如果内核实现的拷贝效率不高，read 调用就会在这个同步过程中等待比较长的时间。</strong></p>\n<p>而真正的<strong>异步 I&#x2F;O</strong> 是「内核数据准备好」和「数据从内核态拷贝到用户态」这两个过程都不用等待。</p>\n<p>当我们发起 <code>aio_read</code> 之后，就立即返回，内核自动将数据从内核空间拷贝到应用程序空间，这个拷贝过程同样是异步的，内核自动完成的，和前面的同步操作不一样，应用程序并不需要主动发起拷贝动作。过程如下图：</p>\n<img src=\"/oranfish.github.io/oranfish.github.io/posts/0/%E5%BC%82%E6%AD%A5%20I_O.png\" alt=\"异步 I/O\" style=\"zoom:50%;\">\n\n<p>下面这张图，总结了以上几种 I&#x2F;O 模型：</p>\n<img src=\"/oranfish.github.io/oranfish.github.io/posts/0/%E5%90%8C%E6%AD%A5VS%E5%BC%82%E6%AD%A5IO.png\" alt=\"img\" style=\"zoom:50%;\">\n\n<p>在前面我们知道了，I&#x2F;O 是分为两个过程的：</p>\n<ol>\n<li>数据准备的过程</li>\n<li>数据从内核空间拷贝到用户进程缓冲区的过程</li>\n</ol>\n<p>阻塞 I&#x2F;O 会阻塞在「过程 1 」和「过程 2」，而非阻塞 I&#x2F;O 和基于非阻塞 I&#x2F;O 的多路复用只会阻塞在「过程 2」，所以这三个都可以认为是同步 I&#x2F;O。</p>\n<p>异步 I&#x2F;O 则不同，「过程 1 」和「过程 2 」都不会阻塞。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>用故事去理解这几种 I&#x2F;O 模型</p>\n<p>举个你去饭堂吃饭的例子，你好比用户程序，饭堂好比操作系统。</p>\n<p>阻塞 I&#x2F;O 好比，你去饭堂吃饭，但是饭堂的菜还没做好，然后你就一直在那里等啊等，等了好长一段时间终于等到饭堂阿姨把菜端了出来（数据准备的过程），但是你还得继续等阿姨把菜（内核空间）打到你的饭盒里（用户空间），经历完这两个过程，你才可以离开。</p>\n<p>非阻塞 I&#x2F;O 好比，你去了饭堂，问阿姨菜做好了没有，阿姨告诉你没，你就离开了，过几十分钟，你又来饭堂问阿姨，阿姨说做好了，于是阿姨帮你把菜打到你的饭盒里，这个过程你是得等待的。</p>\n<p>基于非阻塞的 I&#x2F;O 多路复用好比，你去饭堂吃饭，发现有一排窗口，饭堂阿姨告诉你这些窗口都还没做好菜，等做好了再通知你，于是等啊等（<code>select</code> 调用中），过了一会阿姨通知你菜做好了，但是不知道哪个窗口的菜做好了，你自己看吧。于是你只能一个一个窗口去确认，后面发现 5 号窗口菜做好了，于是你让 5 号窗口的阿姨帮你打菜到饭盒里，这个打菜的过程你是要等待的，虽然时间不长。打完菜后，你自然就可以离开了。</p>\n<p>异步 I&#x2F;O 好比，你让饭堂阿姨将菜做好并把菜打到饭盒里后，把饭盒送到你面前，整个过程你都不需要任何等待。</p></blockquote>\n","text":"1.文件系统的基本组成文件系统是操作系统中负责管理持久数据的子系统，负责把用户文件存到磁盘硬件。 文件系统的基本数据单位是文件，它的目的是对磁盘上的文件进行组织...","permalink":"/post/OS-文件系统","photos":[],"count_time":{"symbolsCount":"10k","symbolsTime":"9 mins."},"categories":[{"name":"Study","slug":"Study","count":30,"path":"api/categories/Study.json"}],"tags":[{"name":"学习","slug":"学习","count":20,"path":"api/tags/学习.json"},{"name":"操作系统","slug":"操作系统","count":9,"path":"api/tags/操作系统.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90\"><span class=\"toc-text\">1.文件系统的基本组成</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-1-%E7%9B%AE%E5%BD%95%E9%A1%B9%E5%92%8C%E7%9B%AE%E5%BD%95%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">1.1 目录项和目录区别</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-2-%E6%96%87%E4%BB%B6%E6%95%B0%E6%8D%AE%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E5%9C%A8%E7%A3%81%E7%9B%98\"><span class=\"toc-text\">1.2 文件数据如何存储在磁盘</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F\"><span class=\"toc-text\">2.虚拟文件系统</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-%E6%96%87%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">3.文件的使用</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-%E6%96%87%E4%BB%B6%E7%9A%84%E5%AD%98%E5%82%A8\"><span class=\"toc-text\">4.文件的存储</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-1-%E8%BF%9E%E7%BB%AD%E7%A9%BA%E9%97%B4%E5%AD%98%E6%94%BE%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">4.1 连续空间存放方式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-2-%E9%9D%9E%E8%BF%9E%E7%BB%AD%E7%A9%BA%E9%97%B4%E5%AD%98%E6%94%BE%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">4.2 非连续空间存放方式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-2-1-%E9%93%BE%E8%A1%A8%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">4.2.1 链表方式</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-2-2-%E7%B4%A2%E5%BC%95%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">4.2.2 索引方式</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-3-Unix%E6%96%87%E4%BB%B6%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">4.3 Unix文件的实现方式</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-%E7%A9%BA%E9%97%B2%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">5.空闲空间管理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-1-%E7%A9%BA%E9%97%B2%E8%A1%A8%E6%B3%95\"><span class=\"toc-text\">5.1 空闲表法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-2-%E7%A9%BA%E9%97%B2%E9%93%BE%E8%A1%A8%E6%B3%95\"><span class=\"toc-text\">5.2 空闲链表法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-3-%E4%BD%8D%E5%9B%BE%E6%B3%95\"><span class=\"toc-text\">5.3 位图法</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">6.文件系统的结构</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#7-%E7%9B%AE%E5%BD%95%E7%9A%84%E5%AD%98%E5%82%A8\"><span class=\"toc-text\">7.目录的存储</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#8-%E8%BD%AF%E9%93%BE%E6%8E%A5%E5%92%8C%E7%A1%AC%E9%93%BE%E6%8E%A5\"><span class=\"toc-text\">8.软链接和硬链接</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#9-%E6%96%87%E4%BB%B6I-O\"><span class=\"toc-text\">9.文件I&#x2F;O</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#9-1-%E7%BC%93%E5%AD%98%E4%B8%8E%E9%9D%9E%E7%BC%93%E5%AD%98I-O\"><span class=\"toc-text\">9.1 缓存与非缓存I&#x2F;O</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#9-2-%E7%9B%B4%E6%8E%A5%E4%B8%8E%E9%9D%9E%E7%9B%B4%E6%8E%A5I-O\"><span class=\"toc-text\">9.2 直接与非直接I&#x2F;O</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#9-3-%E9%98%BB%E5%A1%9E%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9EI-O-VS-%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5I-O\"><span class=\"toc-text\">9.3 阻塞与非阻塞I&#x2F;O VS  同步与异步I&#x2F;O</span></a></li></ol></li></ol>","author":{"name":"Fioransh","slug":"blog-author","avatar":"/medias/2.jpg","link":"/","description":"<p> 学而无知，无知而学 <p> <p> Anime is trash and so am I. <p>","socials":{"github":"https://github.com/orangefish1118","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/14481775?spm_id_from=333.1007.0.0"},"gitee":{"icon":"/svg/gitee.svg","link":"https://gitee.com/Orangefish-cyc"},"mail":{"icon":"/svg/email.svg","link":"mailto:1263938020@qq.com"}}}},"mapped":true,"hidden":false,"prev_post":{"title":"OS-进程通信方式","uid":"6c3d1454bbe7a724ef7580b6eaa23896","slug":"OS-进程通信方式","date":"2024-06-08T13:25:12.000Z","updated":"2024-06-19T08:02:21.214Z","comments":true,"path":"api/articles/OS-进程通信方式.json","keywords":"博客、橙汁蒸鱼、Orangefish、Oranfish","cover":"/medias/30.jpg","text":"1.管道1.1 基础介绍每个进程的用户地址空间都是独立的，一般而言是不能互相访问的，但内核空间是每个进程都共享的，所以进程之间要通信必须通过内核。Linux 内...","permalink":"/post/OS-进程通信方式","photos":[],"count_time":{"symbolsCount":"9.1k","symbolsTime":"8 mins."},"categories":[{"name":"Study","slug":"Study","count":30,"path":"api/categories/Study.json"}],"tags":[{"name":"学习","slug":"学习","count":20,"path":"api/tags/学习.json"},{"name":"操作系统","slug":"操作系统","count":9,"path":"api/tags/操作系统.json"}],"author":{"name":"Fioransh","slug":"blog-author","avatar":"/medias/2.jpg","link":"/","description":"<p> 学而无知，无知而学 <p> <p> Anime is trash and so am I. <p>","socials":{"github":"https://github.com/orangefish1118","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/14481775?spm_id_from=333.1007.0.0"},"gitee":{"icon":"/svg/gitee.svg","link":"https://gitee.com/Orangefish-cyc"},"mail":{"icon":"/svg/email.svg","link":"mailto:1263938020@qq.com"}}}}},"next_post":{"title":"OS-调度算法","uid":"1074313276193b1539ba5882aa8b135e","slug":"OS-调度算法","date":"2024-06-04T14:25:12.000Z","updated":"2024-06-19T08:00:40.517Z","comments":true,"path":"api/articles/OS-调度算法.json","keywords":"博客、橙汁蒸鱼、Orangefish、Oranfish","cover":"/medias/28.jpg","text":"1.进程调度算法当 CPU 空闲时，操作系统就选择内存中的某个「就绪状态」的进程，并给其分配 CPU。 非抢占式的意思就是，当进程正在运行时，它就会一直运行，直...","permalink":"/post/OS-调度算法","photos":[],"count_time":{"symbolsCount":"6k","symbolsTime":"5 mins."},"categories":[{"name":"Study","slug":"Study","count":30,"path":"api/categories/Study.json"}],"tags":[{"name":"学习","slug":"学习","count":20,"path":"api/tags/学习.json"},{"name":"操作系统","slug":"操作系统","count":9,"path":"api/tags/操作系统.json"}],"author":{"name":"Fioransh","slug":"blog-author","avatar":"/medias/2.jpg","link":"/","description":"<p> 学而无知，无知而学 <p> <p> Anime is trash and so am I. <p>","socials":{"github":"https://github.com/orangefish1118","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/14481775?spm_id_from=333.1007.0.0"},"gitee":{"icon":"/svg/gitee.svg","link":"https://gitee.com/Orangefish-cyc"},"mail":{"icon":"/svg/email.svg","link":"mailto:1263938020@qq.com"}}}}}}