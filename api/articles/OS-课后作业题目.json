{"title":"OS-课后作业题目总结","uid":"77c1bfd730d0b976f5020ec70d93bbca","slug":"OS-课后作业题目","date":"2024-05-12T10:25:12.000Z","updated":"2024-06-19T08:54:19.280Z","comments":true,"path":"api/articles/OS-课后作业题目.json","keywords":"博客、橙汁蒸鱼、Orangefish、Oranfish","cover":"/medias/32.jpg","content":"<h2 id=\"第一章\"><a href=\"#第一章\" class=\"headerlink\" title=\"第一章\"></a>第一章</h2><p>1.一台计算机包括高速缓存、内存和磁盘，如果要存取的字在高速缓存中，从高速缓存存取需要20ns；如果该字不在高速缓存中而在内存中，先把它从内存载入高速缓存需要60ns，然后再从高速缓存存取；如果该字不在内存中，则先需要花费12ms从磁盘中取到内存，接着从内存复制到高速缓存中，再从高速缓存存取。高速缓存的命中率为0.9，内存的命中率为0.6，则该系统中一个字的平均存取时间是多少ns？</p>\n<p><strong>解答：</strong></p>\n<p><img src=\"/orangefish1118.github.io/orangefish1118.github.io/posts/0/OS%E8%AF%BE%E5%90%8E%E4%BD%9C%E4%B8%9A%E9%A2%98%E7%9B%AE/image-20240510194525002.png\" alt=\"image-20240510194525002\"></p>\n<p>平均存取时间为：0.9×20 + 0.06×80 + 0.04×12000080 &#x3D; 480026 ns</p>\n<p>2.假设系统中有两个程序A和B待执行，设以A、B的先后顺序运行，不能互相抢占CPU。程序A的访问流程是：处理器10秒，设备甲5秒，处理器5秒，设备乙10秒，处理器10秒；程序B的访问流程是：设备甲10秒，处理器10秒，设备乙5秒，处理器5秒，设备乙10秒。在单道程序环境下和多道程序环境下执行，处理器的利用率是分别是多少？</p>\n<p><strong>解答：</strong></p>\n<p>单道CPU利用率：(10+5+10+10+5)\\80＝50％</p>\n<p><img src=\"/orangefish1118.github.io/orangefish1118.github.io/posts/0/OS%E8%AF%BE%E5%90%8E%E4%BD%9C%E4%B8%9A%E9%A2%98%E7%9B%AE/image-20240510200210127.png\" alt=\"image-20240510200210127\"></p>\n<p>多道CPU利用率：(10+5+10+10+5)\\45＝88.9％ </p>\n<p><img src=\"/orangefish1118.github.io/orangefish1118.github.io/posts/0/OS%E8%AF%BE%E5%90%8E%E4%BD%9C%E4%B8%9A%E9%A2%98%E7%9B%AE/image-20240510200221681.png\" alt=\"image-20240510200221681\"></p>\n<h2 id=\"第二章\"><a href=\"#第二章\" class=\"headerlink\" title=\"第二章\"></a>第二章</h2><p>1.假设在时间5时，系统资源只有处理器和内存被使用。考虑如下事件：<br>时间5：P1执行对磁盘单元3的读操作。<br>时间15：P5的时间片结束。<br>时间18：P7执行对磁盘单元3的写操作。<br>时间20：P3执行对磁盘单元2的读操作。<br>时间24：P5执行对磁盘单元3的写操作。<br>时间28：P5被换出。<br>时间33：P3读磁盘单元2操作完成，产生中断。<br>时间36：P1读磁盘单元3操作完成，产生中断。<br>时间38：P8结束。<br>时间40：P5写磁盘单元3操作完成，产生中断。<br>时间44：P5被调入。<br>时间48：P7写磁盘单元3操作完成，产生中断。<br>请分别写出时间22、37和47时每个进程的状态。如果一个进程在阻塞态，写出其等待的事件。</p>\n<p><strong>解答：</strong></p>\n<p><img src=\"/orangefish1118.github.io/orangefish1118.github.io/posts/0/OS%E8%AF%BE%E5%90%8E%E4%BD%9C%E4%B8%9A%E9%A2%98%E7%9B%AE/image-20240510200509084.png\" alt=\"image-20240510200509084\"></p>\n<p>注：47时刻，P1、P3、P5中有两个就绪，另一个运行</p>\n<p>2.某分时系统中的进程可能出现如下图所示的状态变化，请把图中每个状态变化以及变化的可能原因填写在下表中。</p>\n<p><img src=\"/orangefish1118.github.io/orangefish1118.github.io/posts/0/OS%E8%AF%BE%E5%90%8E%E4%BD%9C%E4%B8%9A%E9%A2%98%E7%9B%AE/image-20240510200541844.png\" alt=\"image-20240510200541844\"></p>\n<p><strong>解答：</strong></p>\n<p><img src=\"/orangefish1118.github.io/orangefish1118.github.io/posts/0/OS%E8%AF%BE%E5%90%8E%E4%BD%9C%E4%B8%9A%E9%A2%98%E7%9B%AE/image-20240510200626409.png\" alt=\"image-20240510200626409\"></p>\n<p>3.写出信号量定义，semWait和semSignal原语，以及用信号量实现互斥的伪代码。</p>\n<p><strong>解答：</strong></p>\n<p><img src=\"/orangefish1118.github.io/orangefish1118.github.io/posts/0/OS%E8%AF%BE%E5%90%8E%E4%BD%9C%E4%B8%9A%E9%A2%98%E7%9B%AE/image-20240510200657339.png\" alt=\"image-20240510200657339\"></p>\n<p><img src=\"/orangefish1118.github.io/orangefish1118.github.io/posts/0/OS%E8%AF%BE%E5%90%8E%E4%BD%9C%E4%B8%9A%E9%A2%98%E7%9B%AE/image-20240510200716334.png\"></p>\n<p>4.假设一个阅览室有100个座位，没有座位时读者在阅览室外等待；每个读者进入阅览室时都必须在阅览室门口的一个登记本上登记座位号和姓名，然后阅览，离开阅览室时要去掉登记项。每次只允许一个人登记或去掉登记。用信号量操作描述读者的行为。</p>\n<p><strong>解答：</strong></p>\n<div class=\"language-cpp\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">cpp</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #BABED8\">semaphore seatcount</span><span style=\"color: #89DDFF\">=</span><span style=\"color: #F78C6C\">100</span><span style=\"color: #89DDFF\">;</span><span style=\"color: #676E95; font-style: italic\">  //空座位数</span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">semaphore mutex</span><span style=\"color: #89DDFF\">=</span><span style=\"color: #F78C6C\">1</span><span style=\"color: #89DDFF\">;</span><span style=\"color: #676E95; font-style: italic\">            //互斥操作登记本</span></span>\n<span class=\"line\"><span style=\"color: #C792EA\">void</span><span style=\"color: #BABED8\"> </span><span style=\"color: #82AAFF\">readeri</span><span style=\"color: #89DDFF\">()&#123;</span><span style=\"color: #BABED8\">                             </span></span>\n<span class=\"line\"><span style=\"color: #BABED8\">  </span><span style=\"color: #89DDFF; font-style: italic\">while</span><span style=\"color: #89DDFF\">(true)&#123;</span></span>\n<span class=\"line\"><span style=\"color: #F07178\">      </span><span style=\"color: #82AAFF\">semWait</span><span style=\"color: #89DDFF\">(</span><span style=\"color: #F07178\">seatcount</span><span style=\"color: #89DDFF\">);</span></span>\n<span class=\"line\"><span style=\"color: #F07178\">      </span><span style=\"color: #82AAFF\">semWait</span><span style=\"color: #F07178\"> </span><span style=\"color: #89DDFF\">(</span><span style=\"color: #F07178\">mutex</span><span style=\"color: #89DDFF\">)</span><span style=\"color: #F07178\">；</span></span>\n<span class=\"line\"><span style=\"color: #F07178\">            登记；</span></span>\n<span class=\"line\"><span style=\"color: #F07178\">      </span><span style=\"color: #82AAFF\">semSignal</span><span style=\"color: #F07178\"> </span><span style=\"color: #89DDFF\">(</span><span style=\"color: #F07178\">mutex</span><span style=\"color: #89DDFF\">);</span></span>\n<span class=\"line\"><span style=\"color: #F07178\">         进入阅览室坐下读书；</span></span>\n<span class=\"line\"><span style=\"color: #F07178\">      </span><span style=\"color: #82AAFF\">semWait</span><span style=\"color: #F07178\"> </span><span style=\"color: #89DDFF\">(</span><span style=\"color: #F07178\">mutex</span><span style=\"color: #89DDFF\">);</span></span>\n<span class=\"line\"><span style=\"color: #F07178\">           取消登记；</span></span>\n<span class=\"line\"><span style=\"color: #F07178\">      </span><span style=\"color: #82AAFF\">semSignal</span><span style=\"color: #89DDFF\">(</span><span style=\"color: #F07178\">mutex</span><span style=\"color: #89DDFF\">);</span></span>\n<span class=\"line\"><span style=\"color: #F07178\">      </span><span style=\"color: #82AAFF\">semSignal</span><span style=\"color: #89DDFF\">(</span><span style=\"color: #F07178\">seatcount</span><span style=\"color: #89DDFF\">);</span></span>\n<span class=\"line\"><span style=\"color: #F07178\">          离开阅览室；</span></span>\n<span class=\"line\"><span style=\"color: #89DDFF\">&#125;&#125;</span></span></code></pre></div><p>5.6个进程：P0…P5；4种资源：A(15)、B(6)、C(9)、D(10)； T0时刻状态如图所示。问题：<br>（1）验证可用资源向量的正确性。<br>（2）计算需求矩阵。<br>（3）指出一个安全的进程序列来证明当前状态的安全性。同时指出每个进程结束时可用资源向量的变化情况。<br>（4）假设P5请求资源（3, 2, 3, 3），该请求应该被允许吗？请说明理由。</p>\n<p><img src=\"/orangefish1118.github.io/orangefish1118.github.io/posts/0/OS%E8%AF%BE%E5%90%8E%E4%BD%9C%E4%B8%9A%E9%A2%98%E7%9B%AE/image-20240510200846110.png\" alt=\"image-20240510200846110\"></p>\n<p><strong>解答：</strong></p>\n<ul>\n<li>2+0+4+1+1+1+6&#x3D;15<br>0+1+1+0+1+0+3&#x3D;6<br>2+1+0+0+0+1+5&#x3D;9<br>1+1+2+1+0+1+4&#x3D;10<br>因此，可用资源向量正确。</li>\n<li><img src=\"/orangefish1118.github.io/orangefish1118.github.io/posts/0/OS%E8%AF%BE%E5%90%8E%E4%BD%9C%E4%B8%9A%E9%A2%98%E7%9B%AE/image-20240510202217637.png\" alt=\"image-20240510202217637\"></li>\n<li><img src=\"/orangefish1118.github.io/orangefish1118.github.io/posts/0/OS%E8%AF%BE%E5%90%8E%E4%BD%9C%E4%B8%9A%E9%A2%98%E7%9B%AE/image-20240510202228147.png\" alt=\"image-20240510202228147\"></li>\n<li><img src=\"/orangefish1118.github.io/orangefish1118.github.io/posts/0/OS%E8%AF%BE%E5%90%8E%E4%BD%9C%E4%B8%9A%E9%A2%98%E7%9B%AE/image-20240510202240733.png\" alt=\"image-20240510202240733\"></li>\n</ul>\n<p>6.如下的代码涉及3个进程竞争6种资源（A~F）。<br>（1）使用资源分配图来指出这种实现中可能存在的死锁。<br>（2）改变某些请求的顺序来预防死锁。注意不能跨函数移动请求，只能在函数内部调整请求的顺序。</p>\n<p><img src=\"/orangefish1118.github.io/orangefish1118.github.io/posts/0/OS%E8%AF%BE%E5%90%8E%E4%BD%9C%E4%B8%9A%E9%A2%98%E7%9B%AE/image-20240510202301498.png\" alt=\"image-20240510202301498\"></p>\n<p><strong>解答：</strong></p>\n<ul>\n<li><img src=\"/orangefish1118.github.io/orangefish1118.github.io/posts/0/OS%E8%AF%BE%E5%90%8E%E4%BD%9C%E4%B8%9A%E9%A2%98%E7%9B%AE/image-20240510202323070.png\" alt=\"image-20240510202323070\"></li>\n<li><img src=\"/orangefish1118.github.io/orangefish1118.github.io/posts/0/OS%E8%AF%BE%E5%90%8E%E4%BD%9C%E4%B8%9A%E9%A2%98%E7%9B%AE/image-20240510202330201.png\" alt=\"image-20240510202330201\"></li>\n</ul>\n<h2 id=\"第三章\"><a href=\"#第三章\" class=\"headerlink\" title=\"第三章\"></a>第三章</h2><p>1.假设使用动态分区，下图是经过数次放置和换出操作后的内存格局。内存地址从左到右增长；灰色区域是分配给进程的内存块；白色区域是可用内存块。空闲块分配总是从左到右（从低地址端到高地址端）。最后一个放置的进程A大小为2MB，用X标记。此后仅换出了一个进程B。<br>（1）换出的进程B最大是多少？<br>（2）从一个空闲块K中，分配2MB给进程A，那么分配之前，这个空闲块K的大小是多少？<br>（3）下一个内存需求大小为3MB。在使用最佳适配&#x2F;首次适配&#x2F;下次适配&#x2F;最差适配的情况下，分别在图上标记出分配的内存区域。</p>\n<p><img src=\"/orangefish1118.github.io/orangefish1118.github.io/posts/0/OS%E8%AF%BE%E5%90%8E%E4%BD%9C%E4%B8%9A%E9%A2%98%E7%9B%AE/image-20240510202611375.png\" alt=\"image-20240510202611375\"></p>\n<p><strong>解答：</strong></p>\n<p>（1）换出的最大进程大小是多少？<br>1M<br>（2）创建分区并分配给X之前，空闲块的大小是多少？<br>7M<br>（3）下一个内存需求大小为3MB。在使用最佳适配&#x2F;首次适配&#x2F;下次适配&#x2F;最差适配的情况下，分别在图上标记出分配的内存区域</p>\n<p><img src=\"/orangefish1118.github.io/orangefish1118.github.io/posts/0/OS%E8%AF%BE%E5%90%8E%E4%BD%9C%E4%B8%9A%E9%A2%98%E7%9B%AE/image-20240510202627342.png\" alt=\"image-20240510202627342\"></p>\n<p>2.一个1MB的内存块使用伙伴系统来分配内存。请画出类似图3.5的图来表示如下序列的结果：A:请求70；B:请求35；C:请求80；释放A；D:请求60；释放B；释放D；释放C。</p>\n<p><strong>解答：</strong></p>\n<p><img src=\"/orangefish1118.github.io/orangefish1118.github.io/posts/0/OS%E8%AF%BE%E5%90%8E%E4%BD%9C%E4%B8%9A%E9%A2%98%E7%9B%AE/image-20240510202718084.png\" alt=\"image-20240510202718084\"></p>\n<p>3.在一个简单分段系统中，包含如下图所示段表，对下面的每一个逻辑地址，确定其对应的物理地址或者说明段错误是否会发生。<br>(1) 0,198      (2)  2,156      (3)  1,530      (4)  3,444      (5)  0,222</p>\n<p><img src=\"/orangefish1118.github.io/orangefish1118.github.io/posts/0/OS%E8%AF%BE%E5%90%8E%E4%BD%9C%E4%B8%9A%E9%A2%98%E7%9B%AE/image-20240510202740875.png\" alt=\"image-20240510202740875\"></p>\n<p><strong>解答：</strong></p>\n<p>（1）660+198&#x3D;858<br>（2）222+156&#x3D;378<br>（3）段错误，因为530&gt;422<br>（4）996+444&#x3D;1440<br>（5）660+222&#x3D;882</p>\n<p>4.页式存储管理系统中，某进程页表如下。已知页面大小为1024字节，问逻辑地址600，2700，4000所对应的物理地址各是多少？</p>\n<p><img src=\"/orangefish1118.github.io/orangefish1118.github.io/posts/0/OS%E8%AF%BE%E5%90%8E%E4%BD%9C%E4%B8%9A%E9%A2%98%E7%9B%AE/image-20240510202802445.png\" alt=\"image-20240510202802445\"></p>\n<p><strong>解答：</strong></p>\n<p>600&#x2F;1024&#x3D;0…600    7<em>1024+600&#x3D;7768<br>2700&#x2F;1024&#x3D;2…652   5</em>1024+652&#x3D;5772<br>4000&#x2F;1024&#x3D;3…928   非法地址</p>\n<p>5.考虑如下的页访问序列:7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2，请画图说明FIFO、LRU、最佳置换算法（假设后续页面访问序列 1, 2, 0, 1, 7, 0, 1）这三种算法的页框的分配情况（假设该进程分配三个物理块）；对每种情况计算缺页中断次数和缺页率。</p>\n<p><strong>解答：</strong></p>\n<p>FIFO算法：共缺页10次，缺页率 p&#x3D;10&#x2F;13&#x3D;76.9%</p>\n<p><img src=\"/orangefish1118.github.io/orangefish1118.github.io/posts/0/OS%E8%AF%BE%E5%90%8E%E4%BD%9C%E4%B8%9A%E9%A2%98%E7%9B%AE/image-20240510202840753.png\" alt=\"image-20240510202840753\"></p>\n<p> LRU算法：共缺页9次，缺页率 p&#x3D;9&#x2F;13&#x3D;69.2%</p>\n<p><img src=\"/orangefish1118.github.io/orangefish1118.github.io/posts/0/OS%E8%AF%BE%E5%90%8E%E4%BD%9C%E4%B8%9A%E9%A2%98%E7%9B%AE/image-20240510202847953.png\" alt=\"image-20240510202847953\"></p>\n<p> OPT算法：共缺页7次，缺页率 p&#x3D;7&#x2F;13&#x3D;53.8%</p>\n<p><img src=\"/orangefish1118.github.io/orangefish1118.github.io/posts/0/OS%E8%AF%BE%E5%90%8E%E4%BD%9C%E4%B8%9A%E9%A2%98%E7%9B%AE/image-20240510202854724.png\" alt=\"image-20240510202854724\"></p>\n<p>6.考虑一个使用单级页表的分页系统。假设所需的页表总在内存中。（1）如果一次物理内存访问耗时200ns，那么一次逻辑内存访问耗时多少？</p>\n<p>（2）现在添加一个MMU，对每次命中或缺页MMU造成20ns开销。假设85%的内存访问都命中MMU TLB。有效访问时间（EMAT）是多少？</p>\n<p>（3）解释TLB命中率是如何影响EMAT的？</p>\n<p><strong>解答：</strong></p>\n<ul>\n<li>200 * 2&#x3D;400（ns）</li>\n<li>（20+200）* 85%+（20+200+200）* 15%&#x3D;250（ns）</li>\n<li>TLB的命中率越大，有效访问时间越小。</li>\n</ul>\n<h2 id=\"第四章\"><a href=\"#第四章\" class=\"headerlink\" title=\"第四章\"></a>第四章</h2><p>1.从A到E的5个进程同时到达计算中心，它们的估计运行时间分别为15、9、3、6和12分钟，优先级分别为6、3、7、9和4（值越小，表示的优先级越高），所有进程都完全是处理器密集型的。对下面的每种调度算法，确定所有作业的平均周转时间和平均带权周转时间（忽略进程切换的开销）。<br>（1）时间片为1分钟的轮转法。<br>（2）优先级调度。<br>（3）FCFS（按A到E的顺序）。<br>（4）最短进程优先。<br>（5）最高响应比优先。</p>\n<p><strong>解答：</strong></p>\n<ul>\n<li><p><img src=\"/orangefish1118.github.io/orangefish1118.github.io/posts/0/OS%E8%AF%BE%E5%90%8E%E4%BD%9C%E4%B8%9A%E9%A2%98%E7%9B%AE/image-20240510203309331.png\" alt=\"image-20240510203309331\"></p>\n</li>\n<li><p><img src=\"/orangefish1118.github.io/orangefish1118.github.io/posts/0/OS%E8%AF%BE%E5%90%8E%E4%BD%9C%E4%B8%9A%E9%A2%98%E7%9B%AE/image-20240510203316409.png\" alt=\"image-20240510203316409\"></p>\n</li>\n<li><p><img src=\"/orangefish1118.github.io/orangefish1118.github.io/posts/0/OS%E8%AF%BE%E5%90%8E%E4%BD%9C%E4%B8%9A%E9%A2%98%E7%9B%AE/image-20240510203323347.png\" alt=\"image-20240510203323347\"></p>\n</li>\n<li><p><img src=\"/orangefish1118.github.io/orangefish1118.github.io/posts/0/OS%E8%AF%BE%E5%90%8E%E4%BD%9C%E4%B8%9A%E9%A2%98%E7%9B%AE/image-20240510203330097.png\" alt=\"image-20240510203330097\"></p>\n</li>\n<li><p><img src=\"/orangefish1118.github.io/orangefish1118.github.io/posts/0/OS%E8%AF%BE%E5%90%8E%E4%BD%9C%E4%B8%9A%E9%A2%98%E7%9B%AE/image-20240510203338250.png\" alt=\"image-20240510203338250\"></p>\n</li>\n</ul>\n<p>2.在一个三道批处理系统中（N道批处理是指至多允许N个作业进入内存，内存中至多允许N个进程存在，不能进入内存的作业将在后备作业队列中等待），作业调度采用最短作业优先调度算法，进程调度采用以优先级为基础的抢占式调度算法。在下表所示的序列中，所有进程都完全是处理器密集型的，优先数表示进程优先级，此题中优先数越小则优先级越高。试填充表中空白部分。</p>\n<p><strong>解答：</strong></p>\n<p><img src=\"/orangefish1118.github.io/orangefish1118.github.io/posts/0/OS%E8%AF%BE%E5%90%8E%E4%BD%9C%E4%B8%9A%E9%A2%98%E7%9B%AE/image-20240510203407473.png\" alt=\"image-20240510203407473\"></p>\n<p><img src=\"/orangefish1118.github.io/orangefish1118.github.io/posts/0/OS%E8%AF%BE%E5%90%8E%E4%BD%9C%E4%B8%9A%E9%A2%98%E7%9B%AE/image-20240510203854236.png\" alt=\"image-20240510203854236\"></p>\n<p>3.考虑一组周期任务，执行简表如下，给出100个单位时间内，基于最早完成期限调度算法的调度图。</p>\n<p><img src=\"/orangefish1118.github.io/orangefish1118.github.io/posts/0/OS%E8%AF%BE%E5%90%8E%E4%BD%9C%E4%B8%9A%E9%A2%98%E7%9B%AE/image-20240510203917246.png\" alt=\"image-20240510203917246\"></p>\n<p><strong>解答：</strong></p>\n<p><img src=\"/orangefish1118.github.io/orangefish1118.github.io/posts/0/OS%E8%AF%BE%E5%90%8E%E4%BD%9C%E4%B8%9A%E9%A2%98%E7%9B%AE/image-20240510203930051.png\" alt=\"image-20240510203930051\"></p>\n<p>4.考虑5个非周期任务，执行简表如下，给出调度这5个任务，基于有自愿空闲时间的最早最后期限调度算法的调度图。</p>\n<p><img src=\"/orangefish1118.github.io/orangefish1118.github.io/posts/0/OS%E8%AF%BE%E5%90%8E%E4%BD%9C%E4%B8%9A%E9%A2%98%E7%9B%AE/image-20240510203943082.png\" alt=\"image-20240510203943082\"></p>\n<p><strong>解答：</strong></p>\n<p><img src=\"/orangefish1118.github.io/orangefish1118.github.io/posts/0/OS%E8%AF%BE%E5%90%8E%E4%BD%9C%E4%B8%9A%E9%A2%98%E7%9B%AE/image-20240510203953447.png\" alt=\"image-20240510203953447\"></p>\n<h2 id=\"第五章\"><a href=\"#第五章\" class=\"headerlink\" title=\"第五章\"></a>第五章</h2><p>1.分析下列磁道请求序列：27，129，110，186，147，41，10，64，120。假设磁头当前定位在磁道100处。对以下两种移动方向，分别应用FCFS、SSTF、SCAN、C-SCAN算法，求磁道访问顺序及平均寻道长度。<br>（1）沿着磁道号减小的方向移动。<br>（2）沿着磁道号增大的方向移动。</p>\n<p><strong>解答：</strong></p>\n<p>FCFS平均寻道长度：556&#x2F;9&#x3D;61.8</p>\n<p><img src=\"/orangefish1118.github.io/orangefish1118.github.io/posts/0/OS%E8%AF%BE%E5%90%8E%E4%BD%9C%E4%B8%9A%E9%A2%98%E7%9B%AE/image-20240510204029076.png\" alt=\"image-20240510204029076\"></p>\n<p>SSTF平均寻道长度：262&#x2F;9&#x3D;29.1</p>\n<p><img src=\"/orangefish1118.github.io/orangefish1118.github.io/posts/0/OS%E8%AF%BE%E5%90%8E%E4%BD%9C%E4%B8%9A%E9%A2%98%E7%9B%AE/image-20240510204033886.png\" alt=\"image-20240510204033886\"></p>\n<p>小方向SCAN平均寻道长度：266&#x2F;9&#x3D;29.6</p>\n<p><img src=\"/orangefish1118.github.io/orangefish1118.github.io/posts/0/OS%E8%AF%BE%E5%90%8E%E4%BD%9C%E4%B8%9A%E9%A2%98%E7%9B%AE/image-20240510204041454.png\" alt=\"image-20240510204041454\"></p>\n<p>小方向C-SCAN平均寻道长度：342&#x2F;9&#x3D;38</p>\n<p><img src=\"/orangefish1118.github.io/orangefish1118.github.io/posts/0/OS%E8%AF%BE%E5%90%8E%E4%BD%9C%E4%B8%9A%E9%A2%98%E7%9B%AE/image-20240510204046099.png\" alt=\"image-20240510204046099\"></p>\n<p>大方向SCAN平均寻道长度：262&#x2F;9&#x3D;29.1</p>\n<p><img src=\"/orangefish1118.github.io/orangefish1118.github.io/posts/0/OS%E8%AF%BE%E5%90%8E%E4%BD%9C%E4%B8%9A%E9%A2%98%E7%9B%AE/image-20240510204050507.png\" alt=\"image-20240510204050507\"></p>\n<p>大方向C-SCAN平均寻道长度：316&#x2F;9&#x3D;35.1</p>\n<p><img src=\"/orangefish1118.github.io/orangefish1118.github.io/posts/0/OS%E8%AF%BE%E5%90%8E%E4%BD%9C%E4%B8%9A%E9%A2%98%E7%9B%AE/image-20240510204055964.png\" alt=\"image-20240510204055964\"></p>\n<p>2.现有一个RAID磁盘阵列，包含4个磁盘，每个磁盘大小都是200GB。请给出RAID级别分别是0、1、3、4、5、6时，该磁盘阵列的有效存储容量是多少。<br>RAID0：800GB；RAID1：400GB；RAID3：600GB；<br>RAID4：600GB；RAID5：600GB；RAID6：400GB。</p>\n<p><strong>解答：</strong></p>\n<ul>\n<li>RAID0：4个盘均存储数据，4<em>200&#x3D;800；</em></li>\n<li><em>RAID1：2个盘存储，2个盘备份，2</em>200&#x3D;400；</li>\n<li>RAID3-5：3个盘存储，1个盘校验，3<em>200&#x3D;600；</em></li>\n<li><em>RAID6：2个盘存储，2个盘校验，2</em>200&#x3D;400。</li>\n</ul>\n<p><img src=\"/orangefish1118.github.io/orangefish1118.github.io/posts/0/OS%E8%AF%BE%E5%90%8E%E4%BD%9C%E4%B8%9A%E9%A2%98%E7%9B%AE/image-20240510204124736.png\" alt=\"image-20240510204124736\"></p>\n","text":"2024年操作系统期末大题复习材料...","permalink":"/post/OS-课后作业题目","photos":[],"count_time":{"symbolsCount":"4.4k","symbolsTime":"4 mins."},"categories":[{"name":"Study","slug":"Study","count":30,"path":"api/categories/Study.json"}],"tags":[{"name":"学习","slug":"学习","count":20,"path":"api/tags/学习.json"},{"name":"操作系统","slug":"操作系统","count":9,"path":"api/tags/操作系统.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AC%AC%E4%B8%80%E7%AB%A0\"><span class=\"toc-text\">第一章</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AC%AC%E4%BA%8C%E7%AB%A0\"><span class=\"toc-text\">第二章</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AC%AC%E4%B8%89%E7%AB%A0\"><span class=\"toc-text\">第三章</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AC%AC%E5%9B%9B%E7%AB%A0\"><span class=\"toc-text\">第四章</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AC%AC%E4%BA%94%E7%AB%A0\"><span class=\"toc-text\">第五章</span></a></li></ol>","author":{"name":"Fioransh","slug":"blog-author","avatar":"/medias/2.jpg","link":"/","description":"<p> 学而无知，无知而学 <p> <p> Anime is trash and so am I. <p>","socials":{"github":"https://github.com/orangefish1118","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/14481775?spm_id_from=333.1007.0.0"},"gitee":{"icon":"/svg/gitee.svg","link":"https://gitee.com/Orangefish-cyc"},"mail":{"icon":"/svg/email.svg","link":"mailto:1263938020@qq.com"}}}},"mapped":true,"hidden":false,"prev_post":{"title":"OS-虚拟内存","uid":"a8e53f71d8296af4285fe02496a3f129","slug":"OS-虚拟内存","date":"2024-06-04T12:25:12.000Z","updated":"2024-06-19T08:05:32.470Z","comments":true,"path":"api/articles/OS-虚拟内存.json","keywords":"博客、橙汁蒸鱼、Orangefish、Oranfish","cover":"/medias/36.jpg","text":"1.虚拟内存1.1 引入单片机的CPU是直接操作内存的 [物理地址] 此时不能同时在内存运行两个程序，如何解决？ 1.2 操作系统如何解决这个问题问题在于两个程...","permalink":"/post/OS-虚拟内存","photos":[],"count_time":{"symbolsCount":"6.3k","symbolsTime":"6 mins."},"categories":[{"name":"Study","slug":"Study","count":30,"path":"api/categories/Study.json"}],"tags":[{"name":"学习","slug":"学习","count":20,"path":"api/tags/学习.json"},{"name":"操作系统","slug":"操作系统","count":9,"path":"api/tags/操作系统.json"}],"author":{"name":"Fioransh","slug":"blog-author","avatar":"/medias/2.jpg","link":"/","description":"<p> 学而无知，无知而学 <p> <p> Anime is trash and so am I. <p>","socials":{"github":"https://github.com/orangefish1118","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/14481775?spm_id_from=333.1007.0.0"},"gitee":{"icon":"/svg/gitee.svg","link":"https://gitee.com/Orangefish-cyc"},"mail":{"icon":"/svg/email.svg","link":"mailto:1263938020@qq.com"}}}}},"next_post":{"title":"OS-期末简答题复习","uid":"5ace535680a97380947dc34f832b3150","slug":"OS-简答题","date":"2024-05-10T10:25:12.000Z","updated":"2024-06-19T08:01:49.769Z","comments":true,"path":"api/articles/OS-简答题.json","keywords":"博客、橙汁蒸鱼、Orangefish、Oranfish","cover":"/medias/29.jpg","text":"2024年操作系统期末简答题复习材料...","permalink":"/post/OS-简答题","photos":[],"count_time":{"symbolsCount":"2.9k","symbolsTime":"3 mins."},"categories":[{"name":"Study","slug":"Study","count":30,"path":"api/categories/Study.json"}],"tags":[{"name":"学习","slug":"学习","count":20,"path":"api/tags/学习.json"},{"name":"操作系统","slug":"操作系统","count":9,"path":"api/tags/操作系统.json"}],"author":{"name":"Fioransh","slug":"blog-author","avatar":"/medias/2.jpg","link":"/","description":"<p> 学而无知，无知而学 <p> <p> Anime is trash and so am I. <p>","socials":{"github":"https://github.com/orangefish1118","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/14481775?spm_id_from=333.1007.0.0"},"gitee":{"icon":"/svg/gitee.svg","link":"https://gitee.com/Orangefish-cyc"},"mail":{"icon":"/svg/email.svg","link":"mailto:1263938020@qq.com"}}}}}}