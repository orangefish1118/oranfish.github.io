{"title":"软件工程基础复习材料","uid":"e831f129fb6325d4710907008135b5ef","slug":"软基-复习材料","date":"2024-06-19T07:25:12.000Z","updated":"2024-06-19T07:37:44.784Z","comments":true,"path":"api/articles/软基-复习材料.json","keywords":"博客、橙汁蒸鱼、Orangefish、Oranfish","cover":"/medias/25.jpg","content":"<h2 id=\"名词解释题\"><a href=\"#名词解释题\" class=\"headerlink\" title=\"名词解释题\"></a>名词解释题</h2><h3 id=\"1-软件工程\"><a href=\"#1-软件工程\" class=\"headerlink\" title=\"1.软件工程\"></a>1.软件工程</h3><p>将<strong>系统化、规范化、可量化</strong>的方法应用于软件的开发、运行和维护的过程，以及上述方法的研究</p>\n<p><strong>软件工程</strong>是：<br>    ①将系统化的、严格约束的、可量化的方法应用于软件的开发、运行和维护，即将工程化应用于软件；<br>    ②在①中所述方法的研究。</p>\n<h3 id=\"2-软件制品\"><a href=\"#2-软件制品\" class=\"headerlink\" title=\"2.软件制品\"></a>2.软件制品</h3><p>软件过程的每一项活动都需要人员去完成，活动实施需投入必要的成本、资源和工具，活动的完成需要时间，结束之后会产生相应的软件制品。 因此 ，软件过程将软件项目相关的人力、成本、进度、资源、制品、工具等组织在一起，不仅软件项目的实施需要软件过程的指导 ，软件项目的管理也依赖具体的软件过程 ，比如基于软件过程来制订项目实施计划、跟踪计划的开展、估算软件项目的成本等。</p>\n<p>①软件原型②软件用例模型③软件需求文档</p>\n<h3 id=\"3-系统软件\"><a href=\"#3-系统软件\" class=\"headerlink\" title=\"3.系统软件\"></a>3.系统软件</h3><p>系统软件是指<strong>对计算资源进行管理， 为应用软件的运行提供基础服务</strong>的一类软件。</p>\n<h3 id=\"4-支撑软件\"><a href=\"#4-支撑软件\" class=\"headerlink\" title=\"4.支撑软件\"></a>4.支撑软件</h3><p>支撑软件是指用于<strong>辅助软件开发和运维</strong>，帮助软件开发入员完成<strong>软件开发和维护工作</strong>的一类软件。 </p>\n<h3 id=\"5-软件生存周期\"><a href=\"#5-软件生存周期\" class=\"headerlink\" title=\"5.软件生存周期\"></a>5.软件生存周期</h3><p>软件生命周期指一个软件<strong>从提出开发开始，到开发完成交付用户使用，及至最后退役不再使用</strong>的全过程。 </p>\n<h3 id=\"6-需求工程\"><a href=\"#6-需求工程\" class=\"headerlink\" title=\"6.需求工程\"></a>6.需求工程</h3><p>需求工程是指应用工程化的方法、技术和规格来开发和管理软件的需求。</p>\n<p>需求工程旨在用工程的理念和方法来指导软件需求实践。 </p>\n<p>它提供了一系列过程、策略、方法学和工具，帮助需求工程师加强对业务或领域问题及其环境的理解，获取和分析软件需求，指导软件需求的文档化和评审，以尽可能获得准确、一致和完整的软件需求，产生软件需求的相关软件制品。 </p>\n<h3 id=\"7-原型\"><a href=\"#7-原型\" class=\"headerlink\" title=\"7.原型\"></a>7.原型</h3><p>所谓原型 (prototype) ，是指<strong>在产品开发前期所产生的产品雏形或仿真产品</strong>。 相较于实际产品，原型具有可直观展示产品的特性、贴近业务应用、能自然地反映产品需求等特点。</p>\n<h3 id=\"8-强内聚低耦合\"><a href=\"#8-强内聚低耦合\" class=\"headerlink\" title=\"8.强内聚低耦合\"></a>8.强内聚低耦合</h3><p>内聚度是指模块内各成分间彼此结合的紧密程度，耦合度是指不同模块之间的相关程度。 高内聚度、低耦合度的原则要求模块应该设计得每个模块内部内聚度要高，不同模块之间的耦合度要低。 这两项基本原则可以用来有效指导软件模块的设计，确保得到高质量的模块设计。</p>\n<h3 id=\"9-模块化\"><a href=\"#9-模块化\" class=\"headerlink\" title=\"9.模块化\"></a>9.模块化</h3><p>模块化原则是指将软件系统的功能分解和实现为若干个模块，每个模块具有独立的功能，模块之间通过接口进行调用和访问。 </p>\n<h3 id=\"10-信息隐藏原则\"><a href=\"#10-信息隐藏原则\" class=\"headerlink\" title=\"10.信息隐藏原则\"></a>10.信息隐藏原则</h3><p>信息隐藏原则是指模块应该设计为使其所含的信息（如内部语句、变址等）对那些不需要这些信息的模块而言不可访问，模块间仅交换实现系统功能所须交换的信息（如接口）。 </p>\n<h3 id=\"11-系统响应时间\"><a href=\"#11-系统响应时间\" class=\"headerlink\" title=\"11.系统响应时间\"></a>11.系统响应时间</h3><p>系统响应时间指从用户执行某个控制动作（如按回车键或单击鼠标）到软件作出响应（期望的输出或动作）的时间。</p>\n<h3 id=\"12-图形用户界面\"><a href=\"#12-图形用户界面\" class=\"headerlink\" title=\"12.图形用户界面\"></a>12.图形用户界面</h3><p>用户通过键盘和鼠标等方式来操纵图形化界面，向软件输入所需的信息，如点击按钮、选择某项信息等。软件处理完成之后，采用图形化方式向用户现实和反馈处理的结果，如通过窗口、采用图形等形式来显示处理结果。它以图形化方式向用户展示输入、输出信息，如图形、窗口、按钮、对话框、菜单等。这种方式尤其是鼠标极大促进了它的使用，方便了用户操作软件。用户无须记忆各种命令符号，只需点击菜单项或按钮可发出各种命令，通过选择或填写对话框中的各信息输入项就可以完成参数设置。</p>\n<h3 id=\"13-软件测试用例\"><a href=\"#13-软件测试用例\" class=\"headerlink\" title=\"13.软件测试用例\"></a>13.软件测试用例</h3><p>软件测试用例的设计是软件测试的关键，它描述了对程序代码进行测试时所输入的数据以及预期的结果。一般地，一个测试用例是由以下4类元素所构成的，输入数据，前置条件，测试步骤，预期输出。</p>\n<ul>\n<li><p>输入数据。输入数据代表将交由待测试程序代码进行处理的数据，程序代码基于输入数据执行相应的业务逻辑，并产生数据输出。</p>\n</li>\n<li><p>前置条件。当待测试的程序代码对数据进行处理是，如阿坚测试工程师需要明确程序处理输入数据的运行上下文，也即要满足的前置条件。</p>\n</li>\n<li><p>测试步骤。在软件测试的过程中，程序代码对输入数据的处理可能设计一系列步骤，其中某些步骤需要用户的进一步输入。</p>\n</li>\n<li><p>预期输出。根据待测试程序代码的功能及内部执行逻辑，输入不同的数据，程序代码应该有不同的预期输出结果。</p>\n</li>\n</ul>\n<h3 id=\"14-单元测试-集成测试-确认测试\"><a href=\"#14-单元测试-集成测试-确认测试\" class=\"headerlink\" title=\"14.单元测试\\集成测试\\确认测试\"></a>14.单元测试\\集成测试\\确认测试</h3><ul>\n<li><p>单元测试：单元测试依据软件详细设计模型和文档来设计测试用例，它主要对程序单元的接口以及内部执行逻辑进行测试。单元测试通常由程序员完成，一般采用白盒测试技术。</p>\n</li>\n<li><p>集成测试：集成测试是将构成目标软件系统的程序单元进行逐步组装，测试它们的接口和集成是否存在缺陷。软件概要设计模型和文档(如子系统设计模型、软件体系结构设计模型等)是指导集成测试的依据，也即集成测试是要测试程序单元间的接口及其集成是否满足概要设计的相关要求。通常，集成测试在单元测试完成之后，由专门的软件测试工程师来完成，其测试用例可在软件概要设计阶段产生。集成测试通常采用黑盒测试技术。</p>\n</li>\n<li><p>确认测试需要在集成测试完成之后，由专门的软件测试工程师在软件测试阶段来负责完成，其测试用例可在软件需求分析阶段产生。确认测试通常采用黑盒测试技术。</p>\n</li>\n</ul>\n<h3 id=\"15-性能测试\"><a href=\"#15-性能测试\" class=\"headerlink\" title=\"15.性能测试\"></a>15.性能测试</h3><p>性能测试用来测试软件在集成的系统中的性能。性能测试可发生在测试过程的所有步骤中，单元测试时主要测试一个模块的性能，软件的整体性能只有在软件集成后进行，整个计算机系统性能实在计算机系统集成后进行。 </p>\n<h3 id=\"16-安全测试\"><a href=\"#16-安全测试\" class=\"headerlink\" title=\"16.安全测试\"></a>16.安全测试</h3><p>安全性测试借助工具或人工手段来模拟黑客入侵，以发现软件系统中存在的安全隐患，检查软件系统对非法侵入的防范能力。</p>\n<h3 id=\"17-回归测试\"><a href=\"#17-回归测试\" class=\"headerlink\" title=\"17.回归测试\"></a>17.回归测试</h3><p>程序员修复了程序后，还需要对修复后的代码进行回归测试，以判断缺陷和错误是否已经被成功修复，或者在修复代码过程中有没有引入新的缺陷和错误。</p>\n<h3 id=\"18-软件部署\"><a href=\"#18-软件部署\" class=\"headerlink\" title=\"18.软件部署\"></a>18.软件部署</h3><p>软件部署是指将目标软件系统（包括构建、配置文件、用户手册、帮助文档等）进行收集、打包、安装、配置和发布到运行环境的过程。</p>\n<h3 id=\"19-纠正性维护-完善性维护-适应性维护-预防性维护\"><a href=\"#19-纠正性维护-完善性维护-适应性维护-预防性维护\" class=\"headerlink\" title=\"19.纠正性维护\\完善性维护\\适应性维护\\预防性维护\"></a>19.纠正性维护\\完善性维护\\适应性维护\\预防性维护</h3><ul>\n<li><p>纠正性维护：纠正性维护是指为修复和纠正软件中缺陷而开展的维护活动。</p>\n</li>\n<li><p>改善性维护：改善型维护是指对软件进行改造以增加新的功能、修改已有的功能等维护活动。</p>\n</li>\n<li><p>适应性维护：适应性维护是指为实用软件运行环境变化而对软件进行的维护活动。</p>\n</li>\n<li><p>预防性维护：预防性维护是指对软件结构进行改造，一边提高软件的可靠性和可维护性而进行的维护活动。</p>\n</li>\n</ul>\n<h3 id=\"20-软件演化\"><a href=\"#20-软件演化\" class=\"headerlink\" title=\"20.软件演化\"></a>20.软件演化</h3><p>软件演化是指针对软件的大规模功能增强和结构调整，以实现变化的软件需求或者提高软件系统的质量。</p>\n<h2 id=\"简答题\"><a href=\"#简答题\" class=\"headerlink\" title=\"简答题\"></a>简答题</h2><h3 id=\"1-什么是开源软件，和其他闭源软件相比，有什么优势和不足？\"><a href=\"#1-什么是开源软件，和其他闭源软件相比，有什么优势和不足？\" class=\"headerlink\" title=\"1.什么是开源软件，和其他闭源软件相比，有什么优势和不足？\"></a>1.什么是开源软件，和其他闭源软件相比，有什么优势和不足？</h3><p>开源软件是一种源代码可以自由获取和传播的计算机软件，其拥有者通过开源许可证赋予被许可人对软件进行使用、修改和传播的权利。开源软件采用群体化的思想和理念，代表了一种新的软件开发方法 。</p>\n<ul>\n<li><p>优势：</p>\n<ul>\n<li>采购和开发成本更低</li>\n<li>软件质量更高、更安全</li>\n<li>软件研制和交付更快</li>\n<li>软件功能更全面、更具创新性</li>\n</ul>\n</li>\n<li><p>不足：</p>\n<ul>\n<li>安装开源软件有时需要更多的技术经验，比如要有配置或编译源代码的能力。</li>\n<li>开源软件许可协议一般会包含类似的规定，说明作者对用户使用该软件所产生的任何问题不承担责任。由开源软件引发的损失由谁负责是个问题。</li>\n<li>引入或使用开源软件，发现缺陷有谁来维护也是问题，特别是原作者已经不在维护了。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-什么是软件过程模型？请列举2个进行介绍\"><a href=\"#2-什么是软件过程模型？请列举2个进行介绍\" class=\"headerlink\" title=\"2.什么是软件过程模型？请列举2个进行介绍\"></a>2.什么是软件过程模型？请列举2个进行介绍</h3><p>它又称软件开发模型，是软件开发技术活动和管理活动的结构框架，刻画活动间的不同次序，反映对软件开发的理解和认识，展示软件开发理念和思想。</p>\n<ul>\n<li><p>瀑布模型：瀑布模型将软件开发过程分为若干步骤和活动，包括需求分析、软件设计、编码实现、软件测试和运行维护。这些步骤严格按照先后次序和逻辑关系来组织实施。需求分析活动完成之后产生了软件需求文档，才能开展软件设计，以此类推。每个阶段的末尾需要对该阶段产生的软件制品（文档、模型和代码等）进行评审，以发现和纠正软件制品中的问题和缺陷，防止有质批问题的软件制品进入下一步骤。评审通过后意味着该阶段的开发任务完成，随后就可以进入下一个阶段的工作 因此，在瀑布模型中上一步骤的输出是下一步骤的输入，下一步骤需等到前一步骤完成之后才能实施。整个软件开发过程的步骤和实施次序与软件生存周期相一致。软件开发过程中的活动被组织为线性形状，类似于瀑布，故而因此得名。</p>\n</li>\n<li><p>增量模型：瀑布模型要等到软件开发后期才能给用户提供可运行的软件系统，这一点往往不利于用户使用。此外，滞后的软件交付和使用必然会导致软件缺陷和问题的滞后发现，加大软件开发的成本和工作队，影响软件质乱出现这一状况的根本原因在于，获取软件需求后瀑布模型要求一次性实现所有的软件需求，这势必会导致软件设计和实现的工作址大、开发周期长，使软件交付延后<br>针对这一问题，增量模型对瀑布模型做了适当改进，它不再要求软件开发人员，一次性实现所有的软件需求，而是在软件需求和总体设计确定好之后，采用增扯开发的模式渐进式地实现软件系统的所有功能，从而确保软件开发人员可以尽早为用户提交可运行的软件系统。增乱模型的另一个显著优点是允许软件开发人员平行地开发软件、实现软件系统的各个独立模块，从而提高软件开发效率，加快交付目标软件系统的进度。</p>\n</li>\n<li><p>增量模型：在软件需求和总体设计确定好之后，采用增量开发的模式渐进式地实现软件系统的所有功能，从而确保软件开发人员可以尽早为用户提交可运行的软件系统。</p>\n</li>\n<li><p>原型模型：在软件开发早期(通常在需求分析阶段)根据用户的初步需求构建软件原型并将其交给用户使用，获得用户的评价和反馈，帮助用户导出软件需求、发现开发人员与用户之间的需求认识偏差，进而有效地支持软件需求分析。这一过程模型即为原型模型。</p>\n</li>\n</ul>\n<h3 id=\"3-什么是计算机辅助软件工程（CASE）-请举例说明典型的CASE工具（至少写出3个）\"><a href=\"#3-什么是计算机辅助软件工程（CASE）-请举例说明典型的CASE工具（至少写出3个）\" class=\"headerlink\" title=\"3.什么是计算机辅助软件工程（CASE）,请举例说明典型的CASE工具（至少写出3个）\"></a>3.什么是计算机辅助软件工程（CASE）,请举例说明典型的CASE工具（至少写出3个）</h3><p>计算机辅助软件工程(computer aided software engineering, CASE)是指借助计算机软件来辅助软件开发、运行、维护和管理的过程。用于支持计算机辅助软件工程的工具称为 CASE 工具。通常每个 CASE 工具提供一个相对独立的功能，辅助软件开发人员完成某项特定的工作。 </p>\n<ul>\n<li>SonarQube 就是一种 CASE 工具，它可辅助软件开发人员完成代码质量分析和评估工作。</li>\n<li>Microsoft Office也可视为 CASE 工具，它可辅助软件开发人员撰写软件文档。</li>\n<li>Eclipse 也是CASE工具，用于代码编写、程序编译、程序调试等等。</li>\n<li>Git也是CASE工具，用于项目管理，团队合作，软件版本管理。</li>\n</ul>\n<h3 id=\"4-软件需求是什么？包含哪些具体内容？\"><a href=\"#4-软件需求是什么？包含哪些具体内容？\" class=\"headerlink\" title=\"4.软件需求是什么？包含哪些具体内容？\"></a>4.软件需求是什么？包含哪些具体内容？</h3><p>可以从软件本身和软件利益相关者两个不同的角度来理解软件需求 (software requirements) 。</p>\n<p>从软件本身的角度，软件需求是指软件用千解决现实世界问题时所表现出的功能和性能等要求；</p>\n<p>从软件利益相关者的角度，软件需求是指软件系统的利益相关者对软件系统的功能和质量，以及软件运行环境、交付进度等方面提出的期望和要求。</p>\n<p>《计算机科学技术名词》将软件需求定义为：为解决用户或客户的问题或实现其目标，软件系统必须具备的能力及必须满足的约束条件。本质上，软件需求刻画了软件系统能够做什么、应表现出怎样的行为、需满足哪些方面的条件和约束等要求。</p>\n<p>软件需求主要表现为三种形式：功能需求、软件质量需求和软件开发约束需求。后两种形式统称为非功能需求。</p>\n<ul>\n<li><p>软件的功能需求描述了软件能做什么、具有什么功能、可提供怎样的服务，刻画了软件在具体场景下所展现的行为及效果。软件的功能需求大多来自软件的用户、客户和开发者群体。 对于一些人机物共生系统而言，目标系统的某些功能需要通过软件加以实现，因而会对软件提出特定的功能要求。</p>\n</li>\n<li><p>软件质量需求是指软件的利益相关者对软件应具有的质蜇属性所提出的具体要求。 软件的质量属性既包括内部质量属性，也包括外部质量属性。 通常而言，软件系统的客户、用户、开发者群体或者与软件发生交互的其他系统都会对软件的外部质量属性提出要求，如运行性能、可靠性 、易用性、安全性 、私密性、可用性、持续性、可信性等。 软件系统的开发者群体还会对软 件系统的内部质扯属性提出要求 ，如软件的可扩展性、 可维护性、可理解性、可重用性 、可移植性有效性等。</p>\n</li>\n<li><p>软件开发约束需求是指软件的利益相关者对软件系统的开发成本、交付进度、技术选型、遵循标准等方面提出的要求。 站在客户或开发者的视角，软件开发是一项工程，需要投入资源和 成本，产品交付需要时间。 为了获益，他们会对软件产品的开发成本和进度提出明确要求。</p>\n</li>\n</ul>\n<h3 id=\"5-写出瀑布模型的特征和不足\"><a href=\"#5-写出瀑布模型的特征和不足\" class=\"headerlink\" title=\"5.写出瀑布模型的特征和不足\"></a>5.写出瀑布模型的特征和不足</h3><p>特征：</p>\n<ul>\n<li>接受上一阶段的结果作为本阶段的输入</li>\n<li>利用这一输入实施本阶段应完成的活动</li>\n<li>对本阶段的工作进行评审</li>\n<li>将本阶段的结果作为输出，传递给下一阶段</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>缺乏灵活性，难以适应需求不明确或需求经常变化的软件开发</li>\n<li>开发早期存在的问题往往要到交付使用时才发现，维护代价大</li>\n</ul>\n<h3 id=\"6-如何选择合适的过程模型\"><a href=\"#6-如何选择合适的过程模型\" class=\"headerlink\" title=\"6.如何选择合适的过程模型\"></a>6.如何选择合适的过程模型</h3><p>在具体的软件开发实践中，软件开发人员和管理人员需根据各个软件过程模型的特点和适用场合，结合所开发软件项目的实际情况和具体要求，合理地选择或制定软件项目的过程模型。</p>\n<ol>\n<li>考虑软件项目的特点：考虑软件项目的特点，尤其是所开发软件的业务特点，如业务领域是否明确、软件需求是否易于确定、用户需求是否会经常变化等。</li>\n<li>考虑软件项目开发的风险：如果在软件项目实施之前就可以预估到该项目可能会面临多样化的软件风险，可以考虑采用螺旋模型等过程模型。</li>\n<li>考虑团队的经验和水平：需要结合软件开发团队的能力和水平来选择过程模型，以防开发团队和管理人员无法掌控和驾驭过程模型。</li>\n</ol>\n<h3 id=\"7-写出需求工程的一般过程\"><a href=\"#7-写出需求工程的一般过程\" class=\"headerlink\" title=\"7.写出需求工程的一般过程\"></a>7.写出需求工程的一般过程</h3><p>需求工程提供了一般性过程，以指导软件需求的获取、分析和文档化。 它包含了若干与需求工程密切相关的活动，明确了每项活动的具体任务以及不同活动间的关系，以帮助需求工程师等循序渐进地开展需求工程。</p>\n<ol>\n<li>获取软件需求：该活动的任务是要获得软件利益相关者对软件的期望和要求，进而获取初步软件需求。</li>\n<li>分析软件需求：该项工作的任务是要在初步软件需求的基础上，对软件需求进行稍化、建模和分析，获得软件需求在功能、行为、特征和约束等方面更为详细的信息，发现并解决软件需求中潜在的问题，产生准确、一致和完整的软件需求及其描述。</li>\n<li>文档化软件需求：该项活动的任务是要在获取和分析软件需求及其成果的基础上．撰写软件需求文档，产生软件需求规格说明书。</li>\n<li>确认和验证软件需求：该项活动的任务是要对前面工作所产生的软件需求模型和文档进行评审，让软件系统的利益相关者确认和验证软件需求，发现其中的问题和存在的缺陷，并加以解决和纠正 ， 确保经评审后的软件需求模型和文档符合利益相关者的诉求并满足质址要求。</li>\n<li>管理软件需求：由于软件需求工程贯穿于整个软件生存周期，软件需求会持续发生变化，并且需求变化会对软件开发和运维产生重要的影响，因此必须对软件需求变化以及相应的软件需求制品进行有效的管理，包括明确和验证软件需求变更、追踪需求变化、分析和评估需求变化所产生的影响、 对变化后的软件需求制品进行配置管理等。</li>\n</ol>\n<h3 id=\"8-获取软件需求的方法有哪些，请列举2个进行介绍\"><a href=\"#8-获取软件需求的方法有哪些，请列举2个进行介绍\" class=\"headerlink\" title=\"8.获取软件需求的方法有哪些，请列举2个进行介绍\"></a>8.获取软件需求的方法有哪些，请列举2个进行介绍</h3><ul>\n<li>从软件系统的用户和客户处导出软件需求：在获取软件需求的过程中，如果在现实世界能够找到软件系统的潜在用户和实际客户，那么需求工程师可以通过与这些用户或客户进行交互，从他们那里导出软件系统的需求。 </li>\n<li>分解其他系统的需求产生软件需求：多软件系统并不是独立存在的，而是作为更大系统的一个组成部分，负责完成整个系统的部分需求。</li>\n<li>重用已有的系统的需求：当开发一个软件系统时，如果类似的软件产品已经存在，需求工程师可通过对已有软件产品的功能和特点进行分析形成待开发软件系统的需求。</li>\n<li>通过软件开发者构思和创作软件需求</li>\n<li>激励互联网开放群体贡献软件需求</li>\n</ul>\n<h3 id=\"9-请简述软件设计的任务\"><a href=\"#9-请简述软件设计的任务\" class=\"headerlink\" title=\"9.请简述软件设计的任务\"></a>9.请简述软件设计的任务</h3><p>软件设计的任务是根据需求工程所定义的软件需求，包括功能需求、质量需求和开发约束需求，遵循软件设计的基本原则，定义构成软件系统的各个设计元素，提供可指导软件实现的解决方案，形成高质量的软件设计模型和文档。</p>\n<h3 id=\"10-写出软件设计的一般过程\"><a href=\"#10-写出软件设计的一般过程\" class=\"headerlink\" title=\"10.写出软件设计的一般过程\"></a>10.写出软件设计的一般过程</h3><p>在软件设计阶段，软件设计工程师需要基千软件需求模型，通过一系列软件设计活动，产生由各种设计元素所表述的软件设计模型，以此来指导程序员编写目标软件系统的代码。 为此，软件设计工程师需要在充分理解软件需求的基础上，有序地开展一系列软件设计工作，产生支持目标软件系统的设计模型和文档。</p>\n<ol>\n<li>体系结构性设计：软件设计首先需要回答软件系统应具有什么样的软件体系结构，也称为软件架构。 </li>\n<li>用户界面设计：用户界面设计就是要明确目标软件系统有哪些用户界面（如窗口和对话框等），这些界面之间的跳转关系（如在一个窗口点击确认后将弹出另一个窗口），每个界面内部的输入输出元素及其布局，包括输入框、按钮、文本显示框、菜单项等。 所有的界面设计元素可由设计类来表示。 </li>\n<li>详细设计：在上述两项软件设计的基础上，软件设计工程师须进一步细化软件设计，所谓的详细设计，顾名思义就是要给出软件系统更为具体的细节性设计，需要详细到足以支待程序员的编码实现。 包括了用例设计、子系统和构件设计、类设计、数据设计。</li>\n<li>文档化软件设计：软件设计工程师需在上述软件设计及其成果的基础上，按照软件设计规格说明书的规范和要求撰写软件设计文档，详细记录软件设计的具体信息，并以此作为与其他人员进行交流和评审的媒介。 </li>\n<li>软件设计评审：软件设计工程师需要组织多方人员一起对软件设计制品进行评审，验证软件设计是否实现 了软件需求，分析软件设计的质址，发现软件设计中存在的缺陷和问题，并与多方人员 一起协商加以解决。</li>\n<li>软件设计管理：由于软件设计在软件生存周期中会发生变化，并且设计变化会对软件的编码、测试和运维产生重要影响，因此必须对软件设计变化以及相应的软件设计制品进行有效的管理，包括追踪软件设计变化、分析和评估软件设计变化所产生的影响、对变化后的软件设计制品进行配置管理等。</li>\n</ol>\n<h3 id=\"11-体系结构结构设计风格有哪些，请列举两个进行介绍\"><a href=\"#11-体系结构结构设计风格有哪些，请列举两个进行介绍\" class=\"headerlink\" title=\"11.体系结构结构设计风格有哪些，请列举两个进行介绍\"></a>11.体系结构结构设计风格有哪些，请列举两个进行介绍</h3><ul>\n<li><p>管道&#x2F;过滤器风格：</p>\n</li>\n<li><p>管道&#x2F;过滤器风格将软件系统的功能实现为一系列处理步骤，每个步骤完成特定的子功能冰凤凰装在一个成为“过滤器”的构建中。响铃过滤器之间以“管道”相连，也即连接件，前一个过滤器的输出数据通过管道流向最后一个过滤器。整个软件系统的输入由数据源提供，它通过管道与某个过滤器项链。软件系统的最终输出由源自某个过滤器的管道流向数据宿，也称数据汇。典型的数据源和数据汇包括数据库、数据文件、其他软件系统、物理设备（如智能手机等）。</p>\n</li>\n<li><p>层次风格：</p>\n</li>\n<li><p>层次风格将软件系统按照抽象级别划分为若干层次,每层由若干抽象级别相同的构件组成,因而整个软件体系结构呈现出层次化的形式(见图8.6)。每层构件仅为紧邻其上的抽象别更高的层次及其构件提供服务,并且它们仅使用紧邻下层及其构件提供的服务。一般而言，处于顶层的构件直接面向用户提供软件系统的交互界面,处于底层的构件则负责提供基础性、公共性的功能和服务。相邻层次间的构件连接通常采用以下两种方式:一种是高层构件向低层构件发出服务请求,低层构件在计算完成后向请求者发送服务应答;另一种是低层构件在主动探测或被动获知计算环境的变化后,以事件的形式通知高层构件。每个层次可以采用两种方式来向上层提供服务接口:一种是层次中每个提供服务的构件对外公开其接口;另一种是将服务接口封装于层次的内部,每个层次提供统一的服务接口。</p>\n</li>\n<li><p>MvC风格：</p>\n</li>\n<li><p>MVC风格将软件系统划分为三类主要的构件:模型(model)、视图(view)和控制器(controller)(见图8.7)。模型构件负责存储业务数据，提供业务逻辑处理功能；视图构件负责向用户展示模型结果；控制器构件在接收模型的业务逻辑处理结果后，负责选择适当的视图作为软件系统对用户的界面动作的响应，它实际上是模型和视图之间的连接桥梁。</p>\n</li>\n</ul>\n<h3 id=\"12-写出用户界面设计的一般过程\"><a href=\"#12-写出用户界面设计的一般过程\" class=\"headerlink\" title=\"12.写出用户界面设计的一般过程\"></a>12.写出用户界面设计的一般过程</h3><p><img src=\"/orangefish1118.github.io/%E8%BD%AF%E5%9F%BA-%E5%A4%8D%E4%B9%A0%E6%9D%90%E6%96%99/image-20240613141327069.png\" alt=\"image-20240613141327069\"></p>\n<h3 id=\"13-编写程序代码时，标识符命名应该注意什么问题（至少写出5条）\"><a href=\"#13-编写程序代码时，标识符命名应该注意什么问题（至少写出5条）\" class=\"headerlink\" title=\"13.编写程序代码时，标识符命名应该注意什么问题（至少写出5条）\"></a>13.编写程序代码时，标识符命名应该注意什么问题（至少写出5条）</h3><p>I. 名字应反映所代表的实体，具有一定实际意义</p>\n<p>II. 选择精炼的意义明确的名字</p>\n<p>III. 不用关键字作标识符</p>\n<p>IV. 同一个名字不要有多个含义</p>\n<p>V. 避免使用容易混淆的字符 </p>\n<h3 id=\"14-写出软件调试的步骤\"><a href=\"#14-写出软件调试的步骤\" class=\"headerlink\" title=\"14.写出软件调试的步骤\"></a>14.写出软件调试的步骤</h3><p><img src=\"/orangefish1118.github.io/%E8%BD%AF%E5%9F%BA-%E5%A4%8D%E4%B9%A0%E6%9D%90%E6%96%99/image-20240613141335825.png\" alt=\"image-20240613141335825\"></p>\n<h3 id=\"15-软件设计的原则有哪些？请列举2个进行介绍\"><a href=\"#15-软件设计的原则有哪些？请列举2个进行介绍\" class=\"headerlink\" title=\"15.软件设计的原则有哪些？请列举2个进行介绍\"></a>15.软件设计的原则有哪些？请列举2个进行介绍</h3><ul>\n<li><p>抽象和逐步求精原则：</p>\n</li>\n<li><p>抽象是指在认识事物、分析和解决问题时，忽略那些与当前研究目标不相关的部分及要以便将注意力集中在与当前目标相关的方面。</p>\n</li>\n<li><p>逐步求精是指在分析问题和解决问题过程中，先建立关于问题及其解的高层次抽象，然后以此为基础，通过精化获得更多的细节，建立问题和系统的低层次抽象。</p>\n</li>\n<li><p>模块化与高内聚度、低耦合度原则：</p>\n</li>\n<li><p>模块化是软件工程的一项基本原则，即在开发软件时将整个软件系统设计为一个个功能单一、接口明确、相对独立的模块单元，并通过这些模块之间的交互来实现软件系统的功能。</p>\n</li>\n<li><p>内聚度是指模块内各成分间彼此结合的紧密程度，耦合度是指不同模块之间的相关程度。高内聚度、低耦合度的原则要求模块应该设计得每个模块内部内聚度要高，不同模块之间的耦合度要低。</p>\n</li>\n<li><p>信息隐藏原则：</p>\n</li>\n<li><p>该原则有助于设计出高质量的软件系统其优点具体表现为以下几个方面。</p>\n</li>\n<li><p>它使模块的独立性更好，其内部尽可能少地受其他模块的影响。</p>\n</li>\n<li><p>由于模块的独立性好，因而有助于模块的并行开发(设计和编码)，提高了软件开发的效率。</p>\n</li>\n<li><p>由于模块内部的信息对外不可访问，因而它可以有效地减少错误向外传播，便于软件测试，提高软件系统的可维护性。</p>\n</li>\n<li><p>便于软件系统增加新的功能，也即新功能的增加可以通过增加相关的模块来完成，而非对已有模块的修改。</p>\n</li>\n<li><p>将模块内部的信息隐藏起来，可以防止对模块内部的不必要访问。一旦软件模块出现问题，可以方便地寻找错误原因和定位错误源头。</p>\n</li>\n<li><p>实际上，现有的软件设计和程序设计技术均在不同程度上支持信息隐藏。</p>\n</li>\n<li><p>多视点及关注点分离原则：</p>\n</li>\n<li><p>一个软件系统的设计包含多个不同的方面，需要从不同的视点对它进行设计。</p>\n</li>\n<li><p>当然，软件设计的不同视点有其各自的独立性和关注点，或者说不同视点所关心的问题以及欲达成的设计目标是不一样的，不可将它们混为一谈。</p>\n</li>\n<li><p>软件重用原则：</p>\n</li>\n<li><p>软件重用是软件工程的一项基本原则，它是指在软件开发过程中要尽可能地重用已有的软件资产来实现软件系统的功能，同时要确保所开发的软件系统易于为其他软件系统所重用。</p>\n</li>\n<li><p>软件工程提供了诸多的****技术手段*<em><strong>来支持软件重用，如封装、继承、信息隐藏、多态等。软件重用的</strong></em>*形式*<em><strong>也从早期基于过程和函数的细粒度重用，逐步过渡到基于类、构件、服务和镜像的粗粒度重用，以及近年来出现的基于开源软件的更大粒度重用。</strong></em>*重用的内容*<em><strong>不仅表现为源代码和可执行程序代码，而且还可以重用</strong></em>*体系结构风格、软件设计模式、软件开发知识*<em><strong>等。软件重用不仅发生在</strong></em>*编码实现阶段*<em><strong>，而且在</strong></em>*需求分析、软件设计、软件测试阶段****也可以进行软件重用。</p>\n</li>\n<li><p>迭代设计原则：</p>\n</li>\n<li><p>根据前面的阐述，软件设计极为复杂，要考虑的问题和因素很多，期望通过一次性设计就达成相关的设计任务是不现实的。软件设计需要经过多次反复迭代才能完成。每次迭代都是在前一次迭代的基础上，对产生的设计模型进行反复权衡、折中、优化等工作，以得到更为合理、高效、高质量的软件设计成果。</p>\n</li>\n<li><p>可追踪性原则：</p>\n</li>\n<li><p>概括而言，软件设计的目的是为软件需求的实现提供解决方案。因此，任何软件设计活动以及由此而产生的设计结果都要服务于特定的软件需求。软件设计应能通过逆向追踪找到其对应的软件需求，或者软件需求可以通过正向追踪找到其对应的设计元素。</p>\n</li>\n<li><p>权衡抉择原则：</p>\n</li>\n<li><p>首先，选择什么样的技术来设计和开发软件，新技术也许会让软件产品及其开发具备一定的技术优势，但是也会由于缺乏足够的实践和检验、未能熟练地掌握等因素而带来相关的技术风险，旧技术虽然老旧，但是成熟，利用它们来开发软件相对而言风险较小。为此，设计工程师需要在新旧技术之间进行合理的权衡抉择。</p>\n</li>\n<li><p>其次，在实现软件需求时，不同软件需求项之间可能存在“负相关”的关系，尤其对于质量需求而言体现得更加明显，也即当增强某些质量需求的同时可能会导致另一些质量需求的变弱。因此，设计工程师需要在不同的设计考虑、不同的设计方案之间进行权衠抉择，以得到符合其要求和关注点的合理设计。</p>\n</li>\n</ul>\n<h3 id=\"16-软件测试的V模型包括哪些步骤？说明这些步骤的测试对象是什么？\"><a href=\"#16-软件测试的V模型包括哪些步骤？说明这些步骤的测试对象是什么？\" class=\"headerlink\" title=\"16.软件测试的V模型包括哪些步骤？说明这些步骤的测试对象是什么？\"></a>16.软件测试的V模型包括哪些步骤？说明这些步骤的测试对象是什么？</h3><p><img src=\"/orangefish1118.github.io/%E8%BD%AF%E5%9F%BA-%E5%A4%8D%E4%B9%A0%E6%9D%90%E6%96%99/image-20240613141350487.png\" alt=\"image-20240613141350487\"></p>\n<ul>\n<li>单元测试：模块或构件</li>\n<li>集成测试：集成的软件系统</li>\n<li>确认测试：软件需求规约</li>\n<li>系统测试：基于计算机的系统</li>\n<li>测试对象：类方法、类对象、构建、子系统、整个软件系统</li>\n</ul>\n<h3 id=\"17-请解释什么是改善性维护，并举例说明\"><a href=\"#17-请解释什么是改善性维护，并举例说明\" class=\"headerlink\" title=\"17.请解释什么是改善性维护，并举例说明\"></a>17.请解释什么是改善性维护，并举例说明</h3><p>改善性维护是指对软件进行改造以增加新的功能、修改已有的功能等维护活动。例如，“12306”软件投入使用之后，用户希望该软件能够提供车票改签、退票等功能，为此软件维护团队需要基于这些新需求，对软件进行改善性维护。</p>\n<h3 id=\"18-为提高程序的可理解性，有哪些主要的注意事项？请至少写出3条\"><a href=\"#18-为提高程序的可理解性，有哪些主要的注意事项？请至少写出3条\" class=\"headerlink\" title=\"18.为提高程序的可理解性，有哪些主要的注意事项？请至少写出3条\"></a>18.为提高程序的可理解性，有哪些主要的注意事项？请至少写出3条</h3><p>1）易读，一看就懂</p>\n<p>2）易改，便于维护</p>\n<p>3）降低代码复杂度</p>\n<p>4）尽可能开展软件重用和编写可重用的程序代码</p>\n<p>5）要能处理异常和提高代码的容错性</p>\n<p>6）代码要与模型和文档相一致</p>\n<p>7）格式化代码的布局。尽可能使其清晰、明了</p>\n<p>8）进可能提供简单的代码，不要人为地增加代码的复杂度</p>\n<p>9）对代码辅之以适当的文档，以加强程序的理解</p>\n<p>10）加强程序代码的结构化组织，提高代码的可读性</p>\n<h3 id=\"19-什么是模块化？软件设计时，模块是否应该划分越多越好？为什么？\"><a href=\"#19-什么是模块化？软件设计时，模块是否应该划分越多越好？为什么？\" class=\"headerlink\" title=\"19.什么是模块化？软件设计时，模块是否应该划分越多越好？为什么？\"></a>19.什么是模块化？软件设计时，模块是否应该划分越多越好？为什么？</h3><p>模块化原则是指将软件系统的功能分解和实现为若干个模块，每个模块具有独立的功能，模块之间通过接口进行调用和访问。每个模块内部的要素(如语句、变量等)与模块的功能相关，且相互间关系密切，即模块内部高内聚；每个模块独立性强，模块间的关系松散，即模块间松耦合。</p>\n<p>不是模块分得越细越好、得到的模块个数越多越好。虽然单个模块的复杂性有所降低，但是模块个数多了，组装（或集成）模块得到整个软件的复杂性和代价会增加的。其实划分每个模块的大小和得到的模块个数实际上有个合理的范围，在这个范围内复杂性和代价相对比较合理。</p>\n<h3 id=\"20-写出测试策略（测试的V模型）中的四种测试和它们的任务\"><a href=\"#20-写出测试策略（测试的V模型）中的四种测试和它们的任务\" class=\"headerlink\" title=\"20.写出测试策略（测试的V模型）中的四种测试和它们的任务\"></a>20.写出测试策略（测试的V模型）中的四种测试和它们的任务</h3><ul>\n<li>单元测试：程序单元的接口测试、局部数据的接口测试、执行路径的接口测试、错误处理路径测试。</li>\n<li>集成测试：自顶向下集成测试、自底向上集成测试。</li>\n<li>确认测试：针对整个软件系统进行确认测试，以测试目标软件系统是否满足软件需求文档所定义的各项软件需求。</li>\n<li>系统测试：一旦软件系统通过了确认测试之后，它还要与相关的其他系统进行集成，以进行系统测试，发现软件系统与其他系统交互过程中是否存在缺陷。</li>\n</ul>\n","feature":true,"text":"2024年软件工程基础期末复习材料...","permalink":"/post/软基-复习材料","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[{"name":"Study","slug":"Study","count":30,"path":"api/categories/Study.json"}],"tags":[{"name":"学习","slug":"学习","count":20,"path":"api/tags/学习.json"},{"name":"软件工程基础","slug":"软件工程基础","count":1,"path":"api/tags/软件工程基础.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A%E9%A2%98\"><span class=\"toc-text\">名词解释题</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B\"><span class=\"toc-text\">1.软件工程</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E8%BD%AF%E4%BB%B6%E5%88%B6%E5%93%81\"><span class=\"toc-text\">2.软件制品</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6\"><span class=\"toc-text\">3.系统软件</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-%E6%94%AF%E6%92%91%E8%BD%AF%E4%BB%B6\"><span class=\"toc-text\">4.支撑软件</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-%E8%BD%AF%E4%BB%B6%E7%94%9F%E5%AD%98%E5%91%A8%E6%9C%9F\"><span class=\"toc-text\">5.软件生存周期</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-%E9%9C%80%E6%B1%82%E5%B7%A5%E7%A8%8B\"><span class=\"toc-text\">6.需求工程</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-%E5%8E%9F%E5%9E%8B\"><span class=\"toc-text\">7.原型</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#8-%E5%BC%BA%E5%86%85%E8%81%9A%E4%BD%8E%E8%80%A6%E5%90%88\"><span class=\"toc-text\">8.强内聚低耦合</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#9-%E6%A8%A1%E5%9D%97%E5%8C%96\"><span class=\"toc-text\">9.模块化</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#10-%E4%BF%A1%E6%81%AF%E9%9A%90%E8%97%8F%E5%8E%9F%E5%88%99\"><span class=\"toc-text\">10.信息隐藏原则</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#11-%E7%B3%BB%E7%BB%9F%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4\"><span class=\"toc-text\">11.系统响应时间</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#12-%E5%9B%BE%E5%BD%A2%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2\"><span class=\"toc-text\">12.图形用户界面</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#13-%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B\"><span class=\"toc-text\">13.软件测试用例</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#14-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95-%E7%A1%AE%E8%AE%A4%E6%B5%8B%E8%AF%95\"><span class=\"toc-text\">14.单元测试\\集成测试\\确认测试</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#15-%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95\"><span class=\"toc-text\">15.性能测试</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#16-%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95\"><span class=\"toc-text\">16.安全测试</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#17-%E5%9B%9E%E5%BD%92%E6%B5%8B%E8%AF%95\"><span class=\"toc-text\">17.回归测试</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#18-%E8%BD%AF%E4%BB%B6%E9%83%A8%E7%BD%B2\"><span class=\"toc-text\">18.软件部署</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#19-%E7%BA%A0%E6%AD%A3%E6%80%A7%E7%BB%B4%E6%8A%A4-%E5%AE%8C%E5%96%84%E6%80%A7%E7%BB%B4%E6%8A%A4-%E9%80%82%E5%BA%94%E6%80%A7%E7%BB%B4%E6%8A%A4-%E9%A2%84%E9%98%B2%E6%80%A7%E7%BB%B4%E6%8A%A4\"><span class=\"toc-text\">19.纠正性维护\\完善性维护\\适应性维护\\预防性维护</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#20-%E8%BD%AF%E4%BB%B6%E6%BC%94%E5%8C%96\"><span class=\"toc-text\">20.软件演化</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AE%80%E7%AD%94%E9%A2%98\"><span class=\"toc-text\">简答题</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E4%BB%80%E4%B9%88%E6%98%AF%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6%EF%BC%8C%E5%92%8C%E5%85%B6%E4%BB%96%E9%97%AD%E6%BA%90%E8%BD%AF%E4%BB%B6%E7%9B%B8%E6%AF%94%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E5%8A%BF%E5%92%8C%E4%B8%8D%E8%B6%B3%EF%BC%9F\"><span class=\"toc-text\">1.什么是开源软件，和其他闭源软件相比，有什么优势和不足？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E4%BB%80%E4%B9%88%E6%98%AF%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B%E6%A8%A1%E5%9E%8B%EF%BC%9F%E8%AF%B7%E5%88%97%E4%B8%BE2%E4%B8%AA%E8%BF%9B%E8%A1%8C%E4%BB%8B%E7%BB%8D\"><span class=\"toc-text\">2.什么是软件过程模型？请列举2个进行介绍</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E4%BB%80%E4%B9%88%E6%98%AF%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BE%85%E5%8A%A9%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%EF%BC%88CASE%EF%BC%89-%E8%AF%B7%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E%E5%85%B8%E5%9E%8B%E7%9A%84CASE%E5%B7%A5%E5%85%B7%EF%BC%88%E8%87%B3%E5%B0%91%E5%86%99%E5%87%BA3%E4%B8%AA%EF%BC%89\"><span class=\"toc-text\">3.什么是计算机辅助软件工程（CASE）,请举例说明典型的CASE工具（至少写出3个）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%8C%85%E5%90%AB%E5%93%AA%E4%BA%9B%E5%85%B7%E4%BD%93%E5%86%85%E5%AE%B9%EF%BC%9F\"><span class=\"toc-text\">4.软件需求是什么？包含哪些具体内容？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-%E5%86%99%E5%87%BA%E7%80%91%E5%B8%83%E6%A8%A1%E5%9E%8B%E7%9A%84%E7%89%B9%E5%BE%81%E5%92%8C%E4%B8%8D%E8%B6%B3\"><span class=\"toc-text\">5.写出瀑布模型的特征和不足</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E8%BF%87%E7%A8%8B%E6%A8%A1%E5%9E%8B\"><span class=\"toc-text\">6.如何选择合适的过程模型</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-%E5%86%99%E5%87%BA%E9%9C%80%E6%B1%82%E5%B7%A5%E7%A8%8B%E7%9A%84%E4%B8%80%E8%88%AC%E8%BF%87%E7%A8%8B\"><span class=\"toc-text\">7.写出需求工程的一般过程</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#8-%E8%8E%B7%E5%8F%96%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82%E7%9A%84%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%8C%E8%AF%B7%E5%88%97%E4%B8%BE2%E4%B8%AA%E8%BF%9B%E8%A1%8C%E4%BB%8B%E7%BB%8D\"><span class=\"toc-text\">8.获取软件需求的方法有哪些，请列举2个进行介绍</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#9-%E8%AF%B7%E7%AE%80%E8%BF%B0%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E7%9A%84%E4%BB%BB%E5%8A%A1\"><span class=\"toc-text\">9.请简述软件设计的任务</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#10-%E5%86%99%E5%87%BA%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E7%9A%84%E4%B8%80%E8%88%AC%E8%BF%87%E7%A8%8B\"><span class=\"toc-text\">10.写出软件设计的一般过程</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#11-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E9%A3%8E%E6%A0%BC%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%8C%E8%AF%B7%E5%88%97%E4%B8%BE%E4%B8%A4%E4%B8%AA%E8%BF%9B%E8%A1%8C%E4%BB%8B%E7%BB%8D\"><span class=\"toc-text\">11.体系结构结构设计风格有哪些，请列举两个进行介绍</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#12-%E5%86%99%E5%87%BA%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2%E8%AE%BE%E8%AE%A1%E7%9A%84%E4%B8%80%E8%88%AC%E8%BF%87%E7%A8%8B\"><span class=\"toc-text\">12.写出用户界面设计的一般过程</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#13-%E7%BC%96%E5%86%99%E7%A8%8B%E5%BA%8F%E4%BB%A3%E7%A0%81%E6%97%B6%EF%BC%8C%E6%A0%87%E8%AF%86%E7%AC%A6%E5%91%BD%E5%90%8D%E5%BA%94%E8%AF%A5%E6%B3%A8%E6%84%8F%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%88%E8%87%B3%E5%B0%91%E5%86%99%E5%87%BA5%E6%9D%A1%EF%BC%89\"><span class=\"toc-text\">13.编写程序代码时，标识符命名应该注意什么问题（至少写出5条）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#14-%E5%86%99%E5%87%BA%E8%BD%AF%E4%BB%B6%E8%B0%83%E8%AF%95%E7%9A%84%E6%AD%A5%E9%AA%A4\"><span class=\"toc-text\">14.写出软件调试的步骤</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#15-%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%8E%9F%E5%88%99%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E8%AF%B7%E5%88%97%E4%B8%BE2%E4%B8%AA%E8%BF%9B%E8%A1%8C%E4%BB%8B%E7%BB%8D\"><span class=\"toc-text\">15.软件设计的原则有哪些？请列举2个进行介绍</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#16-%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%9A%84V%E6%A8%A1%E5%9E%8B%E5%8C%85%E6%8B%AC%E5%93%AA%E4%BA%9B%E6%AD%A5%E9%AA%A4%EF%BC%9F%E8%AF%B4%E6%98%8E%E8%BF%99%E4%BA%9B%E6%AD%A5%E9%AA%A4%E7%9A%84%E6%B5%8B%E8%AF%95%E5%AF%B9%E8%B1%A1%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F\"><span class=\"toc-text\">16.软件测试的V模型包括哪些步骤？说明这些步骤的测试对象是什么？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#17-%E8%AF%B7%E8%A7%A3%E9%87%8A%E4%BB%80%E4%B9%88%E6%98%AF%E6%94%B9%E5%96%84%E6%80%A7%E7%BB%B4%E6%8A%A4%EF%BC%8C%E5%B9%B6%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E\"><span class=\"toc-text\">17.请解释什么是改善性维护，并举例说明</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#18-%E4%B8%BA%E6%8F%90%E9%AB%98%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8F%AF%E7%90%86%E8%A7%A3%E6%80%A7%EF%BC%8C%E6%9C%89%E5%93%AA%E4%BA%9B%E4%B8%BB%E8%A6%81%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%EF%BC%9F%E8%AF%B7%E8%87%B3%E5%B0%91%E5%86%99%E5%87%BA3%E6%9D%A1\"><span class=\"toc-text\">18.为提高程序的可理解性，有哪些主要的注意事项？请至少写出3条</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#19-%E4%BB%80%E4%B9%88%E6%98%AF%E6%A8%A1%E5%9D%97%E5%8C%96%EF%BC%9F%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%97%B6%EF%BC%8C%E6%A8%A1%E5%9D%97%E6%98%AF%E5%90%A6%E5%BA%94%E8%AF%A5%E5%88%92%E5%88%86%E8%B6%8A%E5%A4%9A%E8%B6%8A%E5%A5%BD%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F\"><span class=\"toc-text\">19.什么是模块化？软件设计时，模块是否应该划分越多越好？为什么？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#20-%E5%86%99%E5%87%BA%E6%B5%8B%E8%AF%95%E7%AD%96%E7%95%A5%EF%BC%88%E6%B5%8B%E8%AF%95%E7%9A%84V%E6%A8%A1%E5%9E%8B%EF%BC%89%E4%B8%AD%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%B5%8B%E8%AF%95%E5%92%8C%E5%AE%83%E4%BB%AC%E7%9A%84%E4%BB%BB%E5%8A%A1\"><span class=\"toc-text\">20.写出测试策略（测试的V模型）中的四种测试和它们的任务</span></a></li></ol></li></ol>","author":{"name":"Fioransh","slug":"blog-author","avatar":"/medias/2.jpg","link":"/","description":"<p> 学而无知，无知而学 <p> <p> Anime is trash and so am I. <p>","socials":{"github":"https://github.com/orangefish1118","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/14481775?spm_id_from=333.1007.0.0"},"gitee":{"icon":"/svg/gitee.svg","link":"https://gitee.com/Orangefish-cyc"},"mail":{"icon":"/svg/email.svg","link":"mailto:1263938020@qq.com"}}}},"mapped":true,"hidden":false,"prev_post":{},"next_post":{"title":"Hexo+gitee博客搭建流程","uid":"8844fd48687a754eafe1c7b3d89d9e8e","slug":"hexo博客创建教程","date":"2024-01-25T09:42:12.000Z","updated":"2024-02-07T13:29:30.201Z","comments":true,"path":"api/articles/hexo博客创建教程.json","keywords":"博客、橙汁蒸鱼、Orangefish、Oranfish","cover":"/medias/10.jpg","text":"基于Hexo博客框架开发的个人博客流程...","permalink":"/post/hexo博客创建教程","photos":[],"count_time":{"symbolsCount":"3.2k","symbolsTime":"3 mins."},"categories":[{"name":"Blog","slug":"Blog","count":2,"path":"api/categories/Blog.json"}],"tags":[{"name":"学习","slug":"学习","count":20,"path":"api/tags/学习.json"},{"name":"博客搭建","slug":"博客搭建","count":1,"path":"api/tags/博客搭建.json"}],"author":{"name":"Fioransh","slug":"blog-author","avatar":"/medias/2.jpg","link":"/","description":"<p> 学而无知，无知而学 <p> <p> Anime is trash and so am I. <p>","socials":{"github":"https://github.com/orangefish1118","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/14481775?spm_id_from=333.1007.0.0"},"gitee":{"icon":"/svg/gitee.svg","link":"https://gitee.com/Orangefish-cyc"},"mail":{"icon":"/svg/email.svg","link":"mailto:1263938020@qq.com"}}}},"feature":true}}