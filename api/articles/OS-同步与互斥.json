{"title":"OS-同步与互斥","uid":"ab980e069c750cd15253a6b530b876d9","slug":"OS-同步与互斥","date":"2024-06-09T05:25:12.000Z","updated":"2024-06-19T08:04:42.743Z","comments":true,"path":"api/articles/OS-同步与互斥.json","keywords":"博客、橙汁蒸鱼、Orangefish、Oranfish","cover":"/medias/34.jpg","content":"<h2 id=\"1-竞争与合作\"><a href=\"#1-竞争与合作\" class=\"headerlink\" title=\"1.竞争与合作\"></a>1.竞争与合作</h2><h3 id=\"1-1-入门\"><a href=\"#1-1-入门\" class=\"headerlink\" title=\"1.1 入门\"></a>1.1 入门</h3><p>在单核 CPU 系统里，为了实现多个程序同时运行的假象，操作系统通常以时间片调度的方式，让每个进程执行每次执行一个时间片，时间片用完了，就切换下一个进程运行，由于这个时间片的时间很短，于是就造成了「并发」的现象。</p>\n<p>另外，操作系统也为每个进程创建巨大、私有的虚拟内存的假象，这种地址空间的抽象让每个程序好像拥有自己的内存，而实际上操作系统在背后秘密地让多个地址空间「复用」物理内存或者磁盘。</p>\n<p>如果一个程序只有一个执行流程，也代表它是单线程的。当然一个程序可以有多个执行流程，也就是所谓的多线程程序，线程是调度的基本单位，进程则是资源分配的基本单位。</p>\n<p>所以，线程之间是可以共享进程的资源，比如代码段、堆空间、数据段、打开的文件等资源，但每个线程都有自己独立的栈空间。</p>\n<p>那么问题就来了，多个线程如果竞争共享资源，如果不采取有效的措施，则会造成共享数据的混乱。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><img src=\"/oranfish.github.io/oranfish.github.io/posts/0/9-%E6%B1%87%E7%BC%96%E8%AF%AD%E5%8F%A5-%E8%B5%8B%E5%80%BC%E8%BF%87%E7%A8%8B-%E7%AB%9E%E4%BA%89.jpg\" alt=\"蓝色表示线程 1 ，红色表示线程 2\" style=\"zoom:50%;\"></blockquote>\n<h3 id=\"1-2-互斥的概念\"><a href=\"#1-2-互斥的概念\" class=\"headerlink\" title=\"1.2 互斥的概念\"></a>1.2 互斥的概念</h3><p>上面展示的情况称为<strong>竞争条件（*race condition*）</strong>，当多线程相互竞争操作共享变量时，由于运气不好，即在执行过程中发生了上下文切换，我们得到了错误的结果，事实上，每次运行都可能得到不同的结果，因此输出的结果存在<strong>不确定性（*indeterminate*）</strong>。</p>\n<p>由于多线程执行操作共享变量的这段代码可能会导致竞争状态，因此我们将此段代码称为<strong>临界区（*critical section*），它是访问共享资源的代码片段，一定不能给多线程同时执行。</strong></p>\n<p>我们希望这段代码是<strong>互斥（*mutualexclusion*）的，也就说保证一个线程在临界区执行时，其他线程应该被阻止进入临界区</strong>，说白了，就是这段代码执行过程中，最多只能出现一个线程。</p>\n<p>互斥也并不是只针对多线程。在多进程竞争共享资源的时候，也同样是可以使用互斥的方式来避免资源竞争造成的资源混乱。</p>\n<p>互斥解决了并发进程&#x2F;线程对临界区的使用问题。这种基于临界区控制的交互作用是比较简单的，只要一个进程&#x2F;线程进入了临界区，其他试图想进入临界区的进程&#x2F;线程都会被阻塞着，直到第一个进程&#x2F;线程离开了临界区。</p>\n<h3 id=\"1-3-同步的概念\"><a href=\"#1-3-同步的概念\" class=\"headerlink\" title=\"1.3 同步的概念\"></a>1.3 同步的概念</h3><p><strong>所谓同步，就是并发进程&#x2F;线程在一些关键点上可能需要互相等待与互通消息，这种相互制约的等待与互通信息称为进程&#x2F;线程同步</strong>。</p>\n<p>例子，线程 1 是负责读入数据的，而线程 2 是负责处理数据的，这两个线程是相互合作、相互依赖的。线程 2 在没有收到线程 1 的唤醒通知时，就会一直阻塞等待，当线程 1 读完数据需要把数据传给线程 2 时，线程 1 会唤醒线程 2，并把数据交给线程 2 处理。</p>\n<p>注意，同步与互斥是两种不同的概念：</p>\n<ul>\n<li>同步就好比：「操作 A 应在操作 B 之前执行」，「操作 C 必须在操作 A 和操作 B 都完成之后才能执行」等；</li>\n<li>互斥就好比：「操作 A 和操作 B 不能在同一时刻执行」；</li>\n</ul>\n<h2 id=\"2-互斥与同步的实现与使用\"><a href=\"#2-互斥与同步的实现与使用\" class=\"headerlink\" title=\"2.互斥与同步的实现与使用\"></a>2.互斥与同步的实现与使用</h2><p>在进程&#x2F;线程并发执行的过程中，进程&#x2F;线程之间存在协作的关系，例如有互斥、同步的关系。</p>\n<p>为了实现进程&#x2F;线程间正确的协作，操作系统必须提供实现进程协作的措施和方法，主要的方法有两种：</p>\n<ul>\n<li><em>锁</em>：加锁、解锁操作；</li>\n<li><em>信号量</em>：P、V 操作；</li>\n</ul>\n<p>这两个都可以方便地实现进程&#x2F;线程互斥，而信号量比锁的功能更强一些，它还可以方便地实现进程&#x2F;线程同步。</p>\n<h3 id=\"2-1-锁\"><a href=\"#2-1-锁\" class=\"headerlink\" title=\"2.1 锁\"></a>2.1 锁</h3><p>使用加锁操作和解锁操作可以解决并发线程&#x2F;进程的互斥问题。</p>\n<p>任何想进入临界区的线程，必须先执行加锁操作。若加锁操作顺利通过，则线程可进入临界区；在完成对临界资源的访问后再执行解锁操作，以释放该临界资源。</p>\n<p>根据锁的实现不同，可以分为<strong>「忙等待锁」</strong>和<strong>「无忙等待锁」</strong>。</p>\n<h4 id=\"2-1-1-忙等待锁\"><a href=\"#2-1-1-忙等待锁\" class=\"headerlink\" title=\"2.1.1 忙等待锁\"></a>2.1.1 忙等待锁</h4><p>在说明「忙等待锁」的实现之前，先介绍现代 CPU 体系结构提供的特殊<strong>原子操作指令 —— 测试和置位（*Test-and-Set*）指令</strong>。</p>\n<p>如果用 C 代码表示 Test-and-Set 指令，形式如下：</p>\n<p><img src=\"/oranfish.github.io/oranfish.github.io/posts/0/OS-%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/13-TestAndSet.jpg\" alt=\"img\"></p>\n<p>测试并设置指令做了下述事情:</p>\n<ul>\n<li>把 <code>old_ptr</code> 更新为 <code>new</code> 的新值</li>\n<li>返回 <code>old_ptr</code> 的旧值；</li>\n</ul>\n<p>当然，<strong>关键是这些代码是原子执行</strong>。因为既可以测试旧值，又可以设置新值，所以我们把这条指令叫作「测试并设置」。</p>\n<p>那什么是原子操作呢？<strong>原子操作就是要么全部执行，要么都不执行，不能出现执行到一半的中间状态</strong></p>\n<p>我们可以运用 Test-and-Set 指令来实现「忙等待锁」，代码如下：</p>\n<p><img src=\"/oranfish.github.io/oranfish.github.io/posts/0/OS-%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/14-%E8%87%AA%E6%97%8B%E9%94%81.jpg\" alt=\"img\"></p>\n<p>我们来确保理解为什么这个锁能工作：</p>\n<ul>\n<li>第一个场景是，首先假设一个线程在运行，调用 <code>lock()</code>，没有其他线程持有锁，所以 <code>flag</code> 是 0。当调用 <code>TestAndSet(flag, 1)</code> 方法，返回 0，线程会跳出 while 循环，获取锁。同时也会原子的设置 flag 为1，标志锁已经被持有。当线程离开临界区，调用 <code>unlock()</code> 将 <code>flag</code> 清理为 0。</li>\n<li>第二种场景是，当某一个线程已经持有锁（即 <code>flag</code> 为1）。本线程调用 <code>lock()</code>，然后调用 <code>TestAndSet(flag, 1)</code>，这一次返回 1。只要另一个线程一直持有锁，<code>TestAndSet()</code> 会重复返回 1，本线程会一直<strong>忙等</strong>。当 <code>flag</code> 终于被改为 0，本线程会调用 <code>TestAndSet()</code>，返回 0 并且原子地设置为 1，从而获得锁，进入临界区。</li>\n</ul>\n<p>很明显，当获取不到锁时，线程就会一直 while 循环，不做任何事情，所以就被称为「忙等待锁」，也被称为<strong>自旋锁（*spin lock*）</strong>。</p>\n<p>这是最简单的一种锁，一直自旋，利用 CPU 周期，直到锁可用。在单处理器上，需要抢占式的调度器（即不断通过时钟中断一个线程，运行其他线程）。否则，自旋锁在单 CPU 上无法使用，因为一个自旋的线程永远不会放弃 CPU。</p>\n<h4 id=\"2-1-2-无等待锁\"><a href=\"#2-1-2-无等待锁\" class=\"headerlink\" title=\"2.1.2 无等待锁\"></a>2.1.2 无等待锁</h4><p>无等待锁顾明思议就是获取不到锁的时候，不用自旋。</p>\n<p>既然不想自旋，那当没获取到锁的时候，就把当前线程放入到锁的等待队列，然后执行调度程序，把 CPU 让给其他线程执行。</p>\n<img src=\"/oranfish.github.io/oranfish.github.io/posts/0/15-%E6%97%A0%E7%AD%89%E5%BE%85%E9%94%81.jpg\" alt=\"img\" style=\"zoom: 25%;\">\n\n<p>本次只是提出了两种简单锁的实现方式。在具体操作系统实现中，会更复杂，但也离不开本例子两个基本元素。</p>\n<h3 id=\"2-2-信号量\"><a href=\"#2-2-信号量\" class=\"headerlink\" title=\"2.2 信号量\"></a>2.2 信号量</h3><p>信号量是操作系统提供的一种协调共享资源访问的方法。</p>\n<p>通常<strong>信号量表示资源的数量</strong>，对应的变量是一个整型（<code>sem</code>）变量。</p>\n<p>另外，还有<strong>两个原子操作的系统调用函数来控制信号量的</strong>，分别是：</p>\n<ul>\n<li><em>P 操作</em>：将 <code>sem</code> 减 <code>1</code>，相减后，如果 <code>sem &lt; 0</code>，则进程&#x2F;线程进入阻塞等待，否则继续，表明 P 操作可能会阻塞；</li>\n<li><em>V 操作</em>：将 <code>sem</code> 加 <code>1</code>，相加后，如果 <code>sem &lt;= 0</code>，唤醒一个等待中的进程&#x2F;线程，表明 V 操作不会阻塞；</li>\n</ul>\n<p>P 操作是用在进入临界区之前，V 操作是用在离开临界区之后，这两个操作是必须成对出现的。</p>\n<h4 id=\"2-2-1-PV操作如何使用\"><a href=\"#2-2-1-PV操作如何使用\" class=\"headerlink\" title=\"2.2.1 PV操作如何使用\"></a>2.2.1 PV操作如何使用</h4><p>信号量不仅可以实现临界区的互斥访问控制，还可以线程间的事件同步。</p>\n<p>我们先来说说如何使用<strong>信号量实现临界区的互斥访问</strong>。</p>\n<p>为每类共享资源设置一个信号量 <code>s</code>，其初值为 <code>1</code>，表示该临界资源未被占用。</p>\n<p>只要把进入临界区的操作置于 <code>P(s)</code> 和 <code>V(s)</code> 之间，即可实现进程&#x2F;线程互斥。</p>\n<p>此时，任何想进入临界区的线程，必先在互斥信号量上执行 P 操作，在完成对临界资源的访问后再执行 V 操作。由于互斥信号量的初始值为 1，故在第一个线程执行 P 操作后 s 值变为 0，表示临界资源为空闲，可分配给该线程，使之进入临界区。</p>\n<p>若此时又有第二个线程想进入临界区，也应先执行 P 操作，结果使 s 变为负值，这就意味着临界资源已被占用，因此，第二个线程被阻塞。</p>\n<p>并且，直到第一个线程执行 V 操作，释放临界资源而恢复 s 值为 0 后，才唤醒第二个线程，使之进入临界区，待它完成临界资源的访问后，又执行 V 操作，使 s 恢复到初始值 1。</p>\n<p>对于两个并发线程，互斥信号量的值仅取 1、0 和 -1 三个值，分别表示：</p>\n<ul>\n<li>如果互斥信号量为 1，表示没有线程进入临界区；</li>\n<li>如果互斥信号量为 0，表示有一个线程进入临界区；</li>\n<li>如果互斥信号量为 -1，表示一个线程进入临界区，另一个线程等待进入。</li>\n</ul>\n<p>通过互斥信号量的方式，就能保证临界区任何时刻只有一个线程在执行，就达到了互斥的效果。</p>\n<p><strong>信号量实现事件同步</strong>。同步的方式是设置一个信号量，其初值为 <code>0</code>。</p>\n<h3 id=\"2-3-生产者-消费者问题\"><a href=\"#2-3-生产者-消费者问题\" class=\"headerlink\" title=\"2.3 生产者-消费者问题\"></a>2.3 生产者-消费者问题</h3><img src=\"/oranfish.github.io/oranfish.github.io/posts/0/20-%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85.jpg\" alt=\"生产者-消费者模型\" style=\"zoom:33%;\">\n\n<p>生产者-消费者问题描述：</p>\n<ul>\n<li><strong>生产者</strong>在生成数据后，放在一个缓冲区中；</li>\n<li><strong>消费者</strong>从缓冲区取出数据处理；</li>\n<li>任何时刻，<strong>只能有一个</strong>生产者或消费者可以访问缓冲区；</li>\n</ul>\n<p>我们对问题分析可以得出：</p>\n<ul>\n<li>任何时刻只能有一个线程操作缓冲区，说明操作缓冲区是临界代码，<strong>需要互斥</strong>；</li>\n<li>缓冲区空时，消费者必须等待生产者生成数据；缓冲区满时，生产者必须等待消费者取出数据。说明生产者和消费者<strong>需要同步</strong>。</li>\n</ul>\n<p>那么我们需要三个信号量，分别是：</p>\n<ul>\n<li>互斥信号量 <code>mutex</code>：用于互斥访问缓冲区，初始化值为 1；</li>\n<li>资源信号量 <code>fullBuffers</code>：用于消费者询问缓冲区是否有数据，有数据则读取数据，初始化值为 0（表明缓冲区一开始为空）；</li>\n<li>资源信号量 <code>emptyBuffers</code>：用于生产者询问缓冲区是否有空位，有空位则生成数据，初始化值为 n （缓冲区大小）；</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>具体的实现代码：</p>\n<img src=\"/oranfish.github.io/oranfish.github.io/posts/0/21-%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B.jpg\" alt=\"img\" style=\"zoom:15%;\">\n\n<p>如果消费者线程一开始执行 <code>P(fullBuffers)</code>，由于信号量 <code>fullBuffers</code> 初始值为 0，则此时 <code>fullBuffers</code> 的值从 0 变为 -1，说明缓冲区里没有数据，消费者只能等待。</p>\n<p>接着，轮到生产者执行 <code>P(emptyBuffers)</code>，表示减少 1 个空槽，如果当前没有其他生产者线程在临界区执行代码，那么该生产者线程就可以把数据放到缓冲区，放完后，执行 <code>V(fullBuffers)</code> ，信号量 <code>fullBuffers</code> 从 -1 变成 0，表明有「消费者」线程正在阻塞等待数据，于是阻塞等待的消费者线程会被唤醒。</p>\n<p>消费者线程被唤醒后，如果此时没有其他消费者线程在读数据，那么就可以直接进入临界区，从缓冲区读取数据。最后，离开临界区后，把空槽的个数 + 1。</p></blockquote>\n<h2 id=\"3-经典同步问题\"><a href=\"#3-经典同步问题\" class=\"headerlink\" title=\"3.经典同步问题\"></a>3.经典同步问题</h2><h3 id=\"3-1-哲学家就餐问题\"><a href=\"#3-1-哲学家就餐问题\" class=\"headerlink\" title=\"3.1 哲学家就餐问题\"></a>3.1 哲学家就餐问题</h3><p>哲学家就餐的问题描述：</p>\n<ul>\n<li><code>5</code> 个老大哥哲学家，闲着没事做，围绕着一张圆桌吃面；</li>\n<li>巧就巧在，这个桌子只有 <code>5</code> 支叉子，每两个哲学家之间放一支叉子；</li>\n<li>哲学家围在一起先思考，思考中途饿了就会想进餐；</li>\n<li><strong>奇葩的是，这些哲学家要两支叉子才愿意吃面，也就是需要拿到左右两边的叉子才进餐</strong>；</li>\n<li><strong>吃完后，会把两支叉子放回原处，继续思考</strong>；</li>\n</ul>\n<img src=\"/oranfish.github.io/oranfish.github.io/posts/0/23-%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90%E6%A8%A1%E5%9E%8B.jpg\" alt=\"哲学家就餐的问题\" style=\"zoom:25%;\">\n\n<h4 id=\"3-1-1-方案一\"><a href=\"#3-1-1-方案一\" class=\"headerlink\" title=\"3.1.1 方案一\"></a>3.1.1 方案一</h4><p>我们用信号量的方式，也就是 PV 操作来尝试解决它</p>\n<img src=\"/oranfish.github.io/oranfish.github.io/posts/0/24-%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90-%E6%96%B9%E6%A1%88%E4%B8%80%E7%A4%BA%E4%BE%8B.jpg\" alt=\"img\" style=\"zoom:33%;\">\n\n<p>拿起叉子用 P 操作，代表有叉子就直接用，没有叉子时就等待其他哲学家放回叉子。</p>\n<p>不过，这种解法存在一个极端的问题：<strong>假设五位哲学家同时拿起左边的叉子，桌面上就没有叉子了， 这样就没有人能够拿到他们右边的叉子，也就说每一位哲学家都会在 <code>P(fork[(i + 1) % N ])</code> 这条语句阻塞了，很明显这发生了死锁的现象</strong>。</p>\n<h4 id=\"3-1-2-方案二\"><a href=\"#3-1-2-方案二\" class=\"headerlink\" title=\"3.1.2 方案二\"></a>3.1.2 方案二</h4><p>既然「方案一」会发生同时竞争左边叉子导致死锁的现象，那么我们就在拿叉子前，加个互斥信号量，代码如下：</p>\n<img src=\"/oranfish.github.io/oranfish.github.io/posts/0/26-%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90-%E6%96%B9%E6%A1%88%E4%BA%8C%E7%A4%BA%E4%BE%8B.jpg\" alt=\"img\" style=\"zoom:33%;\">\n\n<p>上面程序中的互斥信号量的作用就在于，<strong>只要有一个哲学家进入了「临界区」，也就是准备要拿叉子时，其他哲学家都不能动，只有这位哲学家用完叉子了，才能轮到下一个哲学家进餐。</strong></p>\n<p>方案二虽然能让哲学家们按顺序吃饭，但是每次进餐只能有一位哲学家，而桌面上是有 5 把叉子，按道理是能可以有两个哲学家同时进餐的，所以从效率角度上，这不是最好的解决方案。</p>\n<h4 id=\"3-1-3-方案三\"><a href=\"#3-1-3-方案三\" class=\"headerlink\" title=\"3.1.3 方案三\"></a>3.1.3 方案三</h4><p>那既然方案二使用互斥信号量，会导致只能允许一个哲学家就餐，那么我们就不用它。</p>\n<p>另外，方案一的问题在于，会出现所有哲学家同时拿左边刀叉的可能性，那我们就避免哲学家可以同时拿左边的刀叉，采用分支结构，根据哲学家的编号的不同，而采取不同的动作。</p>\n<p><strong>即让偶数编号的哲学家「先拿左边的叉子后拿右边的叉子」，奇数编号的哲学家「先拿右边的叉子后拿左边的叉子」。</strong></p>\n<img src=\"/oranfish.github.io/oranfish.github.io/posts/0/28-%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90-%E6%96%B9%E6%A1%88%E4%B8%89%E7%A4%BA%E4%BE%8B.jpg\" alt=\"img\" style=\"zoom:33%;\">\n\n<p>上面的程序，在 P 操作时，根据哲学家的编号不同，拿起左右两边叉子的顺序不同。另外，V 操作是不需要分支的，因为 V 操作是不会阻塞的。</p>\n<p>方案三即不会出现死锁，也可以两人同时进餐。</p>\n<h4 id=\"3-1-4-方案四\"><a href=\"#3-1-4-方案四\" class=\"headerlink\" title=\"3.1.4 方案四\"></a>3.1.4 方案四</h4><p>在这里再提出另外一种可行的解决方案，我们<strong>用一个数组 state 来记录每一位哲学家的三个状态，分别是在进餐状态、思考状态、饥饿状态（正在试图拿叉子）。</strong></p>\n<p>那么，<strong>一个哲学家只有在两个邻居都没有进餐时，才可以进入进餐状态。</strong></p>\n<p>第 <code>i</code> 个哲学家的左邻右舍，则由宏 <code>LEFT</code> 和 <code>RIGHT</code> 定义：</p>\n<ul>\n<li><em>LEFT</em> : ( i + 5 - 1 ) % 5</li>\n<li><em>RIGHT</em> : ( i + 1 ) % 5</li>\n</ul>\n<p>比如 i 为 2，则 <code>LEFT</code> 为 1，<code>RIGHT</code> 为 3。</p>\n<p>具体代码实现如下：</p>\n<img src=\"/oranfish.github.io/oranfish.github.io/posts/0/30-%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90-%E6%96%B9%E6%A1%88%E5%9B%9B%E7%A4%BA%E4%BE%8B.jpg\" alt=\"img\" style=\"zoom:33%;\">\n\n<p>上面的程序使用了一个信号量数组，每个信号量对应一位哲学家，这样在所需的叉子被占用时，想进餐的哲学家就被阻塞。</p>\n<p>注意，每个进程&#x2F;线程将 <code>smart_person</code> 函数作为主代码运行，而其他 <code>take_forks</code>、<code>put_forks</code> 和 <code>test</code> 只是普通的函数，而非单独的进程&#x2F;线程。</p>\n<p>方案四同样不会出现死锁，也可以两人同时进餐。</p>\n<h3 id=\"3-2-读者-写者问题\"><a href=\"#3-2-读者-写者问题\" class=\"headerlink\" title=\"3.2 读者-写者问题\"></a>3.2 读者-写者问题</h3><p>前面的「哲学家进餐问题」对于互斥访问有限的竞争问题（如 I&#x2F;O 设备）一类的建模过程十分有用。</p>\n<p>另外，还有个著名的问题是「读者-写者」，它为数据库访问建立了一个模型。</p>\n<p>读者只会读取数据，不会修改数据，而写者即可以读也可以修改数据。</p>\n<p>读者-写者的问题描述：</p>\n<ul>\n<li>「读-读」允许：同一时刻，允许多个读者同时读</li>\n<li>「读-写」互斥：没有写者时读者才能读，没有读者时写者才能写</li>\n<li>「写-写」互斥：没有其他写者时，写者才能写</li>\n</ul>\n<h4 id=\"3-2-1-方案一\"><a href=\"#3-2-1-方案一\" class=\"headerlink\" title=\"3.2.1 方案一\"></a>3.2.1 方案一</h4><p>使用信号量的方式来尝试解决：</p>\n<ul>\n<li>信号量 <code>wMutex</code>：控制写操作的互斥信号量，初始值为 1 ；</li>\n<li>读者计数 <code>rCount</code>：正在进行读操作的读者个数，初始化为 0；</li>\n<li>信号量 <code>rCountMutex</code>：控制对 rCount 读者计数器的互斥修改，初始值为 1；</li>\n</ul>\n<p>接下来看看代码的实现：</p>\n<img src=\"/oranfish.github.io/oranfish.github.io/posts/0/32-%E8%AF%BB%E8%80%85%E5%86%99%E8%80%85-%E6%96%B9%E6%A1%88%E4%B8%80%E7%A4%BA%E4%BE%8B.jpg\" alt=\"img\" style=\"zoom:25%;\">\n\n<p>上面的这种实现，是读者优先的策略，因为只要有读者正在读的状态，后来的读者都可以直接进入，如果读者持续不断进入，则写者会处于饥饿状态。</p>\n<h4 id=\"3-2-2-方案二\"><a href=\"#3-2-2-方案二\" class=\"headerlink\" title=\"3.2.2 方案二\"></a>3.2.2 方案二</h4><p>那既然有读者优先策略，自然也有写者优先策略：</p>\n<ul>\n<li>只要有写者准备要写入，写者应尽快执行写操作，后来的读者就必须阻塞；</li>\n<li>如果有写者持续不断写入，则读者就处于饥饿；</li>\n</ul>\n<p>在方案一的基础上新增如下变量：</p>\n<ul>\n<li>信号量 <code>rMutex</code>：控制读者进入的互斥信号量，初始值为 1；</li>\n<li>信号量 <code>wDataMutex</code>：控制写者写操作的互斥信号量，初始值为 1；</li>\n<li>写者计数 <code>wCount</code>：记录写者数量，初始值为 0；</li>\n<li>信号量 <code>wCountMutex</code>：控制 wCount 互斥修改，初始值为 1；</li>\n</ul>\n<p>具体实现如下代码：</p>\n<img src=\"/oranfish.github.io/oranfish.github.io/posts/0/33-%E8%AF%BB%E8%80%85%E5%86%99%E8%80%85-%E6%96%B9%E6%A1%88%E4%BA%8C%E7%A4%BA%E4%BE%8B.jpg\" alt=\"img\" style=\"zoom: 25%;\">\n\n<p>注意，这里 <code>rMutex</code> 的作用，开始有多个读者读数据，它们全部进入读者队列，此时来了一个写者，执行了 <code>P(rMutex)</code> 之后，后续的读者由于阻塞在 <code>rMutex</code> 上，都不能再进入读者队列，而写者到来，则可以全部进入写者队列，因此保证了写者优先。</p>\n<p>同时，第一个写者执行了 <code>P(rMutex)</code> 之后，也不能马上开始写，必须等到所有进入读者队列的读者都执行完读操作，通过 <code>V(wDataMutex)</code> 唤醒写者的写操作。</p>\n<h4 id=\"3-2-3-方案三\"><a href=\"#3-2-3-方案三\" class=\"headerlink\" title=\"3.2.3 方案三\"></a>3.2.3 方案三</h4><p>既然读者优先策略和写者优先策略都会造成饥饿的现象，那么我们就来实现一下公平策略。</p>\n<p>公平策略：</p>\n<ul>\n<li>优先级相同；</li>\n<li>写者、读者互斥访问；</li>\n<li>只能一个写者访问临界区；</li>\n<li>可以有多个读者同时访问临界资源；</li>\n</ul>\n<p>具体代码实现：</p>\n<img src=\"/oranfish.github.io/oranfish.github.io/posts/0/34-%E8%AF%BB%E8%80%85%E5%86%99%E8%80%85-%E6%96%B9%E6%A1%88%E4%B8%89%E7%A4%BA%E4%BE%8B.jpg\" alt=\"img\" style=\"zoom:25%;\">\n\n<p>看完代码不知你是否有这样的疑问，为什么加了一个信号量 <code>flag</code>，就实现了公平竞争？</p>\n<p>对比方案一的读者优先策略，可以发现，读者优先中只要后续有读者到达，读者就可以进入读者队列， 而写者必须等待，直到没有读者到达。</p>\n<p>没有读者到达会导致读者队列为空，即 <code>rCount==0</code>，此时写者才可以进入临界区执行写操作。</p>\n<p>而这里 <code>flag</code> 的作用就是阻止读者的这种特殊权限（特殊权限是只要读者到达，就可以进入读者队列）。</p>\n<p>比如：开始来了一些读者读数据，它们全部进入读者队列，此时来了一个写者，执行 <code>P(falg)</code> 操作，使得后续到来的读者都阻塞在 <code>flag</code> 上，不能进入读者队列，这会使得读者队列逐渐为空，即 <code>rCount</code> 减为 0。</p>\n<p>这个写者也不能立马开始写（因为此时读者队列不为空），会阻塞在信号量 <code>wDataMutex</code> 上，读者队列中的读者全部读取结束后，最后一个读者进程执行 <code>V(wDataMutex)</code>，唤醒刚才的写者，写者则继续开始进行写操作。</p>\n","text":"1.竞争与合作1.1 入门在单核 CPU 系统里，为了实现多个程序同时运行的假象，操作系统通常以时间片调度的方式，让每个进程执行每次执行一个时间片，时间片用完了...","permalink":"/post/OS-同步与互斥","photos":[],"count_time":{"symbolsCount":"6.9k","symbolsTime":"6 mins."},"categories":[{"name":"Study","slug":"Study","count":30,"path":"api/categories/Study.json"}],"tags":[{"name":"学习","slug":"学习","count":20,"path":"api/tags/学习.json"},{"name":"操作系统","slug":"操作系统","count":9,"path":"api/tags/操作系统.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E7%AB%9E%E4%BA%89%E4%B8%8E%E5%90%88%E4%BD%9C\"><span class=\"toc-text\">1.竞争与合作</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-1-%E5%85%A5%E9%97%A8\"><span class=\"toc-text\">1.1 入门</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-2-%E4%BA%92%E6%96%A5%E7%9A%84%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">1.2 互斥的概念</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-3-%E5%90%8C%E6%AD%A5%E7%9A%84%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">1.3 同步的概念</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E4%BA%92%E6%96%A5%E4%B8%8E%E5%90%8C%E6%AD%A5%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B8%8E%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">2.互斥与同步的实现与使用</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-1-%E9%94%81\"><span class=\"toc-text\">2.1 锁</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-1-1-%E5%BF%99%E7%AD%89%E5%BE%85%E9%94%81\"><span class=\"toc-text\">2.1.1 忙等待锁</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-1-2-%E6%97%A0%E7%AD%89%E5%BE%85%E9%94%81\"><span class=\"toc-text\">2.1.2 无等待锁</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-2-%E4%BF%A1%E5%8F%B7%E9%87%8F\"><span class=\"toc-text\">2.2 信号量</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-2-1-PV%E6%93%8D%E4%BD%9C%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">2.2.1 PV操作如何使用</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-3-%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">2.3 生产者-消费者问题</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-%E7%BB%8F%E5%85%B8%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">3.经典同步问题</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-1-%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%B0%B1%E9%A4%90%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">3.1 哲学家就餐问题</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-1-1-%E6%96%B9%E6%A1%88%E4%B8%80\"><span class=\"toc-text\">3.1.1 方案一</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-1-2-%E6%96%B9%E6%A1%88%E4%BA%8C\"><span class=\"toc-text\">3.1.2 方案二</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-1-3-%E6%96%B9%E6%A1%88%E4%B8%89\"><span class=\"toc-text\">3.1.3 方案三</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-1-4-%E6%96%B9%E6%A1%88%E5%9B%9B\"><span class=\"toc-text\">3.1.4 方案四</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-2-%E8%AF%BB%E8%80%85-%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">3.2 读者-写者问题</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-2-1-%E6%96%B9%E6%A1%88%E4%B8%80\"><span class=\"toc-text\">3.2.1 方案一</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-2-2-%E6%96%B9%E6%A1%88%E4%BA%8C\"><span class=\"toc-text\">3.2.2 方案二</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-2-3-%E6%96%B9%E6%A1%88%E4%B8%89\"><span class=\"toc-text\">3.2.3 方案三</span></a></li></ol></li></ol></li></ol>","author":{"name":"Fioransh","slug":"blog-author","avatar":"/medias/2.jpg","link":"/","description":"<p> 学而无知，无知而学 <p> <p> Anime is trash and so am I. <p>","socials":{"github":"https://github.com/orangefish1118","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/14481775?spm_id_from=333.1007.0.0"},"gitee":{"icon":"/svg/gitee.svg","link":"https://gitee.com/Orangefish-cyc"},"mail":{"icon":"/svg/email.svg","link":"mailto:1263938020@qq.com"}}}},"mapped":true,"hidden":false,"prev_post":{"title":"OS-死锁","uid":"89874e71a8d4fa3b3317f544a3a17f4e","slug":"OS-死锁","date":"2024-06-09T07:25:12.000Z","updated":"2024-06-19T08:04:20.639Z","comments":true,"path":"api/articles/OS-死锁.json","keywords":"博客、橙汁蒸鱼、Orangefish、Oranfish","cover":"/medias/33.jpg","text":"1.死锁的概念在多线程编程中，我们为了防止多线程竞争共享资源而导致数据错乱，都会在操作共享资源之前加上互斥锁，只有成功获得到锁的线程，才能操作共享资源，获取不到...","permalink":"/post/OS-死锁","photos":[],"count_time":{"symbolsCount":"13k","symbolsTime":"12 mins."},"categories":[{"name":"Study","slug":"Study","count":30,"path":"api/categories/Study.json"}],"tags":[{"name":"学习","slug":"学习","count":20,"path":"api/tags/学习.json"},{"name":"操作系统","slug":"操作系统","count":9,"path":"api/tags/操作系统.json"}],"author":{"name":"Fioransh","slug":"blog-author","avatar":"/medias/2.jpg","link":"/","description":"<p> 学而无知，无知而学 <p> <p> Anime is trash and so am I. <p>","socials":{"github":"https://github.com/orangefish1118","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/14481775?spm_id_from=333.1007.0.0"},"gitee":{"icon":"/svg/gitee.svg","link":"https://gitee.com/Orangefish-cyc"},"mail":{"icon":"/svg/email.svg","link":"mailto:1263938020@qq.com"}}}}},"next_post":{"title":"OS-进程通信方式","uid":"6c3d1454bbe7a724ef7580b6eaa23896","slug":"OS-进程通信方式","date":"2024-06-08T13:25:12.000Z","updated":"2024-06-19T08:02:21.214Z","comments":true,"path":"api/articles/OS-进程通信方式.json","keywords":"博客、橙汁蒸鱼、Orangefish、Oranfish","cover":"/medias/30.jpg","text":"1.管道1.1 基础介绍每个进程的用户地址空间都是独立的，一般而言是不能互相访问的，但内核空间是每个进程都共享的，所以进程之间要通信必须通过内核。Linux 内...","permalink":"/post/OS-进程通信方式","photos":[],"count_time":{"symbolsCount":"9.1k","symbolsTime":"8 mins."},"categories":[{"name":"Study","slug":"Study","count":30,"path":"api/categories/Study.json"}],"tags":[{"name":"学习","slug":"学习","count":20,"path":"api/tags/学习.json"},{"name":"操作系统","slug":"操作系统","count":9,"path":"api/tags/操作系统.json"}],"author":{"name":"Fioransh","slug":"blog-author","avatar":"/medias/2.jpg","link":"/","description":"<p> 学而无知，无知而学 <p> <p> Anime is trash and so am I. <p>","socials":{"github":"https://github.com/orangefish1118","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/14481775?spm_id_from=333.1007.0.0"},"gitee":{"icon":"/svg/gitee.svg","link":"https://gitee.com/Orangefish-cyc"},"mail":{"icon":"/svg/email.svg","link":"mailto:1263938020@qq.com"}}}}}}