{"title":"OS-虚拟内存","uid":"a8e53f71d8296af4285fe02496a3f129","slug":"OS-虚拟内存","date":"2024-06-04T12:25:12.000Z","updated":"2024-06-19T08:05:32.470Z","comments":true,"path":"api/articles/OS-虚拟内存.json","keywords":"博客、橙汁蒸鱼、Orangefish、Oranfish","cover":"/medias/36.jpg","content":"<h2 id=\"1-虚拟内存\"><a href=\"#1-虚拟内存\" class=\"headerlink\" title=\"1.虚拟内存\"></a>1.虚拟内存</h2><h3 id=\"1-1-引入\"><a href=\"#1-1-引入\" class=\"headerlink\" title=\"1.1 引入\"></a>1.1 引入</h3><p><strong>单片机的CPU是直接操作内存的 [物理地址]</strong></p>\n<p>此时不能同时在内存运行两个程序，如何解决？</p>\n<h3 id=\"1-2-操作系统如何解决这个问题\"><a href=\"#1-2-操作系统如何解决这个问题\" class=\"headerlink\" title=\"1.2 操作系统如何解决这个问题\"></a>1.2 操作系统如何解决这个问题</h3><p>问题在于两个程序都引用了绝对物理地址，要避免。</p>\n<p>因此操作系统把进程所使用的地址隔离开，为每个进程都分配独立的一套**[虚拟地址]**，互不干涉，每个进程都不能访问物理地址。</p>\n<p><strong>操作系统会提供一种机制，将不同进程的虚拟地址和不同内存的物理地址映射起来。</strong></p>\n<p>如果程序要访问虚拟地址的时候，由操作系统转换成不同的物理地址，这样不同的进程运行的时候，写入的是不同的物理地址，这样就不会冲突了。</p>\n<p>于是，这里就引出了两种地址的概念：</p>\n<ul>\n<li>我们程序所使用的内存地址叫做<strong>虚拟内存地址</strong>（<em>Virtual Memory Address</em>）</li>\n<li>实际存在硬件里面的空间地址叫<strong>物理内存地址</strong>（<em>Physical Memory Address</em>）。</li>\n</ul>\n<p>操作系统引入了虚拟内存，进程持有的虚拟地址会通过 CPU 芯片中的内存管理单元（MMU）的映射关系，来转换变成物理地址，然后再通过物理地址访问内存，如下图所示：</p>\n<img src=\"/posts/0/72ab76ba697e470b8ceb14d5fc5688d9.png\" alt=\"img\" style=\"zoom:50%;\">\n\n\n\n<h3 id=\"1-3-OS如何管理虚拟地址和物理地址之间的关系\"><a href=\"#1-3-OS如何管理虚拟地址和物理地址之间的关系\" class=\"headerlink\" title=\"1.3 OS如何管理虚拟地址和物理地址之间的关系\"></a>1.3 OS如何管理虚拟地址和物理地址之间的关系</h3><p>主要通过<strong>内存分段</strong>和<strong>内存分页</strong>来管理。</p>\n<h2 id=\"2-内存分段\"><a href=\"#2-内存分段\" class=\"headerlink\" title=\"2.内存分段\"></a>2.内存分段</h2><p>程序是由若干个逻辑分段组成的，如可由代码分段、数据分段、栈段、堆段组成。<strong>不同的段是有不同的属性的，所以就用分段（*Segmentation*）的形式把这些段分离出来。</strong></p>\n<h3 id=\"2-1-分段机制下，虚拟地址和物理地址如何映射\"><a href=\"#2-1-分段机制下，虚拟地址和物理地址如何映射\" class=\"headerlink\" title=\"2.1 分段机制下，虚拟地址和物理地址如何映射\"></a>2.1 分段机制下，虚拟地址和物理地址如何映射</h3><p>分段机制下的虚拟地址由两部分组成，<strong>段选择因子</strong>和<strong>段内偏移量</strong>。</p>\n<img src=\"/posts/0/a9ed979e2ed8414f9828767592aadc21.png\" alt=\"img\" style=\"zoom: 40%;\">\n\n<p>段选择因子和段内偏移量：</p>\n<ul>\n<li><strong>段选择子</strong>就保存在段寄存器里面。段选择子里面最重要的是<strong>段号</strong>，用作段表的索引。<strong>段表</strong>里面保存的是这个<strong>段的基地址、段的界限和特权等级</strong>等。</li>\n<li>虚拟地址中的<strong>段内偏移量</strong>应该位于 0 和段界限之间，如果段内偏移量是合法的，就将段基地址加上段内偏移量得到物理内存地址。</li>\n</ul>\n<p>在上面，知道了虚拟地址是通过<strong>段表</strong>与物理地址进行映射的，分段机制会把程序的虚拟地址分成 4 个段，每个段在段表中有一个项，在这一项找到段的基地址，再加上偏移量，于是就能找到物理内存中的地址。</p>\n<p><img src=\"/posts/0/c5e2ab63e6ee4c8db575f3c7c9c85962.png\" alt=\"img\"></p>\n<p>如果要访问段 3 中偏移量 500 的虚拟地址，我们可以计算出物理地址为，段 3 基地址 7000 + 偏移量 500 &#x3D; 7500。</p>\n<p>分段的办法很好，解决了程序本身不需要关心具体的物理内存地址的问题，但它也有一些不足之处：</p>\n<ul>\n<li>第一个就是<strong>内存碎片</strong>的问题。</li>\n<li>第二个就是<strong>内存交换的效率低</strong>的问题。</li>\n</ul>\n<h3 id=\"2-2-分段产生内存碎片问题\"><a href=\"#2-2-分段产生内存碎片问题\" class=\"headerlink\" title=\"2.2 分段产生内存碎片问题\"></a>2.2 分段产生内存碎片问题</h3><p>如图</p>\n<p><img src=\"/posts/0/6142bc3c917e4a6298bdb62936e0d332.png\" alt=\"img\"></p>\n<h3 id=\"2-3-内存分段会出现内存碎片吗\"><a href=\"#2-3-内存分段会出现内存碎片吗\" class=\"headerlink\" title=\"2.3 内存分段会出现内存碎片吗\"></a>2.3 内存分段会出现内存碎片吗</h3><p>内存碎片主要分为，内部内存碎片和外部内存碎片。</p>\n<p>内存分段管理可以做到段根据实际需求分配内存，所以有多少需求就分配多大的段，所以<strong>不会出现内部内存碎片</strong>。</p>\n<p>但是由于每个段的长度不固定，所以多个段未必能恰好使用所有的内存空间，会产生了多个不连续的小物理内存，导致新的程序无法被装载，所以<strong>会出现外部内存碎片</strong>的问题。</p>\n<p>解决「外部内存碎片」的问题就是<strong>内存交换</strong>。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>可以把音乐程序占用的那 256MB 内存写到硬盘上，然后再从硬盘上读回来到内存里。不过再读回的时候，我们不能装载回原来的位置，而是紧紧跟着那已经被占用了的 512MB 内存后面。这样就能空缺出连续的 256MB 空间，于是新的 200MB 程序就可以装载进来。</p>\n<p>这个内存交换空间，在 Linux 系统里，也就是我们常看到的 Swap 空间，这块空间是从硬盘划分出来的，用于内存与硬盘的空间交换。</p></blockquote>\n<h3 id=\"2-4-分段为什么导致内存交换效率低\"><a href=\"#2-4-分段为什么导致内存交换效率低\" class=\"headerlink\" title=\"2.4 分段为什么导致内存交换效率低\"></a>2.4 分段为什么导致内存交换效率低</h3><p>硬盘的访问速度要比内存慢太多了，每一次内存交换，我们都需要把一大段连续的内存数据写到硬盘上。</p>\n<p><strong>如果内存交换的时候，交换的是一个占内存空间很大的程序，这样整个机器都会显得卡顿。</strong></p>\n<p>为了解决内存分段的「外部内存碎片和内存交换效率低」的问题，就出现了内存分页。</p>\n<h2 id=\"3-内存分页\"><a href=\"#3-内存分页\" class=\"headerlink\" title=\"3.内存分页\"></a>3.内存分页</h2><p>当需要进行内存交换的时候，让需要交换写入或者从磁盘装载的数据更少一点，这样就可以解决问题了。这个办法，也就是<strong>内存分页</strong>（<em>Paging</em>）。</p>\n<p><strong>分页是把整个虚拟和物理内存空间切成一段段固定尺寸的大小</strong>。这样一个连续并且尺寸固定的内存空间，我们叫<strong>页</strong>（<em>Page</em>）。在 Linux 下，每一页的大小为 <code>4KB</code>。</p>\n<p>虚拟地址与物理地址之间通过<strong>页表</strong>来映射，如下图：</p>\n<img src=\"/posts/0/08a8e315fedc4a858060db5cb4a654af.png\" alt=\"img\" style=\"zoom: 50%;\">\n\n<p>页表是存储在内存里的，<strong>内存管理单元</strong> （<em>MMU</em>）就做将虚拟内存地址转换成物理地址的工作。</p>\n<p>而当进程访问的虚拟地址在页表中查不到时，系统会产生一个<strong>缺页异常</strong>，进入系统内核空间分配物理内存、更新进程页表，最后再返回用户空间，恢复进程的运行。</p>\n<h3 id=\"3-1-分页如何解决「外部内存碎片和内存交换效率低」的问题\"><a href=\"#3-1-分页如何解决「外部内存碎片和内存交换效率低」的问题\" class=\"headerlink\" title=\"3.1 分页如何解决「外部内存碎片和内存交换效率低」的问题\"></a>3.1 分页如何解决「外部内存碎片和内存交换效率低」的问题</h3><p>内存分页由于内存空间都是预先划分好的，也就不会像内存分段一样，在段与段之间会产生间隙非常小的内存，这正是分段会产生外部内存碎片的原因。而<strong>采用了分页，页与页之间是紧密排列的，所以不会有外部碎片。</strong></p>\n<p>但是，因为内存分页机制分配内存的最小单位是一页，即使程序不足一页大小，我们最少只能分配一个页，所以页内会出现内存浪费，所以针对<strong>内存分页机制会有内部内存碎片</strong>的现象。</p>\n<p>如果内存空间不够，操作系统会把其他正在运行的进程中的「最近没被使用」的内存页面给释放掉，也就是暂时写在硬盘上，称为<strong>换出</strong>（<em>Swap Out</em>）。一旦需要的时候，再加载进来，称为<strong>换入</strong>（<em>Swap In</em>）。所以，一次性写入磁盘的也只有少数的一个页或者几个页，不会花太多时间，<strong>内存交换的效率就相对比较高。</strong></p>\n<p><img src=\"/posts/0/388a29f45fe947e5a49240e4eff13538-20230309234651917.png\" alt=\"img\"></p>\n<p>更进一步地，分页的方式使得我们在加载程序的时候，不再需要一次性都把程序加载到物理内存中。我们完全可以在进行虚拟内存和物理内存的页之间的映射之后，并不真的把页加载到物理内存里，而是<strong>只有在程序运行中，需要用到对应虚拟内存页里面的指令和数据时，再加载到物理内存里面去。</strong></p>\n<h3 id=\"3-2-分页机制下，虚拟地址和物理地址都是如何映射\"><a href=\"#3-2-分页机制下，虚拟地址和物理地址都是如何映射\" class=\"headerlink\" title=\"3.2 分页机制下，虚拟地址和物理地址都是如何映射\"></a>3.2 分页机制下，虚拟地址和物理地址都是如何映射</h3><p>在分页机制下，虚拟地址分为两部分，<strong>页号</strong>和<strong>页内偏移</strong>。页号作为页表的索引，<strong>页表</strong>包含物理页每页所在<strong>物理内存的基地址</strong>，这个基地址与页内偏移的组合就形成了物理内存地址，见下图。</p>\n<p><img src=\"/posts/0/7884f4d8db4949f7a5bb4bbd0f452609.png\" alt=\"img\"></p>\n<p>总结一下，对于一个内存地址转换，其实就是这样三个步骤：</p>\n<ul>\n<li>把虚拟内存地址，切分成页号和偏移量；</li>\n<li>根据页号，从页表里面，查询对应的物理页号；</li>\n<li>直接拿物理页号，加上前面的偏移量，就得到了物理内存地址。</li>\n</ul>\n<h3 id=\"3-3-简单分页的缺陷\"><a href=\"#3-3-简单分页的缺陷\" class=\"headerlink\" title=\"3.3 简单分页的缺陷\"></a>3.3 简单分页的缺陷</h3><p>有空间上的缺陷。</p>\n<p>因为操作系统是可以同时运行非常多的进程的，那这不就意味着页表会非常的庞大。</p>\n<h3 id=\"3-4-多级页表\"><a href=\"#3-4-多级页表\" class=\"headerlink\" title=\"3.4 多级页表\"></a>3.4 多级页表</h3><p>要解决上面的问题，就需要采用一种叫作<strong>多级页表</strong>（<em>Multi-Level Page Table</em>）的解决方案。</p>\n<img src=\"/posts/0/19296e249b2240c29f9c52be70f611d5.png\" alt=\"img\" style=\"zoom: 33%;\">\n\n\n\n<p><strong>页表一定要覆盖全部虚拟地址空间，不分级的页表就需要有 100 多万个页表项来映射，而二级分页则只需要 1024 个页表项</strong>（此时一级页表覆盖到了全部虚拟地址空间，二级页表在需要时创建）。<strong>如果某个一级页表的页表项没有被用到，也就不需要创建这个页表项对应的二级页表了，即可以在需要时才创建二级页表</strong></p>\n<p>把二级分页再推广到多级页表，就会发现页表占用的内存空间更少了，这一切都要归功于对局部性原理的充分应用。</p>\n<p>对于 64 位的系统，两级分页肯定不够了，就变成了四级目录，分别是：</p>\n<ul>\n<li>全局页目录项 PGD（<em>Page Global Directory</em>）；</li>\n<li>上层页目录项 PUD（<em>Page Upper Directory</em>）；</li>\n<li>中间页目录项 PMD（<em>Page Middle Directory</em>）；</li>\n<li>页表项 PTE（<em>Page Table Entry</em>）；</li>\n</ul>\n<img src=\"/posts/0/%E5%9B%9B%E7%BA%A7%E5%88%86%E9%A1%B5.png\" alt=\"img\" style=\"zoom: 50%;\">\n\n\n\n<h3 id=\"3-5-TLB\"><a href=\"#3-5-TLB\" class=\"headerlink\" title=\"3.5 TLB\"></a>3.5 TLB</h3><p>多级页表虽然解决了空间上的问题，但是虚拟地址到物理地址的转换就多了几道转换的工序，这显然就降低了这俩地址转换的速度，也就是带来了时间上的开销。</p>\n<p>我们就可以利用这一特性，把最常访问的几个页表项存储到访问速度更快的硬件，于是计算机科学家们，就在 CPU 芯片中，加入了一个专门存放程序最常访问的页表项的 Cache，这个 Cache 就是 TLB（<em>Translation Lookaside Buffer</em>） ，通常称为页表缓存、转址旁路缓存、快表等。</p>\n<p>在 CPU 芯片里面，封装了内存管理单元（<em>Memory Management Unit</em>）芯片，它用来完成地址转换和 TLB 的访问与交互。</p>\n<p>有了 TLB 后，那么 CPU 在寻址时，会先查 TLB，如果没找到，才会继续查常规的页表。</p>\n<p>TLB 的命中率其实是很高的，因为程序最常访问的页就那么几个。</p>\n<h2 id=\"4-段页式内存管理\"><a href=\"#4-段页式内存管理\" class=\"headerlink\" title=\"4.段页式内存管理\"></a>4.段页式内存管理</h2><p>内存分段和内存分页并不是对立的，它们是可以组合起来在同一个系统中使用的，那么组合起来后，通常称为<strong>段页式内存管理</strong>。</p>\n<p>段页式内存管理实现的方式：</p>\n<ul>\n<li>先将程序划分为多个有逻辑意义的段，也就是前面提到的分段机制；</li>\n<li>接着再把每个段划分为多个页，也就是对分段划分出来的连续空间，再划分固定大小的页；</li>\n</ul>\n<p>这样，地址结构就由<strong>段号、段内页号和页内位移</strong>三部分组成。</p>\n<p>用于段页式地址变换的数据结构是每一个程序一张段表，每个段又建立一张页表，段表中的地址是页表的起始地址，而页表中的地址则为某页的物理页号</p>\n<p><img src=\"/posts/0/8904fb89ae0c49c4b0f2f7b5a0a7b099.png\" alt=\"img\"></p>\n<p>段页式地址变换中要得到物理地址须经过三次内存访问：</p>\n<ul>\n<li>第一次访问段表，得到页表起始地址；</li>\n<li>第二次访问页表，得到物理页号；</li>\n<li>第三次将物理页号与页内位移组合，得到物理地址。</li>\n</ul>\n<p>可用软、硬件相结合的方法实现段页式地址变换，这样虽然增加了硬件成本和系统开销，但提高了内存的利用率。</p>\n<h2 id=\"5-Linux内存管理\"><a href=\"#5-Linux内存管理\" class=\"headerlink\" title=\"5.Linux内存管理\"></a>5.Linux内存管理</h2><p><strong>页式内存管理的作用是在由段式内存管理所映射而成的地址上再加上一层地址映射。</strong></p>\n<p>由于此时由段式内存管理映射而成的地址不再是“物理地址”了，Intel 就称之为“线性地址”（也称虚拟地址）。于是，段式内存管理先将逻辑地址映射成线性地址，然后再由页式内存管理将线性地址映射成物理地址。</p>\n<p><strong>Linux 内存主要采用的是页式内存管理，但同时也不可避免地涉及了段机制</strong>。</p>\n<p><strong>Linux 系统中的每个段都是从 0 地址开始的整个 4GB 虚拟空间（32 位环境下），也就是所有的段的起始地址都是一样的。这意味着，Linux 系统中的代码，包括操作系统本身的代码和应用程序代码，所面对的地址空间都是线性地址空间（虚拟地址），这种做法相当于屏蔽了处理器中的逻辑地址概念，段只被用于访问控制和内存保护。</strong></p>\n<p>在 Linux 操作系统中，虚拟地址空间的内部又被分为<strong>内核空间和用户空间</strong>两部分，不同位数的系统，地址空间的范围也不同。比如最常见的 32 位和 64 位系统，如下所示：</p>\n<p><img src=\"/posts/0/3a6cb4e3f27241d3b09b4766bb0b1124-20230309234553726.png\" alt=\"img\"></p>\n<p>通过这里可以看出：</p>\n<ul>\n<li><code>32</code> 位系统的内核空间占用 <code>1G</code>，位于最高处，剩下的 <code>3G</code> 是用户空间；</li>\n<li><code>64</code> 位系统的内核空间和用户空间都是 <code>128T</code>，分别占据整个内存空间的最高和最低处，剩下的中间部分是未定义的。</li>\n</ul>\n<p>再来说说，内核空间与用户空间的区别：</p>\n<ul>\n<li>进程在用户态时，只能访问用户空间内存；</li>\n<li>只有进入内核态后，才可以访问内核空间的内存；</li>\n</ul>\n<p>虽然每个进程都各自有独立的虚拟内存，但是<strong>每个虚拟内存中的内核地址，其实关联的都是相同的物理内存</strong>。这样，进程切换到内核态后，就可以很方便地访问内核空间内存。</p>\n<p><img src=\"/posts/0/48403193b7354e618bf336892886bcff.png\" alt=\"img\"></p>\n<p>接下来，进一步了解虚拟空间的划分情况，用户空间和内核空间划分的方式是不同的，内核空间的分布情况就不多说了。</p>\n<p>我们看看用户空间分布的情况，以 32 位系统为例，我画了一张图来表示它们的关系：</p>\n<p><img src=\"/posts/0/32%E4%BD%8D%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.png\" alt=\"虚拟内存空间划分\"></p>\n<p>通过这张图你可以看到，用户空间内存，从<strong>低到高</strong>分别是 6 种不同的内存段：</p>\n<ul>\n<li>代码段，包括二进制可执行代码；</li>\n<li>数据段，包括已初始化的静态常量和全局变量；</li>\n<li>BSS 段，包括未初始化的静态变量和全局变量；</li>\n<li>堆段，包括动态分配的内存，从低地址开始向上增长；</li>\n<li>文件映射段，包括动态库、共享内存等，从低地址开始向上增长（<a href=\"http://lishiwen4.github.io/linux/linux-process-memory-location\">跟硬件和内核版本有关 (opens new window)</a>）；</li>\n<li>栈段，包括局部变量和函数调用的上下文等。栈的大小是固定的，一般是 <code>8 MB</code>。当然系统也提供了参数，以便我们自定义大小；</li>\n</ul>\n<p>上图中的内存布局可以看到，代码段下面还有一段内存空间的（灰色部分），这一块区域是「保留区」，之所以要有保留区这是因为在大多数的系统里，我们认为比较小数值的地址不是一个合法地址，例如，我们通常在 C 的代码里会将无效的指针赋值为 NULL。因此，这里会出现一段不可访问的内存保留区，防止程序因为出现 bug，导致读或写了一些小内存地址的数据，而使得程序跑飞。</p>\n<p>在这 7 个内存段中，堆和文件映射段的内存是动态分配的。比如说，使用 C 标准库的 <code>malloc()</code> 或者 <code>mmap()</code> ，就可以分别在堆和文件映射段动态分配内存。</p>\n<h2 id=\"6-总结\"><a href=\"#6-总结\" class=\"headerlink\" title=\"6.总结\"></a>6.总结</h2><p>为了在多进程环境下，使得进程之间的内存地址不受影响，相互隔离，于是操作系统就为每个进程独立分配一套<strong>虚拟地址空间</strong>，每个程序只关心自己的虚拟地址就可以，实际上大家的虚拟地址都是一样的，但分布到物理地址内存是不一样的。作为程序，也不用关心物理地址的事情。</p>\n<p>每个进程都有自己的虚拟空间，而物理内存只有一个，所以当启用了大量的进程，物理内存必然会很紧张，于是操作系统会通过<strong>内存交换</strong>技术，把不常使用的内存暂时存放到硬盘（换出），在需要的时候再装载回物理内存（换入）。</p>\n<p>那既然有了虚拟地址空间，那必然要把虚拟地址「映射」到物理地址，这个事情通常由操作系统来维护。</p>\n<p>那么对于虚拟地址与物理地址的映射关系，可以有<strong>分段</strong>和<strong>分页</strong>的方式，同时两者结合都是可以的。</p>\n<p>内存分段是根据程序的逻辑角度，分成了栈段、堆段、数据段、代码段等，这样可以分离出不同属性的段，同时是一块连续的空间。但是每个段的大小都不是统一的，这就会导致外部内存碎片和内存交换效率低的问题。</p>\n<p>于是，就出现了内存分页，把虚拟空间和物理空间分成大小固定的页，如在 Linux 系统中，每一页的大小为 <code>4KB</code>。由于分了页后，就不会产生细小的内存碎片，解决了内存分段的外部内存碎片问题。同时在内存交换的时候，写入硬盘也就一个页或几个页，这就大大提高了内存交换的效率。</p>\n<p>再来，为了解决简单分页产生的页表过大的问题，就有了<strong>多级页表</strong>，它解决了空间上的问题，但这就会导致 CPU 在寻址的过程中，需要有很多层表参与，加大了时间上的开销。于是根据程序的<strong>局部性原理</strong>，在 CPU 芯片中加入了 <strong>TLB</strong>，负责缓存最近常被访问的页表项，大大提高了地址的转换速度。</p>\n<p><strong>Linux 系统主要采用了分页管理，但是由于 Intel 处理器的发展史，Linux 系统无法避免分段管理</strong>。于是 Linux 就把所有段的基地址设为 <code>0</code>，也就意味着所有程序的地址空间都是线性地址空间（虚拟地址），相当于屏蔽了 CPU 逻辑地址的概念，所以段只被用于访问控制和内存保护。</p>\n<p>另外，Linux 系统中虚拟空间分布可分为<strong>用户态</strong>和<strong>内核态</strong>两部分，其中用户态的分布：代码段、全局变量、BSS、函数栈、堆内存、映射区。</p>\n<h3 id=\"6-1-虚拟内存有什么作用\"><a href=\"#6-1-虚拟内存有什么作用\" class=\"headerlink\" title=\"6.1 虚拟内存有什么作用\"></a>6.1 虚拟内存有什么作用</h3><ul>\n<li>第一，虚拟内存可以使得进程对运行内存超过物理内存大小，因为程序运行符合局部性原理，CPU 访问内存会有很明显的重复访问的倾向性，对于那些没有被经常使用到的内存，我们可以把它换出到物理内存之外，比如硬盘上的 swap 区域。</li>\n<li>第二，由于每个进程都有自己的页表，所以每个进程的虚拟内存空间就是相互独立的。进程也没有办法访问其他进程的页表，所以这些页表是私有的，这就解决了多进程之间地址冲突的问题。</li>\n<li>第三，页表里的页表项中除了物理地址之外，还有一些标记属性的比特，比如控制一个页的读写权限，标记该页是否存在等。在内存访问方面，操作系统提供了更好的安全性。</li>\n</ul>\n","text":"1.虚拟内存1.1 引入单片机的CPU是直接操作内存的 [物理地址] 此时不能同时在内存运行两个程序，如何解决？ 1.2 操作系统如何解决这个问题问题在于两个程...","permalink":"/post/OS-虚拟内存","photos":[],"count_time":{"symbolsCount":"6.3k","symbolsTime":"6 mins."},"categories":[{"name":"Study","slug":"Study","count":30,"path":"api/categories/Study.json"}],"tags":[{"name":"学习","slug":"学习","count":20,"path":"api/tags/学习.json"},{"name":"操作系统","slug":"操作系统","count":9,"path":"api/tags/操作系统.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98\"><span class=\"toc-text\">1.虚拟内存</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-1-%E5%BC%95%E5%85%A5\"><span class=\"toc-text\">1.1 引入</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-2-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%BF%99%E4%B8%AA%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">1.2 操作系统如何解决这个问题</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-3-OS%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E5%92%8C%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB\"><span class=\"toc-text\">1.3 OS如何管理虚拟地址和物理地址之间的关系</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E5%86%85%E5%AD%98%E5%88%86%E6%AE%B5\"><span class=\"toc-text\">2.内存分段</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-1-%E5%88%86%E6%AE%B5%E6%9C%BA%E5%88%B6%E4%B8%8B%EF%BC%8C%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E5%92%8C%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E5%A6%82%E4%BD%95%E6%98%A0%E5%B0%84\"><span class=\"toc-text\">2.1 分段机制下，虚拟地址和物理地址如何映射</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-2-%E5%88%86%E6%AE%B5%E4%BA%A7%E7%94%9F%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">2.2 分段产生内存碎片问题</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-3-%E5%86%85%E5%AD%98%E5%88%86%E6%AE%B5%E4%BC%9A%E5%87%BA%E7%8E%B0%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87%E5%90%97\"><span class=\"toc-text\">2.3 内存分段会出现内存碎片吗</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-4-%E5%88%86%E6%AE%B5%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AF%BC%E8%87%B4%E5%86%85%E5%AD%98%E4%BA%A4%E6%8D%A2%E6%95%88%E7%8E%87%E4%BD%8E\"><span class=\"toc-text\">2.4 分段为什么导致内存交换效率低</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-%E5%86%85%E5%AD%98%E5%88%86%E9%A1%B5\"><span class=\"toc-text\">3.内存分页</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-1-%E5%88%86%E9%A1%B5%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E3%80%8C%E5%A4%96%E9%83%A8%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87%E5%92%8C%E5%86%85%E5%AD%98%E4%BA%A4%E6%8D%A2%E6%95%88%E7%8E%87%E4%BD%8E%E3%80%8D%E7%9A%84%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">3.1 分页如何解决「外部内存碎片和内存交换效率低」的问题</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-2-%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6%E4%B8%8B%EF%BC%8C%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E5%92%8C%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E9%83%BD%E6%98%AF%E5%A6%82%E4%BD%95%E6%98%A0%E5%B0%84\"><span class=\"toc-text\">3.2 分页机制下，虚拟地址和物理地址都是如何映射</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-3-%E7%AE%80%E5%8D%95%E5%88%86%E9%A1%B5%E7%9A%84%E7%BC%BA%E9%99%B7\"><span class=\"toc-text\">3.3 简单分页的缺陷</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-4-%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8\"><span class=\"toc-text\">3.4 多级页表</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-5-TLB\"><span class=\"toc-text\">3.5 TLB</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-%E6%AE%B5%E9%A1%B5%E5%BC%8F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">4.段页式内存管理</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-Linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">5.Linux内存管理</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">6.总结</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-1-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8\"><span class=\"toc-text\">6.1 虚拟内存有什么作用</span></a></li></ol></li></ol>","author":{"name":"Fioransh","slug":"blog-author","avatar":"/medias/2.jpg","link":"/","description":"<p> 学而无知，无知而学 <p> <p> Anime is trash and so am I. <p>","socials":{"github":"https://github.com/orangefish1118","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/14481775?spm_id_from=333.1007.0.0"},"gitee":{"icon":"/svg/gitee.svg","link":"https://gitee.com/Orangefish-cyc"},"mail":{"icon":"/svg/email.svg","link":"mailto:1263938020@qq.com"}}}},"mapped":true,"hidden":false,"prev_post":{"title":"OS-调度算法","uid":"1074313276193b1539ba5882aa8b135e","slug":"OS-调度算法","date":"2024-06-04T14:25:12.000Z","updated":"2024-06-19T08:00:40.517Z","comments":true,"path":"api/articles/OS-调度算法.json","keywords":"博客、橙汁蒸鱼、Orangefish、Oranfish","cover":"/medias/28.jpg","text":"1.进程调度算法当 CPU 空闲时，操作系统就选择内存中的某个「就绪状态」的进程，并给其分配 CPU。 非抢占式的意思就是，当进程正在运行时，它就会一直运行，直...","permalink":"/post/OS-调度算法","photos":[],"count_time":{"symbolsCount":"6k","symbolsTime":"5 mins."},"categories":[{"name":"Study","slug":"Study","count":30,"path":"api/categories/Study.json"}],"tags":[{"name":"学习","slug":"学习","count":20,"path":"api/tags/学习.json"},{"name":"操作系统","slug":"操作系统","count":9,"path":"api/tags/操作系统.json"}],"author":{"name":"Fioransh","slug":"blog-author","avatar":"/medias/2.jpg","link":"/","description":"<p> 学而无知，无知而学 <p> <p> Anime is trash and so am I. <p>","socials":{"github":"https://github.com/orangefish1118","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/14481775?spm_id_from=333.1007.0.0"},"gitee":{"icon":"/svg/gitee.svg","link":"https://gitee.com/Orangefish-cyc"},"mail":{"icon":"/svg/email.svg","link":"mailto:1263938020@qq.com"}}}}},"next_post":{"title":"OS-课后作业题目总结","uid":"77c1bfd730d0b976f5020ec70d93bbca","slug":"OS-课后作业题目","date":"2024-05-12T10:25:12.000Z","updated":"2024-06-19T08:54:19.280Z","comments":true,"path":"api/articles/OS-课后作业题目.json","keywords":"博客、橙汁蒸鱼、Orangefish、Oranfish","cover":"/medias/32.jpg","text":"2024年操作系统期末大题复习材料...","permalink":"/post/OS-课后作业题目","photos":[],"count_time":{"symbolsCount":"4.4k","symbolsTime":"4 mins."},"categories":[{"name":"Study","slug":"Study","count":30,"path":"api/categories/Study.json"}],"tags":[{"name":"学习","slug":"学习","count":20,"path":"api/tags/学习.json"},{"name":"操作系统","slug":"操作系统","count":9,"path":"api/tags/操作系统.json"}],"author":{"name":"Fioransh","slug":"blog-author","avatar":"/medias/2.jpg","link":"/","description":"<p> 学而无知，无知而学 <p> <p> Anime is trash and so am I. <p>","socials":{"github":"https://github.com/orangefish1118","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/14481775?spm_id_from=333.1007.0.0"},"gitee":{"icon":"/svg/gitee.svg","link":"https://gitee.com/Orangefish-cyc"},"mail":{"icon":"/svg/email.svg","link":"mailto:1263938020@qq.com"}}}}}}