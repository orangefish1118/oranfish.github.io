{"title":"OS-调度算法","uid":"1074313276193b1539ba5882aa8b135e","slug":"OS-调度算法","date":"2024-06-04T14:25:12.000Z","updated":"2024-06-19T08:00:40.517Z","comments":true,"path":"api/articles/OS-调度算法.json","keywords":"博客、橙汁蒸鱼、Orangefish、Oranfish","cover":"/medias/28.jpg","content":"<h2 id=\"1-进程调度算法\"><a href=\"#1-进程调度算法\" class=\"headerlink\" title=\"1.进程调度算法\"></a>1.进程调度算法</h2><p>当 CPU 空闲时，操作系统就选择内存中的某个「就绪状态」的进程，并给其分配 CPU。</p>\n<p>非抢占式的意思就是，当进程正在运行时，它就会一直运行，直到该进程完成或发生某个事件而被阻塞时，才会把 CPU 让给其他进程。</p>\n<p>抢占式调度，顾名思义就是进程正在运行的时，可以被打断，使其把 CPU 让给其他进程。那抢占的原则一般有三种，分别是时间片原则、优先权原则、短作业优先原则。</p>\n<p>什么时候会发生 CPU 调度呢？通常有以下情况：</p>\n<ol>\n<li>当进程从运行状态转到等待状态；</li>\n<li>当进程从运行状态转到就绪状态；</li>\n<li>当进程从等待状态转到就绪状态；</li>\n<li>当进程从运行状态转到终止状态；</li>\n</ol>\n<p>其中发生在 1 和 4 两种情况下的调度称为「非抢占式调度」，2 和 3 两种情况下发生的调度称为「抢占式调度」。</p>\n<h3 id=\"1-1-先来先服务算法FCFS\"><a href=\"#1-1-先来先服务算法FCFS\" class=\"headerlink\" title=\"1.1 先来先服务算法FCFS\"></a>1.1 先来先服务算法FCFS</h3><p>最简单的一个调度算法，就是非抢占式的<strong>先来先服务（*First Come First Severd, FCFS*）算法</strong>了。</p>\n<p><img src=\"/oranfish.github.io/posts/0/OS-%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/24-%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1.jpg\" alt=\"FCFS 调度算法\"></p>\n<p>顾名思义，先来后到，<strong>每次从就绪队列选择最先进入队列的进程，然后一直运行，直到进程退出或被阻塞，才会继续从队列中选择第一个进程接着运行。</strong></p>\n<p>这似乎很公平，但是当一个长作业先运行了，那么后面的短作业等待的时间就会很长，不利于短作业。</p>\n<p>FCFS 对长作业有利，适用于 CPU 繁忙型作业的系统，而不适用于 I&#x2F;O 繁忙型作业的系统。</p>\n<p><img src=\"/oranfish.github.io/posts/0/OS-%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/image-20240604214844570.png\" alt=\"image-20240604214844570\"></p>\n<h3 id=\"1-2-最短作业优先调度算法SJF-SPN\"><a href=\"#1-2-最短作业优先调度算法SJF-SPN\" class=\"headerlink\" title=\"1.2 最短作业优先调度算法SJF&#x2F;SPN\"></a>1.2 最短作业优先调度算法SJF&#x2F;SPN</h3><p><strong>最短作业优先（*Shortest Job First, SJF*）调度算法</strong>同样也是顾名思义，它会<strong>优先选择运行时间最短的进程来运行</strong>，这有助于提高系统的吞吐量。</p>\n<p><img src=\"/oranfish.github.io/posts/0/OS-%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/25-%E6%9C%80%E7%9F%AD%E4%BD%9C%E4%B8%9A%E4%BC%98%E5%85%88%E7%AE%97%E6%B3%95.jpg\" alt=\"SJF 调度算法\"></p>\n<p>这显然对长作业不利，很容易造成一种极端现象。</p>\n<p>比如，一个长作业在就绪队列等待运行，而这个就绪队列有非常多的短作业，那么就会使得长作业不断的往后推，周转时间变长，致使长作业长期不会被运行。</p>\n<p><img src=\"/oranfish.github.io/posts/0/OS-%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/image-20240604215144143.png\" alt=\"image-20240604215144143\"></p>\n<h3 id=\"1-3-高响应比优先调度算法HRRN\"><a href=\"#1-3-高响应比优先调度算法HRRN\" class=\"headerlink\" title=\"1.3 高响应比优先调度算法HRRN\"></a>1.3 高响应比优先调度算法HRRN</h3><p>前面的「先来先服务调度算法」和「最短作业优先调度算法」都没有很好的权衡短作业和长作业。</p>\n<p>那么，<strong>高响应比优先 （*Highest Response Ratio Next, HRRN*）调度算法</strong>主要是权衡了短作业和长作业。</p>\n<p><strong>每次进行进程调度时，先计算「响应比优先级」，然后把「响应比优先级」最高的进程投入运行</strong>，「响应比优先级」的计算公式：</p>\n<img src=\"/oranfish.github.io/posts/0/26-%E5%93%8D%E5%BA%94%E6%AF%94%E5%85%AC%E5%BC%8F.jpg\" alt=\"img\" style=\"zoom:33%;\">\n\n<p>从上面的公式，可以发现：</p>\n<ul>\n<li>如果两个进程的「等待时间」相同时，「要求的服务时间」越短，「响应比」就越高，这样短作业的进程容易被选中运行；</li>\n<li>如果两个进程「要求的服务时间」相同时，「等待时间」越长，「响应比」就越高，这就兼顾到了长作业进程，因为进程的响应比可以随时间等待的增加而提高，当其等待时间足够长时，其响应比便可以升到很高，从而获得运行的机会；</li>\n</ul>\n<p><img src=\"/oranfish.github.io/posts/0/OS-%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/image-20240604215832454.png\" alt=\"image-20240604215832454\"></p>\n<h3 id=\"1-4-时间片轮转调度算法RR\"><a href=\"#1-4-时间片轮转调度算法RR\" class=\"headerlink\" title=\"1.4 时间片轮转调度算法RR\"></a>1.4 时间片轮转调度算法RR</h3><p>最古老、最简单、最公平且使用最广的算法就是<strong>时间片轮转（*Round Robin, RR*）调度算法</strong>。</p>\n<p><img src=\"/oranfish.github.io/posts/0/OS-%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/27-%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%AF%A2.jpg\" alt=\"RR 调度算法\"></p>\n<p><strong>每个进程被分配一个时间段，称为时间片（*Quantum*），即允许该进程在该时间段中运行。</strong></p>\n<ul>\n<li>如果时间片用完，进程还在运行，那么将会把此进程从 CPU 释放出来，并把 CPU 分配另外一个进程；</li>\n<li>如果该进程在时间片结束前阻塞或结束，则 CPU 立即进行切换；</li>\n</ul>\n<p>另外，时间片的长度就是一个很关键的点：</p>\n<ul>\n<li>如果时间片设得太短会导致过多的进程上下文切换，降低了 CPU 效率；</li>\n<li>如果设得太长又可能引起对短作业进程的响应时间变长。将</li>\n</ul>\n<p>通常时间片设为 <code>20ms~50ms</code> 通常是一个比较合理的折中值。</p>\n<p><img src=\"/oranfish.github.io/posts/0/OS-%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/image-20240604215902991.png\" alt=\"image-20240604215902991\"></p>\n<h3 id=\"1-5-最高优先级调度算法HPF\"><a href=\"#1-5-最高优先级调度算法HPF\" class=\"headerlink\" title=\"1.5 最高优先级调度算法HPF\"></a>1.5 最高优先级调度算法HPF</h3><p>前面的「时间片轮转算法」做了个假设，即让所有的进程同等重要，也不偏袒谁，大家的运行时间都一样。</p>\n<p>但是，对于多用户计算机系统就有不同的看法了，它们希望调度是有优先级的，即希望调度程序能<strong>从就绪队列中选择最高优先级的进程进行运行，这称为最高优先级（*Highest Priority First，HPF*）调度算法</strong>。</p>\n<p>进程的优先级可以分为，静态优先级或动态优先级：</p>\n<ul>\n<li>静态优先级：创建进程时候，就已经确定了优先级了，然后整个运行时间优先级都不会变化；</li>\n<li>动态优先级：根据进程的动态变化调整优先级，比如如果进程运行时间增加，则降低其优先级，如果进程等待时间（就绪队列的等待时间）增加，则升高其优先级，也就是<strong>随着时间的推移增加等待进程的优先级</strong>。</li>\n</ul>\n<p>该算法也有两种处理优先级高的方法，非抢占式和抢占式：</p>\n<ul>\n<li>非抢占式：当就绪队列中出现优先级高的进程，运行完当前进程，再选择优先级高的进程。</li>\n<li>抢占式：当就绪队列中出现优先级高的进程，当前进程挂起，调度优先级高的进程运行。</li>\n</ul>\n<p>但是依然有缺点，可能会导致低优先级的进程永远不会运行。</p>\n<p><img src=\"/oranfish.github.io/posts/0/OS-%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/image-20240604215946468.png\" alt=\"image-20240604215946468\"></p>\n<p><img src=\"/oranfish.github.io/posts/0/OS-%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/image-20240604215951887.png\" alt=\"image-20240604215951887\"></p>\n<h3 id=\"1-6-多级反馈队列调度算法MFQ\"><a href=\"#1-6-多级反馈队列调度算法MFQ\" class=\"headerlink\" title=\"1.6 多级反馈队列调度算法MFQ\"></a>1.6 多级反馈队列调度算法MFQ</h3><p><strong>多级反馈队列（*Multilevel Feedback Queue*）调度算法</strong>是「时间片轮转算法」和「最高优先级算法」的综合和发展。</p>\n<p>顾名思义：</p>\n<ul>\n<li>「多级」表示有多个队列，每个队列优先级从高到低，同时优先级越高时间片越短。</li>\n<li>「反馈」表示如果有新的进程加入优先级高的队列时，立刻停止当前正在运行的进程，转而去运行优先级高的队列；</li>\n</ul>\n<p><img src=\"/oranfish.github.io/posts/0/OS-%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/28-%E5%A4%9A%E7%BA%A7%E9%98%9F%E5%88%97.jpg\" alt=\"多级反馈队列\"></p>\n<p>来看看，它是如何工作的：</p>\n<ul>\n<li>设置了多个队列，赋予每个队列不同的优先级，每个<strong>队列优先级从高到低</strong>，同时<strong>优先级越高时间片越短</strong>；</li>\n<li>新的进程会被放入到第一级队列的末尾，按先来先服务的原则排队等待被调度，如果在第一级队列规定的时间片没运行完成，则将其转入到第二级队列的末尾，以此类推，直至完成；</li>\n<li>当较高优先级的队列为空，才调度较低优先级的队列中的进程运行。如果进程运行时，有新进程进入较高优先级的队列，则停止当前运行的进程并将其移入到原队列末尾，接着让较高优先级的进程运行；</li>\n</ul>\n<p>可以发现，对于短作业可能可以在第一级队列很快被处理完。对于长作业，如果在第一级队列处理不完，可以移入下次队列等待被执行，虽然等待的时间变长了，但是运行时间也会更长了，所以该算法很好的<strong>兼顾了长短作业，同时有较好的响应时间。</strong></p>\n<p><img src=\"/oranfish.github.io/posts/0/OS-%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/image-20240604220004649.png\" alt=\"image-20240604220004649\"></p>\n<h2 id=\"2-内存页面置换算法\"><a href=\"#2-内存页面置换算法\" class=\"headerlink\" title=\"2.内存页面置换算法\"></a>2.内存页面置换算法</h2><p><strong>缺页异常（缺页中断）</strong></p>\n<p>当 CPU 访问的页面不在物理内存时，便会产生一个缺页中断，请求操作系统将所缺页调入到物理内存。那它与一般中断的主要区别在于：</p>\n<ul>\n<li>缺页中断在指令执行「期间」产生和处理中断信号，而一般中断在一条指令执行「完成」后检查和处理中断信号。</li>\n<li>缺页中断返回到该指令的开始重新执行「该指令」，而一般中断返回回到该指令的「下一个指令」执行。</li>\n</ul>\n<p>我们来看一下缺页中断的处理流程，如下图：</p>\n<img src=\"/oranfish.github.io/posts/0/%E7%BC%BA%E9%A1%B5%E5%BC%82%E5%B8%B8%E6%B5%81%E7%A8%8B.png\" alt=\"缺页中断的处理流程\" style=\"zoom:50%;\">\n\n<p>找不到空闲页的话，就说明此时内存已满了，这时候，就需要「页面置换算法」选择一个物理页，如果该物理页有被修改过（脏页），则把它换出到磁盘，然后把该被置换出去的页表项的状态改成「无效的」，最后把正在访问的页面装入到这个物理页中。</p>\n<p>这里提一下，页表项通常有如下图的字段：</p>\n<p><img src=\"/oranfish.github.io/posts/0/OS-%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/%E9%A1%B5%E8%A1%A8%E9%A1%B9%E5%AD%97%E6%AE%B5.png\" alt=\"img\"></p>\n<p>那其中：</p>\n<ul>\n<li><em>状态位</em>：用于表示该页是否有效，也就是说是否在物理内存中，供程序访问时参考。</li>\n<li><em>访问字段</em>：用于记录该页在一段时间被访问的次数，供页面置换算法选择出页面时参考。</li>\n<li><em>修改位</em>：表示该页在调入内存后是否有被修改过，由于内存中的每一页都在磁盘上保留一份副本，因此，如果没有修改，在置换该页时就不需要将该页写回到磁盘上，以减少系统的开销；如果已经被修改，则将该页重写到磁盘上，以保证磁盘中所保留的始终是最新的副本。</li>\n<li><em>硬盘地址</em>：用于指出该页在硬盘上的地址，通常是物理块号，供调入该页时使用。</li>\n</ul>\n<p>虚拟内存的管理整个流程：</p>\n<img src=\"/oranfish.github.io/posts/0/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%B5%81%E7%A8%8B.png\" alt=\"虚拟内存的流程\" style=\"zoom:50%;\">\n\n<p>所以，页面置换算法的功能是，<strong>当出现缺页异常，需调入新页面而内存已满时，选择被置换的物理页面</strong>，也就是说选择一个物理页面换出到磁盘，然后把需要访问的页面换入到物理页。</p>\n<h3 id=\"2-1-最佳页面置换算法OPT\"><a href=\"#2-1-最佳页面置换算法OPT\" class=\"headerlink\" title=\"2.1 最佳页面置换算法OPT\"></a>2.1 最佳页面置换算法OPT</h3><p>最佳页面置换算法基本思路是，<strong>置换在「未来」最长时间不访问的页面</strong>。</p>\n<p>所以，该算法实现需要计算内存中每个逻辑页面的「下一次」访问时间，然后比较，选择未来最长时间不访问的页面。</p>\n<p>这很理想，但是实际系统中无法实现，因为程序访问页面时是动态的，我们是无法预知每个页面在「下一次」访问前的等待时间。</p>\n<p>所以，最佳页面置换算法作用是为了衡量你的算法的效率，你的算法效率越接近该算法的效率，那么说明你的算法是高效的。</p>\n<p><img src=\"/oranfish.github.io/posts/0/OS-%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/image-20240604220821278.png\"></p>\n<h3 id=\"2-2-先进先出置换算法FIFO\"><a href=\"#2-2-先进先出置换算法FIFO\" class=\"headerlink\" title=\"2.2 先进先出置换算法FIFO\"></a>2.2 先进先出置换算法FIFO</h3><p>既然我们无法预知页面在下一次访问前所需的等待时间，那我们可以<strong>选择在内存驻留时间很长的页面进行中置换</strong>，这个就是「先进先出置换」算法的思想。</p>\n<p><img src=\"/oranfish.github.io/posts/0/OS-%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/image-20240604220858802.png\" alt=\"image-20240604220858802\"></p>\n<h3 id=\"2-3-最近最久未使用的置换算法LRU\"><a href=\"#2-3-最近最久未使用的置换算法LRU\" class=\"headerlink\" title=\"2.3 最近最久未使用的置换算法LRU\"></a>2.3 最近最久未使用的置换算法LRU</h3><p>最近最久未使用（<em>LRU</em>）的置换算法的基本思路是，发生缺页时，<strong>选择最长时间没有被访问的页面进行置换</strong>，也就是说，该算法假设已经很久没有使用的页面很有可能在未来较长的一段时间内仍然不会被使用。</p>\n<p>这种算法近似最优置换算法，最优置换算法是通过「未来」的使用情况来推测要淘汰的页面，而 LRU 则是通过「历史」的使用情况来推测要淘汰的页面。</p>\n<p>虽然 LRU 在理论上是可以实现的，但代价很高。为了完全实现 LRU，需要在内存中维护一个所有页面的链表，最近最多使用的页面在表头，最近最少使用的页面在表尾。</p>\n<p>困难的是，在每次访问内存时都必须要更新「整个链表」。在链表中找到一个页面，删除它，然后把它移动到表头是一个非常费时的操作。</p>\n<p>所以，LRU 虽然看上去不错，但是由于开销比较大，实际应用中比较少使用。</p>\n<p><img src=\"/oranfish.github.io/posts/0/OS-%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/image-20240604221026860.png\" alt=\"image-20240604221026860\"></p>\n<h3 id=\"2-4-时钟页面置换算法\"><a href=\"#2-4-时钟页面置换算法\" class=\"headerlink\" title=\"2.4 时钟页面置换算法\"></a>2.4 时钟页面置换算法</h3><p>时钟页面置换算法就可以两者兼得，它跟 LRU 近似，又是对 FIFO 的一种改进。</p>\n<p>该算法的思路是，把所有的页面都保存在一个类似钟面的「环形链表」中，一个表针指向最老的页面。</p>\n<p>当发生缺页中断时，算法首先检查表针指向的页面：</p>\n<ul>\n<li>如果它的访问位位是 0 就淘汰该页面，并把新的页面插入这个位置，然后把表针前移一个位置；</li>\n<li>如果访问位是 1 就清除访问位，并把表针前移一个位置，重复这个过程直到找到了一个访问位为 0 的页面为止；</li>\n</ul>\n<p>我画了一副时钟页面置换算法的工作流程图，你可以在下方看到：</p>\n<p><img src=\"/oranfish.github.io/posts/0/OS-%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/%E6%97%B6%E9%92%9F%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95.png\" alt=\"时钟页面置换算法\"></p>\n<h3 id=\"2-5-最不常用算法LFU\"><a href=\"#2-5-最不常用算法LFU\" class=\"headerlink\" title=\"2.5 最不常用算法LFU\"></a>2.5 最不常用算法LFU</h3><p>最不常用（<em>LFU</em>）算法，这名字听起来很调皮，但是它的意思不是指这个算法不常用，而是<strong>当发生缺页中断时，选择「访问次数」最少的那个页面，并将其淘汰</strong>。</p>\n<p>它的实现方式是，对每个页面设置一个「访问计数器」，每当一个页面被访问时，该页面的访问计数器就累加 1。在发生缺页中断时，淘汰计数器值最小的那个页面。</p>\n<p>看起来很简单，每个页面加一个计数器就可以实现了，但是在操作系统中实现的时候，我们需要考虑效率和硬件成本的。</p>\n<p>要增加一个计数器来实现，这个硬件成本是比较高的，另外如果要对这个计数器查找哪个页面访问次数最小，查找链表本身，如果链表长度很大，是非常耗时的，效率不高。</p>\n<p>但还有个问题，LFU 算法只考虑了频率问题，没考虑时间的问题，比如有些页面在过去时间里访问的频率很高，但是现在已经没有访问了，而当前频繁访问的页面由于没有这些页面访问的次数高，在发生缺页中断时，就会可能会误伤当前刚开始频繁访问，但访问次数还不高的页面。</p>\n<p>那这个问题的解决的办法还是有的，可以定期减少访问的次数，比如当发生时间中断时，把过去时间访问的页面的访问次数除以 2，也就说，随着时间的流失，以前的高访问次数的页面会慢慢减少，相当于加大了被置换的概率。</p>\n<h2 id=\"3-磁盘调度算法\"><a href=\"#3-磁盘调度算法\" class=\"headerlink\" title=\"3.磁盘调度算法\"></a>3.磁盘调度算法</h2><p>磁盘调度算法的目的很简单，就是为了提高磁盘的访问性能，一般是通过优化磁盘的访问请求顺序来做到的。</p>\n<p>寻道的时间是磁盘访问最耗时的部分，如果请求顺序优化的得当，必然可以节省一些不必要的寻道时间，从而提高磁盘的访问性能。</p>\n<h3 id=\"3-1-先来先服务FCFS\"><a href=\"#3-1-先来先服务FCFS\" class=\"headerlink\" title=\"3.1 先来先服务FCFS\"></a>3.1 先来先服务FCFS</h3><p>先来先服务（<em>First-Come，First-Served，FCFS</em>），顾名思义，先到来的请求，先被服务。</p>\n<p>这种算法，比较简单粗暴，但是如果大量进程竞争使用磁盘，请求访问的磁道可能会很分散，那先来先服务算法在性能上就会显得很差，因为寻道时间过长。</p>\n<p><img src=\"/oranfish.github.io/posts/0/OS-%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/image-20240604221422590.png\" alt=\"image-20240604221422590\"></p>\n<h3 id=\"3-2-最短寻道时间优先SSTF\"><a href=\"#3-2-最短寻道时间优先SSTF\" class=\"headerlink\" title=\"3.2 最短寻道时间优先SSTF\"></a>3.2 最短寻道时间优先SSTF</h3><p>最短寻道时间优先（<em>Shortest Seek First，SSF</em>）算法的工作方式是，优先选择从当前磁头位置所需寻道时间最短的请求</p>\n<p><img src=\"/oranfish.github.io/posts/0/OS-%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/image-20240604221429941.png\" alt=\"image-20240604221429941\"></p>\n<p>但这个算法可能存在某些请求的<strong>饥饿</strong>，因为本次例子我们是静态的序列，看不出问题，假设是一个动态的请求，如果后续来的请求都是小于 183 磁道的，那么 183 磁道可能永远不会被响应，于是就产生了饥饿现象，这里<strong>产生饥饿的原因是磁头在一小块区域来回移动</strong>。</p>\n<h3 id=\"3-3-扫描算法SCAN\"><a href=\"#3-3-扫描算法SCAN\" class=\"headerlink\" title=\"3.3 扫描算法SCAN\"></a>3.3 扫描算法SCAN</h3><p>最短寻道时间优先算法会产生饥饿的原因在于：磁头有可能再一个小区域内来回得移动。</p>\n<p>为了防止这个问题，可以规定：<strong>磁头在一个方向上移动，访问所有未完成的请求，直到磁头到达该方向上的最后的磁道，才调换方向，这就是扫描（*Scan*）算法</strong>。</p>\n<p>这种算法也叫做电梯算法，比如电梯保持按一个方向移动，直到在那个方向上没有请求为止，然后改变方向。</p>\n<p>磁头先响应左边的请求，直到到达最左端（ 0 磁道）后，才开始反向移动，响应右边的请求。</p>\n<p>扫描调度算法性能较好，不会产生饥饿现象，但是存在这样的问题，中间部分的磁道会比较占便宜，中间部分相比其他部分响应的频率会比较多，也就是说每个磁道的响应频率存在差异。</p>\n<p><img src=\"/oranfish.github.io/posts/0/OS-%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/image-20240604221435618.png\" alt=\"image-20240604221435618\"></p>\n<h3 id=\"3-4-循环扫描算法C-SCAN\"><a href=\"#3-4-循环扫描算法C-SCAN\" class=\"headerlink\" title=\"3.4 循环扫描算法C-SCAN\"></a>3.4 循环扫描算法C-SCAN</h3><p>扫描算法使得每个磁道响应的频率存在差异，那么要优化这个问题的话，可以总是按相同的方向进行扫描，使得每个磁道的响应频率基本一致。</p>\n<p>循环扫描（<em>Circular Scan, CSCAN</em> ）规定：只有磁头朝某个特定方向移动时，才处理磁道访问请求，而返回时直接快速移动至最靠边缘的磁道，也就是复位磁头，这个过程是很快的，并且<strong>返回中途不处理任何请求</strong>，该算法的特点，就是<strong>磁道只响应一个方向上的请求</strong>。</p>\n<p><img src=\"/oranfish.github.io/posts/0/OS-%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/image-20240604221441463.png\" alt=\"image-20240604221441463\"></p>\n<p>磁头先响应了右边的请求，直到碰到了最右端的磁道 199，就立即回到磁盘的开始处（磁道 0），但这个返回的途中是不响应任何请求的，直到到达最开始的磁道后，才继续顺序响应右边的请求。</p>\n<p>循环扫描算法相比于扫描算法，对于各个位置磁道响应频率相对比较平均。</p>\n<h3 id=\"3-5-LOOK和C-LOOK算法\"><a href=\"#3-5-LOOK和C-LOOK算法\" class=\"headerlink\" title=\"3.5 LOOK和C-LOOK算法\"></a>3.5 LOOK和C-LOOK算法</h3><p>我们前面说到的扫描算法和循环扫描算法，都是磁头移动到磁盘「最始端或最末端」才开始调换方向。</p>\n<p>那这其实是可以优化的，优化的思路就是<strong>磁头在移动到「最远的请求」位置，然后立即反向移动。</strong></p>\n<p>那针对 SCAN 算法的优化则叫 LOOK 算法，它的工作方式，磁头在每个方向上仅仅移动到最远的请求位置，然后立即反向移动，而不需要移动到磁盘的最始端或最末端，<strong>反向移动的途中会响应请求</strong>。</p>\n<img src=\"/oranfish.github.io/posts/0/%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6-LOOK%E7%AE%97%E6%B3%95.png\" alt=\"LOOK 算法\" style=\"zoom:50%;\">\n\n<p>而针 C-SCAN 算法的优化则叫 C-LOOK，它的工作方式，磁头在每个方向上仅仅移动到最远的请求位置，然后立即反向移动，而不需要移动到磁盘的最始端或最末端，<strong>反向移动的途中不会响应请求</strong>。</p>\n<img src=\"/oranfish.github.io/posts/0/%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6-C-LOOK%E7%AE%97%E6%B3%95.png\" alt=\"C-LOOK 算法\" style=\"zoom:50%;\">","text":"1.进程调度算法当 CPU 空闲时，操作系统就选择内存中的某个「就绪状态」的进程，并给其分配 CPU。 非抢占式的意思就是，当进程正在运行时，它就会一直运行，直...","permalink":"/post/OS-调度算法","photos":[],"count_time":{"symbolsCount":"6k","symbolsTime":"5 mins."},"categories":[{"name":"Study","slug":"Study","count":30,"path":"api/categories/Study.json"}],"tags":[{"name":"学习","slug":"学习","count":20,"path":"api/tags/学习.json"},{"name":"操作系统","slug":"操作系统","count":9,"path":"api/tags/操作系统.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">1.进程调度算法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-1-%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1%E7%AE%97%E6%B3%95FCFS\"><span class=\"toc-text\">1.1 先来先服务算法FCFS</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-2-%E6%9C%80%E7%9F%AD%E4%BD%9C%E4%B8%9A%E4%BC%98%E5%85%88%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95SJF-SPN\"><span class=\"toc-text\">1.2 最短作业优先调度算法SJF&#x2F;SPN</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-3-%E9%AB%98%E5%93%8D%E5%BA%94%E6%AF%94%E4%BC%98%E5%85%88%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95HRRN\"><span class=\"toc-text\">1.3 高响应比优先调度算法HRRN</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-4-%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%BD%AC%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95RR\"><span class=\"toc-text\">1.4 时间片轮转调度算法RR</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-5-%E6%9C%80%E9%AB%98%E4%BC%98%E5%85%88%E7%BA%A7%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95HPF\"><span class=\"toc-text\">1.5 最高优先级调度算法HPF</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-6-%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95MFQ\"><span class=\"toc-text\">1.6 多级反馈队列调度算法MFQ</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E5%86%85%E5%AD%98%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">2.内存页面置换算法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-1-%E6%9C%80%E4%BD%B3%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95OPT\"><span class=\"toc-text\">2.1 最佳页面置换算法OPT</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-2-%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95FIFO\"><span class=\"toc-text\">2.2 先进先出置换算法FIFO</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-3-%E6%9C%80%E8%BF%91%E6%9C%80%E4%B9%85%E6%9C%AA%E4%BD%BF%E7%94%A8%E7%9A%84%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95LRU\"><span class=\"toc-text\">2.3 最近最久未使用的置换算法LRU</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-4-%E6%97%B6%E9%92%9F%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">2.4 时钟页面置换算法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-5-%E6%9C%80%E4%B8%8D%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95LFU\"><span class=\"toc-text\">2.5 最不常用算法LFU</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">3.磁盘调度算法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-1-%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1FCFS\"><span class=\"toc-text\">3.1 先来先服务FCFS</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-2-%E6%9C%80%E7%9F%AD%E5%AF%BB%E9%81%93%E6%97%B6%E9%97%B4%E4%BC%98%E5%85%88SSTF\"><span class=\"toc-text\">3.2 最短寻道时间优先SSTF</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-3-%E6%89%AB%E6%8F%8F%E7%AE%97%E6%B3%95SCAN\"><span class=\"toc-text\">3.3 扫描算法SCAN</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-4-%E5%BE%AA%E7%8E%AF%E6%89%AB%E6%8F%8F%E7%AE%97%E6%B3%95C-SCAN\"><span class=\"toc-text\">3.4 循环扫描算法C-SCAN</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-5-LOOK%E5%92%8CC-LOOK%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">3.5 LOOK和C-LOOK算法</span></a></li></ol></li></ol>","author":{"name":"Fioransh","slug":"blog-author","avatar":"/medias/2.jpg","link":"/","description":"<p> 学而无知，无知而学 <p> <p> Anime is trash and so am I. <p>","socials":{"github":"https://github.com/orangefish1118","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/14481775?spm_id_from=333.1007.0.0"},"gitee":{"icon":"/svg/gitee.svg","link":"https://gitee.com/Orangefish-cyc"},"mail":{"icon":"/svg/email.svg","link":"mailto:1263938020@qq.com"}}}},"mapped":true,"hidden":false,"prev_post":{"title":"OS-文件系统","uid":"a309e6723d5eeefad0a013dac5e81168","slug":"OS-文件系统","date":"2024-06-07T06:25:12.000Z","updated":"2024-06-19T08:05:06.140Z","comments":true,"path":"api/articles/OS-文件系统.json","keywords":"博客、橙汁蒸鱼、Orangefish、Oranfish","cover":"/medias/35.jpg","text":"1.文件系统的基本组成文件系统是操作系统中负责管理持久数据的子系统，负责把用户文件存到磁盘硬件。 文件系统的基本数据单位是文件，它的目的是对磁盘上的文件进行组织...","permalink":"/post/OS-文件系统","photos":[],"count_time":{"symbolsCount":"10k","symbolsTime":"9 mins."},"categories":[{"name":"Study","slug":"Study","count":30,"path":"api/categories/Study.json"}],"tags":[{"name":"学习","slug":"学习","count":20,"path":"api/tags/学习.json"},{"name":"操作系统","slug":"操作系统","count":9,"path":"api/tags/操作系统.json"}],"author":{"name":"Fioransh","slug":"blog-author","avatar":"/medias/2.jpg","link":"/","description":"<p> 学而无知，无知而学 <p> <p> Anime is trash and so am I. <p>","socials":{"github":"https://github.com/orangefish1118","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/14481775?spm_id_from=333.1007.0.0"},"gitee":{"icon":"/svg/gitee.svg","link":"https://gitee.com/Orangefish-cyc"},"mail":{"icon":"/svg/email.svg","link":"mailto:1263938020@qq.com"}}}}},"next_post":{"title":"OS-虚拟内存","uid":"a8e53f71d8296af4285fe02496a3f129","slug":"OS-虚拟内存","date":"2024-06-04T12:25:12.000Z","updated":"2024-06-19T08:05:32.470Z","comments":true,"path":"api/articles/OS-虚拟内存.json","keywords":"博客、橙汁蒸鱼、Orangefish、Oranfish","cover":"/medias/36.jpg","text":"1.虚拟内存1.1 引入单片机的CPU是直接操作内存的 [物理地址] 此时不能同时在内存运行两个程序，如何解决？ 1.2 操作系统如何解决这个问题问题在于两个程...","permalink":"/post/OS-虚拟内存","photos":[],"count_time":{"symbolsCount":"6.3k","symbolsTime":"6 mins."},"categories":[{"name":"Study","slug":"Study","count":30,"path":"api/categories/Study.json"}],"tags":[{"name":"学习","slug":"学习","count":20,"path":"api/tags/学习.json"},{"name":"操作系统","slug":"操作系统","count":9,"path":"api/tags/操作系统.json"}],"author":{"name":"Fioransh","slug":"blog-author","avatar":"/medias/2.jpg","link":"/","description":"<p> 学而无知，无知而学 <p> <p> Anime is trash and so am I. <p>","socials":{"github":"https://github.com/orangefish1118","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/14481775?spm_id_from=333.1007.0.0"},"gitee":{"icon":"/svg/gitee.svg","link":"https://gitee.com/Orangefish-cyc"},"mail":{"icon":"/svg/email.svg","link":"mailto:1263938020@qq.com"}}}}}}