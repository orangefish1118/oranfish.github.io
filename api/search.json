[{"id":"3a4ba5bc78945135efd42b16374ed036","title":"MySQL知识点总结","content":"1.前言在我们讲解SpringBootWeb基础知识(请求响应案例)的时候，我们讲到在web开发中，为了应用程序职责单一，方便维护，我们一般将web应用程序分为三层，即：Controller、Service、Dao 。\n之前我们的案例中，是这样子的请求流程：浏览器发起请求，先请求Controller；Controller接收到请求之后，调用Service进行业务逻辑处理；Service再调用Dao，Dao再解析user.xml中所存储的数据。\nxml文件中可以存储数据，但是在企业项目开发中不会使用xml文件存储数据，因为不便管理维护，操作难度大。 在真实的企业开发中呢，都会采用数据库来存储和管理数据，那此时，web开发调用流程图如下所示：\n\n2.初识MySQL2.1 介绍首先来了解一下什么是数据库。\n\n数据库：英文为 DataBase，简称DB，它是存储和管理数据的仓库。\n\n数据是存储在数据库中的，那我们要如何来操作数据库以及数据库中所存放的数据呢？\n那这里呢，会涉及到一个软件：数据库管理系统（DataBase Management System，简称DBMS）\n\nDBMS是操作和管理数据库的大型软件。将来我们只需要操作这个软件，就可以通过这个软件来操纵和管理数据库了。\n\n此时又出现一个问题：DBMS这个软件怎么知道要操作的是哪个数据库、哪个数据呢？是对数据做修改还是查询呢？\n\n需要给DBMS软件发送一条指令，告诉这个软件我们要执行的是什么样的操作，要对哪个数据进行操作。而这个指令就是SQL语句\n\nSQL（Structured Query Language，简称SQL）：结构化查询语言，它是操作关系型数据库的编程语言，定义了一套操作关系型数据库的统一标准。我们学习数据库开发，最为重要的就是学习SQL语句 。\n\n\n\n\n\n\n\n\n\n关系型数据库：我们后面会详细讲解，现在大家只需要知道我们学习的数据库属于关系型数据库即可。\n结论：程序员给数据库管理系统(DBMS)发送SQL语句，再由数据库管理系统操作数据库当中的数据。\n了解了数据库的一些简单概念之后，接下来我们再来介绍下目前主流的数据库，这里截取了排名前十的数据库：\n \n\nOracle：大型的收费数据库，Oracle公司产品，价格昂贵。（通常是不差钱的公司会选择使用这个数据库）\nMySQL：开源免费的中小型数据库，后来Sun公司收购了MySQL，而Oracle又收购了Sun公司。目前Oracle推出两个版本的Mysql：社区版(开源免费)、商业版(收费)。\nSQL Server：Microsoft 公司推出的收费的中型数据库，C#、.net等语言常用。\nPostgreSQL：开源免费的中小型数据库。\nDB2：IBM公司的大型收费数据库产品。\nSQLLite：嵌入式的微型数据库。Android内置的数据库采用的就是该数据库。\nMariaDB：开源免费的中小型数据库。是MySQL数据库的另外一个分支、另外一个衍生产品，与MySQL数据库有很好的兼容性。\n\n2.2 MySQL入门MySQL官方提供了两个版本：\n\n商业版本（MySQL Enterprise Edition）\n\n该版本是收费的，我们可以使用30天。 官方会提供对应的技术支持。\n\n\n社区版本（MySQL Community Server）\n\n该版本是免费的，但是MySQL不会提供任何的技术支持。\n\n\n\n官网下载地址：https://downloads.mysql.com/archives/community/\n\n\n\n\n\n\n\n\n\n\n安装MySQL具体的步骤，参考资料中提供的 《MySQL安装文档》 ，进行软件的安装即可。\nMySQL服务器启动完毕后，然后再使用如下指令，来连接MySQL服务器：\ntxtmysql -u用户名 -p密码 [-h数据库服务器的IP地址 -P端口号]\n\n\n\n\n\n\n\n\n-h  参数不加，默认连接的是本地 127.0.0.1 的MySQL服务器\n-P  参数不加，默认连接的端口号是 3306\n上述指令，可以有两种形式：\n\n密码直接在-p参数之后直接指定 （这种方式不安全，密码直接以明文形式出现在命令行）\n\n\n\n密码在-p回车之后，在命令行中输入密码，然后回车\n\n \n在真实的企业开发中，MySQL数据库服务器是不会在我们本地安装的，是在公司的服务器上安装的，而服务器还需要放置在专门的IDC机房中的，IDC机房呢，就需要保证恒温、恒湿、恒压，而且还要保证网络、电源的可靠性(备用电源及网络)。\n我们在学习阶段，如果想提前体验一下企业中数据库的使用方式，可以借助于VMware虚拟机来实现。我们可以在我们的电脑上安装一个VMware，然后在Vmware虚拟机上在安装一个服务器操作系统Linux，然后再在Linux服务器上安装各种企业级软件。\n2.3 数据模型关系型数据库（RDBMS）\n概念：建立在关系模型基础上，由多张相互连接的二维表组成的数据库。\n二维表的优点：\n\n使用表存储数据，格式统一，便于维护\n\n使用SQL语言操作，标准统一，使用方便，可用于复杂查询\n\n\n\n\n\n\n\n\n\n\n\n我们之前提到的MySQL、Oracle、DB2、SQLServer这些都是属于关系型数据库，里面都是基于二维表存储数据的。\n结论：基于二维表存储数据的数据库就成为关系型数据库，不是基于二维表存储数据的数据库，就是非关系型数据库（比如大家后面要学习的Redis，就属于非关系型数据库）。\n数据模型\nMySQL是关系型数据库，是基于二维表进行数据存储的，具体的结构图下:\n\n\n通过MySQL客户端连接数据库管理系统DBMS，然后通过DBMS操作数据库\n使用MySQL客户端，向数据库管理系统发送一条SQL语句，由数据库管理系统根据SQL语句指令去操作数据库中的表结构及数据\n一个数据库服务器中可以创建多个数据库，一个数据库中也可以包含多张表，而一张表中又可以包含多行记录。\n\n\n\n\n\n\n\n\n\n\n在Mysql数据库服务器当中存储数据，你需要：\n\n先去创建数据库（可以创建多个数据库，之间是相互独立的）\n在数据库下再去创建数据表（一个数据库下可以创建多张表）\n再将数据存放在数据表中（一张表可以存储多行数据）\n\n2.4 SQL简介SQL：结构化查询语言。一门操作关系型数据库的编程语言，定义操作所有关系型数据库的统一标准。\n2.4.1 SQL通用语法1、SQL语句可以单行或多行书写，以分号结尾。\n2、SQL语句可以使用空格&#x2F;缩进来增强语句的可读性。\n3、MySQL数据库的SQL语句不区分大小写。\n4、注释：\n\n单行注释：– 注释内容   或   # 注释内容(MySQL特有)\n多行注释： &#x2F;* 注释内容 *&#x2F;\n\n2.4.2 分类SQL语句根据其功能被分为四大类：DDL、DML、DQL、DCL \n\n\n\n分类\n全称\n说明\n\n\n\nDDL\nData Definition  Language\n数据定义语言，用来定义数据库对象(数据库，表，字段)\n\n\nDML\nData Manipulation  Language\n数据操作语言，用来对数据库表中的数据进行增删改\n\n\nDQL\nData Query Language\n数据查询语言，用来查询数据库中表的记录\n\n\nDCL\nData Control  Language\n数据控制语言，用来创建数据库用户、控制数据库的访问权限\n\n\n\n3.数据库设计-DDL3.1  项目开发流程\n需求文档：\n\n在我们开发一个项目或者项目当中的某个模块之前，会先会拿到产品经理给我们提供的页面原型及需求文档。\n\n设计：\n\n拿到产品原型和需求文档之后，我们首先要做的不是编码，而是要先进行项目的设计，其中就包括概要设计、详细设计、接口设计、数据库设计等等。\n数据库设计根据产品原型以及需求文档，要分析各个模块涉及到的表结构以及表结构之间的关系，以及表结构的详细信息。最终我们需要将数据库以及数据库当中的表结构设计创建出来。\n\n开发&#x2F;测试：\n\n参照页面原型和需求进行编码，实现业务功能。在这个过程当中，我们就需要来操作设计出来的数据库表结构，来完成业务的增删改查操作等。\n\n部署上线：\n\n在项目的功能开发测试完成之后，项目就可以上线运行了，后期如果项目遇到性能瓶颈，还需要对项目进行优化。优化很重要的一个部分就是数据库的优化，包括数据库当中索引的建立、SQL 的优化、分库分表等操作。\n\n在上述的流程当中，针对于数据库来说，主要包括三个阶段：\n\n数据库设计阶段\n参照页面原型以及需求文档设计数据库表结构\n\n\n数据库操作阶段\n根据业务功能的实现，编写SQL语句对数据表中的数据进行增删改查操作\n\n\n数据库优化阶段\n通过数据库的优化来提高数据库的访问性能。优化手段：索引、SQL优化、分库分表等\n\n\n\n3.2 数据库操作我们在进行数据库设计，需要使用到刚才所介绍SQL分类中的DDL语句。\nDDL英文全称是Data Definition Language(数据定义语言)，用来定义数据库对象(数据库、表)。\nDDL中数据库的常见操作：查询、创建、使用、删除。\n3.2.1 查询数据库查询所有数据库：\ntxtshow databases;查询当前数据库：\ntxtselect database();命令行中执行效果如果：\n\n\n\n\n\n\n\n\n\n\n我们要操作某一个数据库，必须要切换到对应的数据库中。 \n通过指令：select  database() ，就可以查询到当前所处的数据库 \n3.2.2 创建数据库语法：\ntxtcreate database [ if not exists ] 数据库名;&#x3D;&#x3D;注意：在同一个数据库服务器中，不能创建两个名称相同的数据库，否则将会报错。&#x3D;&#x3D;\n\n可以使用if not exists来避免这个问题\n\nsql-- 数据库不存在,则创建该数据库；如果存在则不创建\ncreate database if not extists itcast; 3.2.3 使用数据库语法：\ntxtuse 数据库名 ;\n\n\n\n\n\n\n\n\n我们要操作某一个数据库下的表时，就需要通过该指令，切换到对应的数据库下，否则不能操作。\n3.2.4 删除数据库语法：\ntxtdrop database [ if exists ] 数据库名 ;\n\n\n\n\n\n\n\n\n如果删除一个不存在的数据库，将会报错。\n可以加上参数 if exists ，如果数据库存在，再执行删除，否则不执行删除。\n说明：上述语法中的database，也可以替换成 schema\n\n如：create schema db01;\n如：show schemas;\n\n3.3 图形化工具3.3.1 介绍在项目开发当中，通常为了提高开发效率，都会借助于现成的图形化管理工具来操作数据库。\n目前MySQL主流的图形化界面工具有以下几种：\n\nDataGrip是JetBrains旗下的一款数据库管理工具，是管理和开发MySQL、Oracle、PostgreSQL的理想解决方案。\n官网： https://www.jetbrains.com/zh-cn/datagrip/\n3.3.2 安装安装： 参考资料中提供的《DataGrip安装手册》\n\n\n\n\n\n\n\n\n\n说明：DataGrip这款工具可以不用安装，因为Jetbrains公司已经将DataGrip这款工具的功能已经集成到了 IDEA当中，所以我们就可以使用IDEA来作为一款图形化界面工具来操作Mysql数据库。\n3.3.3 使用连接数据库\n1、打开IDEA自带的Database\n\n2、配置MySQL\n\n3、输入相关信息\n \n4、下载MySQL连接驱动\n\n5、测试数据库连接\n\n6、保存配置\n\n创建数据库：\n\n\n查看所有数据库：\n\n\n3.4 表操作关于表结构的操作也是包含四个部分：创建表、查询表、修改表、删除表。\n3.4.1 创建3.4.1.1 语法txtcreate table  表名(\n    字段1  字段1类型 [约束]  [comment  字段1注释 ],\n    字段2  字段2类型 [约束]  [comment  字段2注释 ],\n    ......\n    字段n  字段n类型 [约束]  [comment  字段n注释 ] \n) [ comment  表注释 ] ;\n\n\n\n\n\n\n\n\n注意： [ ] 中的内容为可选参数； 最后一个字段后面没有逗号\n\n建表语句：\n\ntxtcreate table tb_user (\n    id int comment &#39;ID,唯一标识&#39;,   # id是一行数据的唯一标识（不能重复）\n    username varchar(20) comment &#39;用户名&#39;,\n    name varchar(10) comment &#39;姓名&#39;,\n    age int comment &#39;年龄&#39;,\n    gender char(1) comment &#39;性别&#39;\n) comment &#39;用户表&#39;;\n其实我们现在创建表结构的时候， id这个字段我们只加了一个备注信息说明它是一个唯一标识，但是在数据库层面呢，并没有去限制字段存储的数据。所以id这个字段没有起到唯一标识的作用。\n\n\n\n\n\n\n\n\n\n\n想要限制字段所存储的数据，就需要用到数据库中的约束。\n3.4.1.2 约束概念：所谓约束就是作用在表中字段上的规则，用于限制存储在表中的数据。\n作用：就是来保证数据库当中数据的正确性、有效性和完整性。（后面的学习会验证这些）\n在MySQL数据库当中，提供了以下5种约束：\n\n\n\n约束\n描述\n关键字\n\n\n\n非空约束\n限制该字段值不能为null\nnot null\n\n\n唯一约束\n保证字段的所有数据都是唯一、不重复的\nunique\n\n\n主键约束\n主键是一行数据的唯一标识，要求非空且唯一\nprimary key\n\n\n默认约束\n保存数据时，如果未指定该字段值，则采用默认值\ndefault\n\n\n外键约束\n让两张表的数据建立连接，保证数据的一致性和完整性\nforeign key\n\n\n\n\n\n\n\n\n\n\n\n注意：约束是作用于表中字段上的，可以在创建表&#x2F;修改表的时候添加约束。\nid字段下存储的值，如果由我们自己来维护会比较麻烦(必须保证值的唯一性)。MySQL数据库为了解决这个问题，给我们提供了一个关键字：auto_increment（自动增长）\n\n\n\n\n\n\n\n\n\n主键自增：auto_increment\n\n每次插入新的行记录时，数据库自动生成id字段(主键)下的值\n具有auto_increment的数据列是一个正数序列开始增长(从1开始自增)\n\n3.4.1.3 数据类型MySQL中的数据类型有很多，主要分为三类：数值类型、字符串类型、日期时间类型。\n数值类型\n\n\n\n类型\n大小\n有符号(SIGNED)范围\n无符号(UNSIGNED)范围\n描述\n\n\n\nTINYINT\n1byte\n(-128，127)\n(0，255)\n小整数值\n\n\nSMALLINT\n2bytes\n(-32768，32767)\n(0，65535)\n大整数值\n\n\nMEDIUMINT\n3bytes\n(-8388608，8388607)\n(0，16777215)\n大整数值\n\n\nINT&#x2F;INTEGER\n4bytes\n(-2147483648，2147483647)\n(0，4294967295)\n大整数值\n\n\nBIGINT\n8bytes\n(-2^63，2^63-1)\n(0，2^64-1)\n极大整数值\n\n\nFLOAT\n4bytes\n(-3.402823466 E+38，3.402823466351 E+38)\n0 和 (1.175494351  E-38，3.402823466 E+38)\n单精度浮点数值\n\n\nDOUBLE\n8bytes\n(-1.7976931348623157 E+308，1.7976931348623157 E+308)\n0 和  (2.2250738585072014 E-308，1.7976931348623157 E+308)\n双精度浮点数值\n\n\nDECIMAL\n\n依赖于M(精度)和D(标度)的值\n\n\n\n\n字符串类型\n\n\n\n类型\n大小\n描述\n\n\n\nCHAR\n0-255 bytes\n定长字符串(需要指定长度)\n\n\nVARCHAR\n0-65535 bytes\n变长字符串(需要指定长度)\n\n\nTINYBLOB\n0-255 bytes\n不超过255个字符的二进制数据\n\n\nTINYTEXT\n0-255 bytes\n短文本字符串\n\n\nBLOB\n0-65 535 bytes\n二进制形式的长文本数据\n\n\nTEXT\n0-65 535 bytes\n长文本数据\n\n\nMEDIUMBLOB\n0-16 777 215 bytes\n二进制形式的中等长度文本数据\n\n\nMEDIUMTEXT\n0-16 777 215 bytes\n中等长度文本数据\n\n\nLONGBLOB\n0-4 294 967 295 bytes\n二进制形式的极大文本数据\n\n\nLONGTEXT\n0-4 294 967 295 bytes\n极大文本数据\n\n\n日期时间类型\n\n\n\n类型\n大小\n范围\n格式\n描述\n\n\n\nDATE\n3\n1000-01-01 至  9999-12-31\nYYYY-MM-DD\n日期值\n\n\nTIME\n3\n-838:59:59 至  838:59:59\nHH:MM:SS\n时间值或持续时间\n\n\nYEAR\n1\n1901 至 2155\nYYYY\n年份值\n\n\nDATETIME\n8\n1000-01-01 00:00:00 至 9999-12-31 23:59:59\nYYYY-MM-DD HH:MM:SS\n混合日期和时间值\n\n\nTIMESTAMP\n4\n1970-01-01 00:00:01 至 2038-01-19 03:14:07\nYYYY-MM-DD HH:MM:SS\n\n\n\n3.4.1.4 案例使用SQL创建表：\nsqlcreate table emp (\n  id int unsigned primary key auto_increment comment &#39;ID&#39;,\n  username varchar(20) not null unique comment &#39;用户名&#39;,\n  password varchar(32) default &#39;123456&#39; comment &#39;密码&#39;,\n  name varchar(10) not null comment &#39;姓名&#39;,\n  gender tinyint unsigned not null comment &#39;性别, 说明: 1 男, 2 女&#39;,\n  image varchar(300) comment &#39;图像&#39;,\n  job tinyint unsigned comment &#39;职位, 说明: 1 班主任,2 讲师, 3 学工主管, 4 教研主管&#39;,\n  entrydate date comment &#39;入职时间&#39;,\n  create_time datetime not null comment &#39;创建时间&#39;,\n  update_time datetime not null comment &#39;修改时间&#39;\n) comment &#39;员工表&#39;;除了使用SQL语句创建表外，我们还可以借助于图形化界面来创建表结构，这种创建方式会更加直观、更加方便。\n操作步骤如下：\n\n在指定操作的数据库上，右键New &#x3D;&#x3D;&gt; Table\n\n\n\n编辑表结构的相关信息\n\n\n3.4.1.5 设计表流程通过上面的案例，我们明白了，设计一张表，基本的流程如下：\n\n阅读页面原型及需求文档\n\n基于页面原则和需求文档，确定原型字段(类型、长度限制、约束)\n\n再增加表设计所需要的业务基础字段(id主键、插入时间、修改时间)\n\n\n\n\n\n\n\n\n\n\n\n\n说明：\n\ncreate_time：记录的是当前这条数据插入的时间。 \n\nupdate_time：记录当前这条数据最后更新的时间。\n\n\n3.4.2 查询\n\n\n\n\n\n\n\n\n关于表结构的查询操作，工作中一般都是直接基于图形化界面操作。 \n查询当前数据库所有表\ntxtshow tables;查看指定表结构\ntxtdesc 表名 ;#可以查看指定表的字段、字段的类型、是否可以为NULL、是否存在默认值等信息查询指定表的建表语句\ntxtshow create table 表名 ;3.4.3 修改\n\n\n\n\n\n\n\n\n关于表结构的修改操作，工作中一般都是直接基于图形化界面操作。 \n添加字段\nsqlalter table 表名 add  字段名  类型(长度)  [comment 注释]  [约束];修改数据类型\ntxtalter table 表名 modify  字段名  新数据类型(长度);sqlalter table 表名 change  旧字段名  新字段名  类型(长度)  [comment 注释]  [约束];删除字段\nsqlalter table 表名 drop 字段名;修改表名\nsqlrename table 表名 to  新表名;3.4.4 删除删除表语法：\nsqldrop  table [ if exists ]  表名;\n\n\n\n\n\n\n\n\nif exists ：只有表名存在时才会删除该表，表名不存在，则不执行删除操作(如果不加该参数项，删除一张不存在的表，执行将会报错)。\n4.数据库操作-DMLDML英文全称是Data Manipulation Language(数据操作语言)，用来对数据库中表的数据记录进行增、删、改操作。\n\n添加数据（INSERT）\n修改数据（UPDATE）\n删除数据（DELETE）\n\n4.1 添加（insert）insert语法：\n\n向指定字段添加数据\ntxtinsert into 表名 (字段名1, 字段名2) values (值1, 值2);\n全部字段添加数据\ntxtinsert into 表名 values (值1, 值2, ...);\n批量添加数据（指定字段）\ntxtinsert into 表名 (字段名1, 字段名2) values (值1, 值2), (值1, 值2);\n批量添加数据（全部字段）\ntxtinsert into 表名 values (值1, 值2, ...), (值1, 值2, ...);\n\nInsert操作的注意事项：\n\n插入数据时，指定的字段顺序需要与值的顺序是一一对应的。\n\n字符串和日期型数据应该包含在引号中。\n\n插入的数据大小，应该在字段的规定范围内。\n\n\n4.2 修改（update）update语法：\nsqlupdate 表名 set 字段名1 = 值1 , 字段名2 = 值2 , .... [where 条件] ;\n\n\n\n\n\n\n\n\n注意事项:\n\n修改语句的条件可以有，也可以没有，如果没有条件，则会修改整张表的所有数据。\n\n在修改数据时，一般需要同时修改公共字段update_time，将其修改为当前操作时间。\n\n\n4.3 删除（delete）delete语法：\nsqldelete from 表名  [where  条件] ;\n\n\n\n\n\n\n\n\n注意事项:\n​\t• DELETE 语句的条件可以有，也可以没有，如果没有条件，则会删除整张表的所有数据。\n​\t• DELETE 语句不能删除某一个字段的值(可以使用UPDATE，将该字段值置为NULL即可)。\n​\t• 当进行删除全部数据操作时，会提示询问是否确认删除所有数据，直接点击Execute即可。 \n5.数据库操作-DQL5.1 介绍DQL英文全称是Data Query Language(数据查询语言)，用来查询数据库表中的记录。\n查询关键字：SELECT\n查询操作是所有SQL语句当中最为常见，也是最为重要的操作。在一个正常的业务系统中，查询操作的使用频次是要远高于增删改操作的。当我们打开某个网站或APP所看到的展示信息，都是通过从数据库中查询得到的，而在这个查询过程中，还会涉及到条件、排序、分页等操作。\n5.2 语法DQL查询语句，语法结构如下：\ntxtSELECT\n    字段列表\nFROM\n    表名列表\nWHERE\n    条件列表\nGROUP  BY\n    分组字段列表\nHAVING\n    分组后条件列表\nORDER BY\n    排序字段列表\nLIMIT\n    分页参数5.3 基本查询在基本查询的DQL语句中，不带任何的查询条件，语法如下：\n\n查询多个字段\ntxtselect 字段1, 字段2, 字段3 from  表名;\n查询所有字段（通配符）\ntxtselect *  from  表名;\n设置别名\ntxtselect 字段1 [ as 别名1 ] , 字段2 [ as 别名2 ]  from  表名;\n去除重复记录\ntxtselect distinct 字段列表 from  表名;\n\n5.4 条件查询语法：\nsqlselect  字段列表  from   表名   where   条件列表 ; -- 条件列表：意味着可以有多个条件学习条件查询就是学习条件的构建方式，而在SQL语句当中构造条件的运算符分为两类：\n\n比较运算符\n逻辑运算符\n\n常用的比较运算符如下: \n\n\n\n比较运算符\n功能\n\n\n\n&gt;\n大于\n\n\n&gt;&#x3D;\n大于等于\n\n\n&lt;\n小于\n\n\n&lt;&#x3D;\n小于等于\n\n\n&#x3D;\n等于\n\n\n&lt;&gt; 或 !&#x3D;\n不等于\n\n\nbetween …  and …\n在某个范围之内(含最小、最大值)\n\n\nin(…)\n在in之后的列表中的值，多选一\n\n\nlike 占位符\n模糊匹配(_匹配单个字符, %匹配任意个字符)\n\n\nis null\n是null\n\n\n常用的逻辑运算符如下:\n\n\n\n逻辑运算符\n功能\n\n\n\nand 或 &amp;&amp;\n并且 (多个条件同时成立)\n\n\nor 或 ||\n或者 (多个条件任意一个成立)\n\n\nnot 或 !\n非 , 不是\n\n\ntxtselect id, username, password, name, gender, image, job, entrydate, create_time, update_time\nfrom tb_emp\nwhere id &lt;=5;5.5 聚合函数之前我们做的查询都是横向查询，就是根据条件一行一行的进行判断，而使用聚合函数查询就是纵向查询，它是对一列的值进行计算，然后返回一个结果值。（将一列数据作为一个整体，进行纵向计算）\n语法：\ntxtselect  聚合函数(字段列表)  from  表名 ;\n\n\n\n\n\n\n\n\n注意 : 聚合函数会忽略空值，对NULL值不作为统计。\n常用聚合函数：\n\n\n\n函数\n功能\n\n\n\ncount\n统计数量\n\n\nmax\n最大值\n\n\nmin\n最小值\n\n\navg\n平均值\n\n\nsum\n求和\n\n\n\n\n\n\n\n\n\n\n\ncount ：按照列去统计有多少行数据。\n\n在根据指定的列统计的时候，如果这一列中有null的行，该行不会被统计在其中。\n\nsum ：计算指定列的数值和，如果不是数值类型，那么计算结果为0\nmax ：计算指定列的最大值\nmin ：计算指定列的最小值\navg ：计算指定列的平均值\ntxt# count(字段)\nselect count(id) from tb_emp;-- 结果：29\nselect count(job) from tb_emp;-- 结果：28 （聚合函数对NULL值不做计算）\n\n# count(常量)\nselect count(0) from tb_emp;\nselect count(&#39;A&#39;) from tb_emp;\n\n# count(*)  推荐此写法（MySQL底层进行了优化）\nselect count(*) from tb_emp;5.6 分组查询分组： 按照某一列或者某几列，把相同的数据进行合并输出。\n\n\n\n\n\n\n\n\n\n分组其实就是按列进行分类(指定列下相同的数据归为一类)，然后可以对分类完的数据进行合并计算。\n分组查询通常会使用聚合函数进行计算。\n语法：\ntxtselect  字段列表  from  表名  [where 条件]  group by 分组字段名  [having 分组后过滤条件];\n\n\n\n\n\n\n\n\n注意事项:\n​\t• 分组之后，查询的字段一般为聚合函数和分组字段，查询其他字段无任何意义\n​\t• 执行顺序：where &gt; 聚合函数 &gt; having \nwhere与having区别（面试题）\n\n执行时机不同：where是分组之前进行过滤，不满足where条件，不参与分组；而having是分组之后对结果进行过滤。\n判断条件不同：where不能对聚合函数进行判断，而having可以。\n\ntxtselect job, count(*)\nfrom tb_emp\nwhere entrydate &lt;= &#39;2015-01-01&#39;   -- 分组前条件\ngroup by job                      -- 按照job字段分组\nhaving count(*) &gt;= 2;             -- 分组后条件5.7 排序查询排序在日常开发中是非常常见的一个操作，有升序排序，也有降序排序。\n语法：\ntxtselect  字段列表  \nfrom   表名   \n[where  条件列表] \n[group by  分组字段 ] \norder  by  字段1  排序方式1 , 字段2  排序方式2 … ;\n排序方式：\n\nASC ：升序（默认值）\nDESC：降序\n\n\n\n\n\n\n\n\n\n\n\n\n注意事项：如果是多字段排序，当第一个字段值相同时，才会根据第二个字段进行排序 \ntxtselect id, username, password, name, gender, image, job, entrydate, create_time, update_time\nfrom tb_emp\norder by entrydate DESC; -- 按照entrydate字段下的数据进行降序排序5.8 分页查询分页操作在业务系统开发时，也是非常常见的一个功能，日常我们在网站中看到的各种各样的分页条，后台也都需要借助于数据库的分页操作。\n分页查询语法：\nsqlselect  字段列表  from   表名  limit  起始索引, 查询记录数 ;\n\n\n\n\n\n\n\n\n注意事项:\n\n起始索引从0开始。        计算公式 ：   起始索引 &#x3D; （查询页码 - 1）* 每页显示记录数\n分页查询是数据库的方言，不同的数据库有不同的实现，MySQL中是LIMIT\n如果查询的是第一页数据，起始索引可以省略，直接简写为 limit  条数\n\ntxtselect id, username, password, name, gender, image, job, entrydate, create_time, update_time\nfrom tb_emp\nlimit 0 , 5; -- 从索引0开始，向后取5条记录6.多表设计项目开发中，在进行数据库表结构设计时，会根据业务需求及业务模块之间的关系，分析并设计表结构，由于业务之间相互关联，所以各个表结构之间也存在着各种联系，基本上分为三种：\n\n一对多(多对一)\n\n多对多\n\n一对一\n\n\n6.1 一对多员工表 - 部门表之间的关系：\n\n\n\n\n\n\n\n\n\n\n一对多关系实现：在数据库表中多的一方，添加字段，来关联属于一这方的主键。\n外键约束\n目前上述的两张表(员工表、部门表)，在数据库层面，并未建立关联，所以是无法保证数据的一致性和完整性的\n想解决上述的问题呢，我们就可以通过数据库中的 外键约束 来解决。\n\n\n\n\n\n\n\n\n\n外键约束：让两张表的数据建立连接，保证数据的一致性和完整性。  \n对应的关键字：foreign key\n外键约束的语法：\ntxt-- 创建表时指定\ncreate table 表名(\n    字段名    数据类型,\n    ...\n    [constraint]   [外键名称]  foreign  key (外键字段名)   references   主表 (主表列名)\t\n);\n\n\n-- 建完表后，添加外键\nalter table  表名  add constraint  外键名称  foreign key(外键字段名) references 主表(主表列名);方式1：通过SQL语句操作\ntxt-- 修改表： 添加外键约束\nalter table tb_emp  \nadd  constraint  fk_dept_id  foreign key (dept_id)  references  tb_dept(id);方式2：图形化界面操作\n \n\n\n\n\n\n\n\n\n\n当我们添加外键约束时，我们得保证当前数据库表中的数据是完整的。 所以，我们需要将之前删除掉的数据再添加回来。\n\n\n\n\n\n\n\n\n\n当我们添加了外键之后，再删除ID为1的部门，就会发现，此时数据库报错了，不允许删除。\n\n外键约束（foreign key）：保证了数据的完整性和一致性。\n物理外键和逻辑外键\n\n物理外键\n\n概念：使用foreign key定义外键关联另外一张表。\n缺点：\n影响增、删、改的效率（需要检查外键关系）。\n仅用于单节点数据库，不适用与分布式、集群场景。\n容易引发数据库的死锁问题，消耗性能。\n\n\n\n\n逻辑外键\n\n概念：在业务层逻辑中，解决外键关联。\n通过逻辑外键，就可以很方便的解决上述问题。\n\n\n\n\n\n\n\n\n\n\n\n\n**在现在的企业开发中，很少会使用物理外键，都是使用逻辑外键。 甚至在一些数据库开发规范中，会明确指出禁止使用物理外键 foreign key **\n6.2 一对一一对一关系表在实际开发中应用起来比较简单，通常是用来做单表的拆分，也就是将一张大表拆分成两张小表，将大表中的一些基础字段放在一张表当中，将其他的字段放在另外一张表当中，以此来提高数据的操作效率。\n\n\n\n\n\n\n\n\n\n一对一的应用场景： 用户表(基本信息+身份信息)\n\n\n基本信息：用户的ID、姓名、性别、手机号、学历\n身份信息：民族、生日、身份证号、身份证签发机关，身份证的有效期(开始时间、结束时间)\n\n其实一对一我们可以看成一种特殊的一对多。一对多我们是怎么设计表关系的？是不是在多的一方添加外键。同样我们也可以通过外键来体现一对一之间的关系，我们只需要在任意一方来添加一个外键就可以了。\n\n\n\n\n\n\n\n\n\n\n一对一 ：在任意一方加入外键，关联另外一方的主键，并且设置外键为唯一的(UNIQUE)\n6.3 多对多多对多的关系在开发中属于也比较常见的。比如：学生和老师的关系，一个学生可以有多个授课老师，一个授课老师也可以有多个学生。在比如：学生和课程的关系，一个学生可以选修多门课程，一个课程也可以供多个学生选修。\n案例：学生与课程的关系\n\n关系：一个学生可以选修多门课程，一门课程也可以供多个学生选择\n\n实现关系：建立第三张中间表，中间表至少包含两个外键，分别关联两方主键\n\n\n\n7.多表查询7.1 概述多表查询：查询时从多张表中获取所需数据\n\n\n\n\n\n\n\n\n\n单表查询的SQL语句：select  字段列表  from  表名;\n那么要执行多表查询，只需要使用逗号分隔多张表即可，如： select   字段列表  from  表1, 表2;\n查询用户表和部门表中的数据：\ntxtselect * from  tb_emp , tb_dept;此时,我们看到查询结果中包含了大量的结果集，总共85条记录，而这其实就是员工表所有的记录(17行)与部门表所有记录(5行)的所有组合情况，这种现象称之为笛卡尔积。\n笛卡尔积：笛卡尔乘积是指在数学中，两个集合(A集合和B集合)的所有组合情况。\n\n\n\n\n\n\n\n\n\n\n在多表查询时，需要消除无效的笛卡尔积，只保留表关联部分的数据\n\n在SQL语句中，如何去除无效的笛卡尔积呢？只需要给多表查询加上连接查询的条件即可。\ntxtselect * from tb_emp , tb_dept where tb_emp.dept_id = tb_dept.id ;7.2 内连接\n内连接：相当于查询A、B交集部分数据\n\n \n内连接查询：查询两表或多表中交集部分数据。\n内连接从语法上可以分为：\n\n隐式内连接\n\n显式内连接\n\n\n隐式内连接语法：\ntxtselect  字段列表   from   表1 , 表2   where  条件 ... ;显式内连接语法：\ntxtselect  字段列表   from   表1  [ inner ]  join 表2  on  连接条件 ... ;多表查询时给表起别名：\n\ntableA  as  别名1  ,  tableB  as  别名2 ;\ntableA  别名1  ,  tableB  别名2 ;\n\n\n\n\n\n\n\n\n\n\n注意事项:\n一旦为表起了别名，就不能再使用表名来指定对应的字段了，此时只能够使用别名来指定字段。\n\n隐式内连接实现\n\ntxtselect tb_emp.name , tb_dept.name -- 分别查询两张表中的数据\nfrom tb_emp , tb_dept -- 关联两张表\nwhere tb_emp.dept_id = tb_dept.id; -- 消除笛卡尔积\n显式内连接实现\n\ntxtselect tb_emp.name , tb_dept.name\nfrom tb_emp inner join tb_dept\non tb_emp.dept_id = tb_dept.id;7.3 外连接外连接\n\n左外连接：查询左表所有数据(包括两张表交集部分数据)\n\n右外连接：查询右表所有数据(包括两张表交集部分数据)\n\n\n左外连接语法结构：\ntxtselect  字段列表   from   表1  left  [ outer ]  join 表2  on  连接条件 ... ;\n\n\n\n\n\n\n\n\n左外连接相当于查询表1(左表)的所有数据，当然也包含表1和表2交集部分的数据。\n右外连接语法结构：\ntxtselect  字段列表   from   表1  right  [ outer ]  join 表2  on  连接条件 ... ;\n\n\n\n\n\n\n\n\n右外连接相当于查询表2(右表)的所有数据，当然也包含表1和表2交集部分的数据。\n\n\n\n\n\n\n\n\n\n注意事项：\n左外连接和右外连接是可以相互替换的，只需要调整连接查询时SQL语句中表的先后顺序就可以了。而我们在日常开发使用时，更偏向于左外连接。\ntxt-- 左外连接：以left join关键字左边的表为主表，查询主表中所有数据，以及和主表匹配的右边表中的数据\nselect emp.name , dept.name\nfrom tb_emp AS emp left join tb_dept AS dept \n     on emp.dept_id = dept.id;txt-- 右外连接\nselect dept.name , emp.name\nfrom tb_emp AS emp right join  tb_dept AS dept\n     on emp.dept_id = dept.id;7.4 子查询7.4.1 介绍SQL语句中嵌套select语句，称为嵌套查询，又称子查询。\nsqlSELECT  *  FROM   t1   WHERE  column1 =  ( SELECT  column1  FROM  t2 ... );\n\n\n\n\n\n\n\n\n子查询外部的语句可以是insert &#x2F; update &#x2F; delete &#x2F; select 的任何一个，最常见的是 select。\n根据子查询结果的不同分为：\n\n标量子查询（子查询结果为单个值[一行一列]）\n\n列子查询（子查询结果为一列，但可以是多行）\n\n行子查询（子查询结果为一行，但可以是多列）\n\n表子查询（子查询结果为多行多列[相当于子查询结果是一张表]）\n\n\n子查询可以书写的位置：\n\nwhere之后\nfrom之后\nselect之后\n\n7.4.2 标量子查询子查询返回的结果是单个值(数字、字符串、日期等)，最简单的形式，这种子查询称为标量子查询。\n常用的操作符： &#x3D;   &lt;&gt;   &gt;    &gt;&#x3D;    &lt;   &lt;&#x3D;   \ntxt-- 1.查询&quot;教研部&quot;部门ID\nselect id from tb_dept where name = &#39;教研部&#39;;    #查询结果：2\n-- 2.根据&quot;教研部&quot;部门ID, 查询员工信息\nselect * from tb_emp where dept_id = 2;\n\n-- 合并出上两条SQL语句\nselect * from tb_emp where dept_id = (select id from tb_dept where name = &#39;教研部&#39;);7.4.3 列子查询子查询返回的结果是一列(可以是多行)，这种子查询称为列子查询。\n常用的操作符：\n\n\n\n操作符\n描述\n\n\n\nIN\n在指定的集合范围之内，多选一\n\n\nNOT IN\n不在指定的集合范围之内\n\n\ntxt-- 1.查询&quot;销售部&quot;和&quot;市场部&quot;的部门ID\nselect id from tb_dept where name = &#39;教研部&#39; or name = &#39;咨询部&#39;;    #查询结果：3,2\n-- 2.根据部门ID, 查询员工信息\nselect * from tb_emp where dept_id in (3,2);\n\n-- 合并以上两条SQL语句\nselect * from tb_emp where dept_id in (select id from tb_dept where name = &#39;教研部&#39; or name = &#39;咨询部&#39;);7.4.4 行子查询子查询返回的结果是一行(可以是多列)，这种子查询称为行子查询。\n常用的操作符：&#x3D; 、&lt;&gt; 、IN 、NOT IN\ntxt-- 查询&quot;韦一笑&quot;的入职日期 及 职位\nselect entrydate , job from tb_emp where name = &#39;韦一笑&#39;;  #查询结果： 2007-01-01 , 2\n-- 查询与&quot;韦一笑&quot;的入职日期及职位相同的员工信息\nselect * from tb_emp where (entrydate,job) = (&#39;2007-01-01&#39;,2);\n\n-- 合并以上两条SQL语句\nselect * from tb_emp where (entrydate,job) = (select entrydate , job from tb_emp where name = &#39;韦一笑&#39;);7.4.5 表子查询子查询返回的结果是多行多列，常作为临时表，这种子查询称为表子查询。\ntxtselect * from emp where entrydate &gt; &#39;2006-01-01&#39;;\n\nselect e.*, d.* from (select * from emp where entrydate &gt; &#39;2006-01-01&#39;) e left join dept d on e.dept_id = d.id ;8.事务8.1 介绍在实际的业务开发中，有些业务操作要多次访问数据库。一个业务要发送多条SQL语句给数据库执行。需要将多次访问数据库的操作视为一个整体来执行，要么所有的SQL语句全部执行成功。如果其中有一条SQL语句失败，就进行事务的回滚，所有的SQL语句全部执行失败。\n简而言之：事务是一组操作的集合，它是一个不可分割的工作单位。事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。\n事务作用：保证在一个事务中多次操作数据库表中数据时，要么全都成功,要么全都失败。\n8.2 操作MYSQL中有两种方式进行事务的操作：\n\n自动提交事务：即执行一条sql语句提交一次事务。（默认MySQL的事务是自动提交）\n手动提交事务：先开启，再提交\n\n事务操作有关的SQL语句：\n\n\n\nSQL语句\n描述\n\n\n\nstart transaction;  &#x2F;  begin ;\n开启手动控制事务\n\n\ncommit;\n提交事务\n\n\nrollback;\n回滚事务\n\n\n\n\n\n\n\n\n\n\n\n手动提交事务使用步骤：\n\n第1种情况：开启事务  &#x3D;&gt;  执行SQL语句   &#x3D;&gt;  成功  &#x3D;&gt;  提交事务\n第2种情况：开启事务  &#x3D;&gt;  执行SQL语句   &#x3D;&gt;  失败  &#x3D;&gt;  回滚事务\n\n使用事务控制删除部门和删除该部门下的员工的操作：\nsql-- 开启事务\nstart transaction ;\n\n-- 删除学工部\ndelete from tb_dept where id = 1;\n\n-- 删除学工部的员工\ndelete from tb_emp where dept_id = 1;\n上述的这组SQL语句，如果如果执行成功，则提交事务\n\nsql-- 提交事务 (成功时执行)\ncommit ;\n上述的这组SQL语句，如果如果执行失败，则回滚事务\n\nsql-- 回滚事务 (出错时执行)\nrollback ;8.3 四大特性面试题：事务有哪些特性？\n\n原子性（Atomicity）：事务是不可分割的最小单元，要么全部成功，要么全部失败。\n一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态。\n隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。\n持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。\n\n\n\n\n\n\n\n\n\n\n事务的四大特性简称为：ACID\n\n原子性（Atomicity） ：原子性是指事务包装的一组sql是一个不可分割的工作单元，事务中的操作要么全部成功，要么全部失败。\n\n一致性（Consistency）：一个事务完成之后数据都必须处于一致性状态。\n\n\n​\t\t如果事务成功的完成，那么数据库的所有变化将生效。\n​\t\t如果事务执行出现错误，那么数据库的所有变化将会被回滚(撤销)，返回到原始状态。\n\n隔离性（Isolation）：多个用户并发的访问数据库时，一个用户的事务不能被其他用户的事务干扰，多个并发的事务之间要相互隔离。\n\n​\t\t一个事务的成功或者失败对于其他的事务是没有影响。\n\n持久性（Durability）：一个事务一旦被提交或回滚，它对数据库的改变将是永久性的，哪怕数据库发生异常，重启之后数据亦然存在。\n\n9.索引9.1 介绍索引(index)：是帮助数据库高效获取数据的数据结构 。\n\n简单来讲，就是使用索引可以提高查询的效率。\n\ntxt-- 添加索引\ncreate index idx_sku_sn on tb_sku (sn);  #在添加索引时，也需要消耗时间\n\n-- 查询数据（使用了索引）\nselect * from tb_sku where sn = &#39;100000003145008&#39;;优点：\n\n提高数据查询的效率，降低数据库的IO成本。\n通过索引列对数据进行排序，降低数据排序的成本，降低CPU消耗。\n\n缺点：\n\n索引会占用存储空间。\n索引大大提高了查询效率，同时却也降低了insert、update、delete的效率。\n\n9.2 结构MySQL数据库支持的索引结构有很多，如：Hash索引、B+Tree索引、Full-Text索引等。\n我们平常所说的索引，如果没有特别指明，都是指默认的 B+Tree 结构组织的索引。\n在没有了解B+Tree结构前，我们先回顾下之前所学习的树结构：\n\n\n\n\n\n\n\n\n\n二叉查找树：左边的子节点比父节点小，右边的子节点比父节点大\n \n\n\n\n\n\n\n\n\n\n当我们向二叉查找树保存数据时，是按照从大到小(或从小到大)的顺序保存的，此时就会形成一个单向链表，搜索性能会打折扣。\n \n\n\n\n\n\n\n\n\n\n可以选择平衡二叉树或者是红黑树来解决上述问题。（红黑树也是一棵平衡的二叉树）\n\n\n\n\n\n\n\n\n\n\n但是在Mysql数据库中并没有使用二叉搜索数或二叉平衡数或红黑树来作为索引的结构。\n思考：采用二叉搜索树或者是红黑树来作为索引的结构有什么问题？\n\n    答案\n    最大的问题就是在数据量大的情况下，树的层级比较深，会影响检索速度。因为不管是二叉搜索数还是红黑数，一个节点下面只能有两个子节点。此时在数据量大的情况下，就会造成数的高度比较高，树的高度一旦高了，检索速度就会降低。\n\n\n\n\n\n\n\n\n\n\n\n\n\n说明：如果数据结构是红黑树，那么查询1000万条数据，根据计算树的高度大概是23左右，这样确实比之前的方式快了很多，但是如果高并发访问，那么一个用户有可能需要23次磁盘IO，那么100万用户，那么会造成效率极其低下。所以为了减少红黑树的高度，那么就得增加树的宽度，就是不再像红黑树一样每个节点只能保存一个数据，可以引入另外一种数据结构，一个节点可以保存多个数据，这样宽度就会增加从而降低树的高度。这种数据结构例如BTree就满足。\n下面我们来看看B+Tree(多路平衡搜索树)结构中如何避免这个问题：\n\nB+Tree结构：\n\n每一个节点，可以存储多个key（有n个key，就有n个指针）\n节点分为：叶子节点、非叶子节点\n叶子节点，就是最后一层子节点，所有的数据都存储在叶子节点上\n非叶子节点，不是树结构最下面的节点，用于索引数据，存储的的是：key+指针\n\n\n为了提高范围查询效率，叶子节点形成了一个双向链表，便于数据的排序及区间范围查询\n\n\n\n\n\n\n\n\n\n\n拓展：\n非叶子节点都是由key+指针域组成的，一个key占8字节，一个指针占6字节，而一个节点总共容量是16KB，那么可以计算出一个节点可以存储的元素个数：16*1024字节 &#x2F; (8+6)&#x3D;1170个元素。\n\n查看mysql索引节点大小：show global status like ‘innodb_page_size’;    – 节点大小：16384\n\n当根节点中可以存储1170个元素，那么根据每个元素的地址值又会找到下面的子节点，每个子节点也会存储1170个元素，那么第二层即第二次IO的时候就会找到数据大概是：1170*1170&#x3D;135W。也就是说B+Tree数据结构中只需要经历两次磁盘IO就可以找到135W条数据。\n对于第二层每个元素有指针，那么会找到第三层，第三层由key+数据组成，假设key+数据总大小是1KB，而每个节点一共能存储16KB，所以一个第三层一个节点大概可以存储16个元素(即16条记录)。那么结合第二层每个元素通过指针域找到第三层的节点，第二层一共是135W个元素，那么第三层总元素大小就是：135W*16结果就是2000W+的元素个数。\n结合上述分析B+Tree有如下优点：\n\n千万条数据，B+Tree可以控制在小于等于3的高度\n所有的数据都存储在叶子节点上，并且底层已经实现了按照索引进行排序，还可以支持范围查询，叶子节点是一个双向链表，支持从小到大或者从大到小查找\n\n9.3 语法创建索引\ntxtcreate  [ unique ]  index 索引名 on  表名 (字段名,... ) ;查看索引\ntxtshow  index  from  表名;删除索引\ntxtdrop  index  索引名  on  表名;\n\n\n\n\n\n\n\n\n注意事项：\n\n主键字段，在建表时，会自动创建主键索引\n\n添加唯一约束时，数据库实际上会添加唯一索引\n\n\n","slug":"MySQL学习","date":"2024-02-07T09:58:12.000Z","categories_index":"Study","tags_index":"数据库,MySQL","author_index":"Fioransh"},{"id":"2fe7dc1ca97676d4ef7064386a344643","title":"Maven知识点总结","content":"1.初始Maven1.1 什么是MavenMaven是Apache旗下的一个开源项目，是一款用于管理和构建java项目的工具。\n1.2 Maven的作用使用Maven能够做什么：\n\n依赖管理\n统一项目结构\n项目构建\n\n依赖管理：\n\n方便快捷的管理项目依赖的资源(jar包)，避免版本冲突问题\n\n\n当使用maven进行项目依赖(jar包)管理，则很方便的可以解决这个问题。 我们只需要在maven项目的pom.xml文件中，添加一段如下图所示的配置即可实现。\n\n**统一项目结构 : **\n\n提供标准、统一的项目结构\n\n在项目开发中，当你使用不同的开发工具 (如：Eclipse、Idea)，创建项目工程时：\n\n若我们创建的是一个maven工程，是可以帮我们自动生成统一、标准的项目目录结构：\n\n具体的统一结构如下：\n\n\n\n\n\n\n\n\n\n\n目录说明： \n\nsrc&#x2F;main&#x2F;java: java源代码目录\nsrc&#x2F;main&#x2F;resources:  配置文件信息\nsrc&#x2F;test&#x2F;java: 测试代码\nsrc&#x2F;test&#x2F;resources: 测试配置文件信息\n\n项目构建 : \n\nmaven提供了标准的、跨平台(Linux、Windows、MacOS) 的自动化项目构建方式\n\n代码需要进行编译、测试、打包、发布，这些操作如果需要反复进行就显得特别麻烦，而Maven提供了一套简单的命令来完成项目构建。\n\n2.Maven概述2.1 Maven介绍Apache Maven是一个项目管理和构建工具，它基于项目对象模型(Project Object Model , 简称: POM)的概念，通过一小段描述信息来管理项目的构建、报告和文档。\n官网：https://maven.apache.org/\nMaven的作用： \n\n方便的依赖管理\n统一的项目结构\n标准的项目构建流程\n\n2.2 Maven模型\n项目对象模型 (Project Object Model)\n依赖管理模型(Dependency)\n构建生命周期&#x2F;阶段(Build lifecycle &amp; phases)\n\n\n2.3 Maven仓库仓库：用于存储资源，管理各种jar包\n\n\n\n\n\n\n\n\n\n仓库的本质就是一个目录(文件夹)，这个目录被用来存储开发中所有依赖(就是jar包)和插件\nMaven仓库分为：\n\n本地仓库：自己计算机上的一个目录(用来存储jar包)\n中央仓库：由Maven团队维护的全球唯一的。仓库地址：https://repo1.maven.org/maven2/\n远程仓库(私服)：一般由公司团队搭建的私有仓库\n\n当项目中使用坐标引入对应依赖jar包后，首先会查找本地仓库中是否有对应的jar包\n\n如果有，则在项目直接引用\n\n如果没有，则去中央仓库中下载对应的jar包到本地仓库\n\n\n如果还可以搭建远程仓库(私服)，将来jar包的查找顺序则变为： 本地仓库 –&gt; 远程仓库–&gt; 中央仓库\n2.4 Maven安装下载地址：https://maven.apache.org/download.cgi\nMaven安装配置步骤：\n\n解压安装\n配置仓库\n配置Maven环境变量\n\n1、解压 apache-maven-3.6.1-bin.zip（解压即安装）\n\nbin目录 ： 存放的是可执行命令。（mvn 命令重点关注）\nconf目录 ：存放Maven的配置文件。（settings.xml配置文件后期需要修改）\nlib目录 ：存放Maven依赖的jar包。（Maven也是使用java开发的，所以它也依赖其他的jar包）\n\n2、配置本地仓库\n在自己计算机上新一个目录（本地仓库，用来存储jar包）\n进入到conf目录下修改settings.xml配置文件 \n1). 使用超级记事本软件，打开settings.xml文件，定位到53行\n2). 复制标签，粘贴到注释的外面（55行）\n3). 复制之前新建的用来存储jar包的路径，替换掉标签体内容\n3、配置阿里云私服\n由于中央仓库在国外，所以下载jar包速度可能比较慢，而阿里公司提供了一个远程仓库，里面基本也都有开源项目的jar包。\n进入到conf目录下修改settings.xml配置文件：\n1). 使用超级记事本软件，打开settings.xml文件，定位到160行左右\n2). 在&#x2F;标签下为其添加子标签&#x2F;，内容如下：\nxml&lt;mirror&gt;  \n    &lt;id&gt;alimaven&lt;/id&gt;  \n    &lt;name&gt;aliyun maven&lt;/name&gt;  \n    &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt;\n    &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;          \n&lt;/mirror&gt;&#x3D;&#x3D;注:  只可配置一个(另一个要注释!) ，不然两个可能发生冲突，导致jar包无法下载!!!!!!!&#x3D;&#x3D;\n4、配置环境变量\n1). 在系统变量处新建一个变量MAVEN_HOME\n\nMAVEN_HOME环境变量的值，设置为maven的解压安装目录\n\n2). 在Path中进行配置\n\nPATH环境变量的值，设置为：%MAVEN_HOME%\\bin\n\n3). 打开DOS命令提示符进行验证，出现如图所示表示安装成功\ntxtmvn -v3. IDEA集成Maven3.1 配置Maven环境1、选择 IDEA中 File  &#x3D;&gt;  Settings  &#x3D;&gt;  Build,Execution,Deployment  &#x3D;&gt;  Build Tools  &#x3D;&gt;  Maven\n\n2、设置IDEA使用本地安装的Maven，并修改配置文件及本地仓库路径\n\n\n\n\n\n\n\n\n\n\nMaven home path ：指定当前Maven的安装目录\nUser settings file ：指定当前Maven的settings.xml配置文件的存放路径\nLocal repository ：指定Maven的本地仓库的路径 (如果指定了settings.xml, 这个目录会自动读取出来, 可以不用手动指定)\n3、配置工程的编译版本为11\n\nMaven默认使用的编译版本为5（版本过低）\n\n\n3.2 全局设置1、进入到IDEA欢迎页面\n\n选择 IDEA中 File  &#x3D;&gt;  close project\n\n2、打开 All settings , 选择 Build,Execution,Deployment  &#x3D;&gt;  Build Tools  &#x3D;&gt;  Maven\n3、配置工程的编译版本为11\n这里所设置的maven的环境信息，并未指定任何一个project，此时设置的信息就属于全局配置信息。 以后，我们再创建project，默认就是使用我们全局配置的信息。\n3.3 Maven项目1、创建一个空项目 \n\n2、创建模块，选择Maven，点击Next\n\n\n3、填写模块名称，坐标信息，点击finish，创建完成\n\n4、在Maven工程下，创建HelloWorld类\n\n\n5、编写 HelloWorld，并运行\njavapublic class HelloWorld &#123;\n    public static void main(String[] args) &#123;\n        System.out.println(&quot;Hello Maven ...&quot;);\n    &#125;\n&#125;\n\n\n\n\n\n\n\n\n\nMaven项目的目录结构:\nmaven-project01|—  src  (源代码目录和测试代码目录)        |—  main (源代码目录)                   |— java (源代码java文件目录)                   |— resources (源代码配置文件目录)        |—  test (测试代码目录)                   |— java (测试代码java目录)                   |— resources (测试代码配置文件目录)|— target (编译、打包生成文件存放目录)\n\n\n3.4 POM配置POM (Project Object Model) ：指的是项目对象模型，用来描述当前的maven项目。\n\n使用pom.xml文件来实现\n\npom文件详解：\n\n ：pom文件的根标签，表示当前maven项目\n ：声明项目描述遵循哪一个POM模型版本\n虽然模型本身的版本很少改变，但它仍然是必不可少的。目前POM模型版本是4.0.0\n\n\n坐标 ：、、\n定位项目在本地仓库中的位置，由以上三个标签组成一个坐标\n\n\n ：maven项目的打包方式，通常设置为jar或war（默认值：jar）\n\n3.5 Maven坐标什么是坐标？\n\nMaven中的坐标是&#x3D;&#x3D;资源的唯一标识&#x3D;&#x3D; , 通过该坐标可以唯一定位资源位置\n使用坐标来定义项目或引入项目中需要的依赖\n\nMaven坐标主要组成\n\ngroupId：定义当前Maven项目隶属组织名称（通常是域名反写，例如：com.itheima）\n\nartifactId：定义当前Maven项目名称（通常是模块名称，例如 order-service、goods-service）\n\nversion：定义当前项目版本号\n\n注意：\n\n上面所说的资源可以是插件、依赖、当前项目。\n我们的项目如果被其他的项目依赖时，也是需要坐标来引入的。\n\n\n\n3.6 导入Mavem项目\n方式1：使用Maven面板，快速导入项目\n\n打开IDEA，选择右侧Maven面板，点击 + 号，选中对应项目的pom.xml文件，双击即可\n说明：如果没有Maven面板，选择 View  &#x3D;&gt;  Appearance  &#x3D;&gt;  Tool Window Bars\n\n方式2：使用idea导入模块项目\n\nFile  &#x3D;&gt;  Project Structure  &#x3D;&gt;  Modules  &#x3D;&gt;  +  &#x3D;&gt;  Import Module\n找到要导入工程的pom.xml\n4.依赖管理4.1 依赖配置依赖：指当前项目运行所需要的jar包。一个项目中可以引入多个依赖：\n例如：在当前工程中，我们需要用到logback来记录日志，此时就可以在maven工程的pom.xml文件中，引入logback的依赖。具体步骤如下：\n\n在pom.xml中编写标签\n在标签中使用引入坐标\n定义坐标的 groupId、artifactId、version\n点击刷新按钮，引入最新加入的坐标\n\n\n刷新依赖：保证每一次引入新的依赖，或者修改现有的依赖配置，都可以加入最新的坐标\n\n注意事项：\n\n如果引入的依赖，在本地仓库中不存在，将会连接远程仓库 &#x2F; 中央仓库，然后下载依赖（这个过程会比较耗时，耐心等待）\n如果不知道依赖的坐标信息，可以到mvn的中央仓库（https://mvnrepository.com/）中搜索\n\n添加依赖的几种方式：\n\n利用中央仓库搜索的依赖坐标\n利用IDEA工具搜索依赖\n熟练上手maven后，快速导入依赖\n\n4.2 依赖传递依赖传递可以分为：\n\n直接依赖：在当前项目中通过依赖配置建立的依赖关系\n\n间接依赖：被依赖的资源如果依赖其他资源，当前项目间接依赖其他资源\n\n\n\n比如以上图中：\n\nprojectA依赖了projectB。对于projectA 来说，projectB 就是直接依赖。\n而projectB依赖了projectC及其他jar包。 那么此时，在projectA中也会将projectC的依赖传递下来。对于projectA 来说，projectC就是间接依赖。\n\n在pom.xml文件中只添加了logback-classic依赖，但由于maven的依赖具有传递性，所以会自动把所依赖的其他jar包也一起导入。\n4.3 排除依赖问题：之前我们讲了依赖具有传递性。那么A依赖B，B依赖C，如果A不想将C依赖进来，是否可以做到？ \n答案：在maven项目中，我们可以通过排除依赖来实现。\n什么是排除依赖？\n\n排除依赖：指主动断开依赖的资源。（被排除的资源无需指定版本）\n\nxml&lt;dependency&gt;\n    &lt;groupId&gt;com.itheima&lt;/groupId&gt;\n    &lt;artifactId&gt;maven-projectB&lt;/artifactId&gt;\n    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;\n   \n    &lt;!--排除依赖, 主动断开依赖的资源--&gt;\n    &lt;exclusions&gt;\n        &lt;exclusion&gt;\n            &lt;groupId&gt;junit&lt;/groupId&gt;\n            &lt;artifactId&gt;junit&lt;/artifactId&gt;\n        &lt;/exclusion&gt;\n    &lt;/exclusions&gt;\n&lt;/dependency&gt;4.4 依赖范围在项目中导入依赖的jar包后，默认情况下，可以在任何地方使用。\n\n如果希望限制依赖的使用范围，可以通过标签设置其作用范围。\n\n作用范围：\n\n主程序范围有效（main文件夹范围内）\n\n测试程序范围有效（test文件夹范围内）\n\n是否参与打包运行（package指令范围内）\n\n\nscope标签的取值范围：\n\n\n\nscope值\n主程序\n测试程序\n打包（运行）\n范例\n\n\n\ncompile（默认）\nY\nY\nY\nlog4j\n\n\ntest\n-\nY\n-\njunit\n\n\nprovided\nY\nY\n-\nservlet-api\n\n\nruntime\n-\nY\nY\njdbc驱动\n\n\n4.5 生命周期Maven的生命周期就是为了对所有的构建过程进行抽象和统一。 描述了一次项目构建，经历哪些阶段。\nMaven从大量项目和构建工具中学习和反思，然后总结了一套高度完美的，易扩展的项目构建生命周期。这个生命周期包含了项目的清理，初始化，编译，测试，打包，集成测试，验证，部署和站点生成等几乎所有构建步骤。\nMaven对项目构建的生命周期划分为3套（相互独立）：\n\nclean：清理工作。\n\ndefault：核心工作。如：编译、测试、打包、安装、部署等。\n\nsite：生成报告、发布站点等。\n\n\n\n• clean：移除上一次构建生成的文件\n• compile：编译项目源代码\n• test：使用合适的单元测试框架运行测试(junit)\n• package：将编译后的文件打包，如：jar、war等\n• install：安装项目到本地仓库\nMaven的生命周期是抽象的，这意味着生命周期本身不做任何实际工作。在Maven的设计中，实际任务（如源代码编译）都交由插件来完成。\nIDEA工具为了方便程序员使用maven生命周期，在右侧的maven工具栏中，已给出快速访问通道\n\n生命周期的顺序是：clean –&gt; validate –&gt; compile –&gt; test –&gt; package –&gt; verify –&gt; install –&gt; site –&gt; deploy \n我们需要关注的就是：clean –&gt;  compile –&gt; test –&gt; package  –&gt; install \n4.6 执行\n在日常开发中，当我们要执行指定的生命周期时，有两种执行方式：\n\n在idea工具右侧的maven工具栏中，选择对应的生命周期，双击执行\n在DOS命令行中，通过maven命令执行\n\n方式一：在idea中执行生命周期\n\n选择对应的生命周期，双击执行\n\n\ntest：\n\npackage：\n\ninstall：\n\nclean：\n\n方式二：在命令行中执行生命周期\n\n进入到DOS命令行\n\n\n \n5.其他5.1 更新依赖索引有时候给idea配置完maven仓库信息后，在idea中依然搜索不到仓库中的jar包。这是因为仓库中的jar包索引尚未更新到idea中。这个时候我们就需要更新idea中maven的索引了，具体做法如下：\n 打开设置—-搜索maven—-Repositories—-选中本地仓库—–点击Update\n\n5.2 清理maven仓库初始情况下，我们的本地仓库是没有任何jar包的，此时会从私服去下载（如果没有配置，就直接从中央仓库去下载），可能由于网络的原因，jar包下载不完全，这些不完整的jar包都是以lastUpdated结尾。此时，maven不会再重新帮你下载，需要你删除这些以lastUpdated结尾的文件，然后maven才会再次自动下载这些jar包。\n\n如果本地仓库中有很多这样的以lastUpadted结尾的文件，可以定义一个批处理文件，在其中编写如下脚本来删除： \ntxtset REPOSITORY_PATH=E:\\develop\\apache-maven-3.6.1\\mvn_repo\nrem 正在搜索...\n\ndel /s /q %REPOSITORY_PATH%\\*.lastUpdated\n\nrem 搜索完毕\npause操作步骤如下：\n1). 定义批处理文件del_lastUpdated.bat  (直接创建一个文本文件，命名为del_lastUpdated，后缀名直接改为bat即可 )\n \n2). 在上面的bat文件上右键—》编辑 。修改文件：\n \n修改完毕后，双击运行即可删除maven仓库中的残留文件。\n6.Maven高级Maven高级内容包括:\n\n分模块设计与开发\n继承与聚合\n私服\n\n6.1 分模块设计与开发所谓分模块设计，顾名思义指的就是我们在设计一个 Java 项目的时候，将一个 Java 项目拆分成多个模块进行开发。\n1). 未分模块设计的问题 \n如果项目不分模块，也就意味着所有的业务代码是不是都写在这一个 Java 项目当中。随着这个项目的业务扩张，项目当中的业务功能可能会越来越多。\n总结起来，主要两点问题：不方便项目的维护和管理、项目中的通用组件难以复用。\n2). 分模块设计\n分模块设计我们在进行项目设计阶段，就可以将一个大的项目拆分成若干个模块，每一个模块都是独立的。\n分模块设计就是将项目按照功能&#x2F;结构拆分成若干个子模块，方便项目的管理维护、拓展，也方便模块键的相互调用、资源共享。\n注意：分模块开发需要先针对模块功能进行设计，再进行编码。不会先将工程开发完毕，然后进行拆分。\n例子：\n1.创建maven模块 tlias-pojo，存放实体类\nA. 创建一个正常的Maven模块，模块名tlias-pojo\nB. 然后在tlias-pojo中创建一个包 com.itheima.pojo (和原来案例项目中的pojo包名一致)\nC. 将原来案例项目 tlias-web-management 中的pojo包下的实体类，复制到tlias-pojo模块中\nD. 在 tlias-pojo 模块的pom.xml文件中引入依赖\nE. 删除原有案例项目tlias-web-management的pojo包【直接删除不要犹豫，我们已经将该模块拆分出去了】，然后在pom.xml中引入 tlias-pojo的依赖\n2. 创建Maven模块 tlias-utils，存放相关工具类\nA. 创建一个正常的Maven模块，模块名tlias-utils\nB. 然后在 tlias-utils 中创建一个包 com.itheima.utils (和原来案例项目中的utils包名一致)\nC. 将原来案例项目 tlias-web-management 中的utils包下的实体类，复制到tlias-utils模块中\nD. 在 tlias-utils 模块的pom.xml文件中引入依赖\nE. 删除原有案例项目tlias-web-management的utils包【直接删除不要犹豫，我们已经将该模块拆分出去了】，然后在pom.xml中引入 tlias-utils的依赖\n到此呢，就已经完成了模块的拆分，拆分出了 tlias-pojo、tlias-utils、tlias-web-management ，如果其他项目中需要用到 pojo，或者 utils工具类，就可以直接引入依赖。 \n\n\n\n\n\n\n\n\n\n1). 什么是分模块设计：将项目按照功能拆分成若干个子模块\n\n\n\n\n\n\n\n\n\n2). 为什么要分模块设计：方便项目的管理维护、扩展，也方便模块间的相互调用，资源共享\n\n\n\n\n\n\n\n\n\n3). 注意事项：分模块设计需要先针对模块功能进行设计，再进行编码。不会先将工程开发完毕，然后进行拆分\n6.2 继承\n概念：继承描述的是两个工程间的关系，与java中的继承相似，子工程可以继承父工程中的配置信息，常见于依赖关系的继承。\n\n作用：简化依赖配置、统一管理依赖\n\n实现：\nxml&lt;parent&gt;\n    &lt;groupId&gt;...&lt;/groupId&gt;\n    &lt;artifactId&gt;...&lt;/artifactId&gt;\n    &lt;version&gt;...&lt;/version&gt;\n    &lt;relativePath&gt;....&lt;/relativePath&gt;\n&lt;/parent&gt;\n\n\n1). 创建maven模块 tlias-parent ，该工程为父工程，设置打包方式pom(默认jar)。\n工程结构如下：\n\n父工程tlias-parent的pom.xml文件配置如下：\nxml&lt;parent&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;\n    &lt;version&gt;2.7.5&lt;/version&gt;\n    &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;\n&lt;/parent&gt;\n\n&lt;groupId&gt;com.itheima&lt;/groupId&gt;\n&lt;artifactId&gt;tlias-parent&lt;/artifactId&gt;\n&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;\n&lt;packaging&gt;pom&lt;/packaging&gt;\n\n\n\n\n\n\n\n\nMaven打包方式：\n\njar：普通模块打包，springboot项目基本都是jar包（内嵌tomcat运行）\nwar：普通web程序打包，需要部署在外部的tomcat服务器中运行\npom：父工程或聚合工程，该模块不写代码，仅进行依赖管理\n\n2). 在子工程的pom.xml文件中，配置继承关系。\nxml&lt;parent&gt;\n    &lt;groupId&gt;com.itheima&lt;/groupId&gt;\n    &lt;artifactId&gt;tlias-parent&lt;/artifactId&gt;\n    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;\n    &lt;relativePath&gt;../tlias-parent/pom.xml&lt;/relativePath&gt;\n&lt;/parent&gt;\n\n&lt;artifactId&gt;tlias-utils&lt;/artifactId&gt;\n&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;这里是以 tlias-utils 为例，指定了其父工程。其他的模块，都是相同的配置方式。\n\n\n\n\n\n\n\n\n\n注意：\n\n在子工程中，配置了继承关系之后，坐标中的groupId是可以省略的，因为会自动继承父工程的 。\nrelativePath指定父工程的pom文件的相对位置（如果不指定，将从本地仓库&#x2F;远程仓库查找该工程）。\n..&#x2F; 代表的上一级目录\n\n\n\n3). 在父工程中配置各个工程共有的依赖（子工程会自动继承父工程的依赖）。\nxml&lt;dependencies&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;\n        &lt;artifactId&gt;lombok&lt;/artifactId&gt;\n        &lt;version&gt;1.18.24&lt;/version&gt;\n    &lt;/dependency&gt;\n&lt;/dependencies&gt;此时，我们已经将各个子工程中共有的依赖（lombok），都定义在了父工程中，子工程中的这一项依赖，就可以直接删除了。删除之后，我们会看到父工程中配置的依赖 lombok，子工程直接继承下来了。\n \n\n\n\n\n\n\n\n\n\n工程结构说明：\n\n我们当前的项目结构为：\n \n因为我们是项目开发完毕之后，给大家基于现有项目拆分的各个模块，tlias-web-management已经存在了，然后再创建各个模块与父工程，所以父工程与模块之间是平级的。\n\n而实际项目中，可能还会见到下面的工程结构：\n \n而在真实的企业开发中，都是先设计好模块之后，再开始创建模块，开发项目。 那此时呢，一般都会先创建父工程 tlias-parent，然后将创建的各个子模块，都放在父工程parent下面。 这样层级结构会更加清晰一些。 \nPS：上面两种工程结构，都是可以正常使用的，没有一点问题。 只不过，第二种结构，看起来，父子工程结构更加清晰、更加直观。\n\n\n版本锁定\n那假如说，我们项目要升级，要使用到jwt最新版本 0.9.2 中的一个新功能，那此时需要将依赖的版本升级到0.9.2，那此时该怎么做呢 ？\n第一步：去找当前项目中所有的模块的pom.xml配置文件，看哪些模块用到了jwt的依赖。\n第二步：找到这个依赖之后，将其版本version，更换为 0.9.2。\n问题：如果项目拆分的模块比较多，每一次更换版本，我们都得找到这个项目中的每一个模块，一个一个的更改。 很容易就会出现，遗漏掉一个模块，忘记更换版本的情况。\n那我们又该如何来解决这个问题，如何来统一管理各个依赖的版本呢？ \n答案：Maven的版本锁定功能。\n在maven中，可以在父工程的pom文件中通过 &lt;dependencyManagement&gt; 来统一管理依赖版本。\n父工程：\nxml&lt;!--统一管理依赖版本--&gt;\n&lt;dependencyManagement&gt;\n    &lt;dependencies&gt;\n        &lt;!--JWT令牌--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;\n            &lt;artifactId&gt;jjwt&lt;/artifactId&gt;\n            &lt;version&gt;0.9.1&lt;/version&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n&lt;/dependencyManagement&gt;子工程：\nxml&lt;dependencies&gt;\n    &lt;!--JWT令牌--&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;\n        &lt;artifactId&gt;jjwt&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n&lt;/dependencies&gt;\n\n\n\n\n\n\n\n\n注意：\n\n在父工程中所配置的 &lt;dependencyManagement&gt; 只能统一管理依赖版本，并不会将这个依赖直接引入进来。 这点和 &lt;dependencies&gt; 是不同的。\n\n子工程要使用这个依赖，还是需要引入的，只是此时就无需指定 &lt;version&gt; 版本号了，父工程统一管理。变更依赖版本，只需在父工程中统一变更。\n\n\n接下来，我们就可以将tlias-utils模块中单独配置的依赖，将其版本统一交给 tlias-parent 进行统一管理。\n如果依赖的版本已经在父工程进行了统一管理，所以在子工程中就无需再配置依赖的版本了。\n我们也可以通过自定义属性及属性引用的形式，在父工程中将依赖的版本号进行集中管理维护。 \n版本集中管理之后，我们要想修改依赖的版本，就只需要在父工程中自定义属性的位置，修改对应的属性值即可。\n\n\n\n\n\n\n\n\n\n面试题：&lt;dependencyManagement&gt; 与 &lt;dependencies&gt; 的区别是什么?\n\n&lt;dependencies&gt; 是直接依赖，在父工程配置了依赖，子工程会直接继承下来。 \n&lt;dependencyManagement&gt; 是统一管理依赖版本，不会直接依赖，还需要在子工程中引入所需依赖(无需指定版本)\n\n6.3 聚合分模块设计与开发之后啊，我们的项目被拆分为多个模块，而模块之间的关系，可能错综复杂。 那就比如我们当前的案例项目，结构如下（相对还是比较简单的）：\n\n\n那此时，大家试想一下，如果开发一个大型项目，拆分的模块很多，模块之间的依赖关系错综复杂，那此时要进行项目的打包、安装操作，是非常繁琐的。 而我们接下来，要讲解的maven的聚合就是来解决这个问题的，通过maven的聚合就可以轻松实现项目的一键构建（清理、编译、测试、打包、安装等）。\n \n\n\n聚合：将多个模块组织成一个整体，同时进行项目的构建。\n聚合工程：一个不具有业务功能的“空”工程（有且仅有一个pom文件） 【PS：一般来说，继承关系中的父工程与聚合关系中的聚合工程是同一个】\n作用：快速构建项目（无需根据依赖关系手动构建，直接在聚合工程上构建即可）\n\n在maven中，我们可以在聚合工程中通过 &lt;moudules&gt; 设置当前聚合工程所包含的子模块的名称。我们可以在 tlias-parent中，添加如下配置，来指定当前聚合工程，需要聚合的模块：\njava&lt;!--聚合其他模块--&gt;\n&lt;modules&gt;\n    &lt;module&gt;../tlias-pojo&lt;/module&gt;\n    &lt;module&gt;../tlias-utils&lt;/module&gt;\n    &lt;module&gt;../tlias-web-management&lt;/module&gt;\n&lt;/modules&gt;那此时，我们要进行编译、打包、安装操作，就无需在每一个模块上操作了。只需要在聚合工程上，统一进行操作就可以了。\n继承与聚合对比\n\n作用\n\n聚合用于快速构建项目\n\n继承用于简化依赖配置、统一管理依赖\n\n\n\n相同点：\n\n聚合与继承的pom.xml文件打包方式均为pom，通常将两种关系制作到同一个pom文件中\n\n聚合与继承均属于设计型模块，并无实际的模块内容\n\n\n\n不同点：\n\n聚合是在聚合工程中配置关系，聚合可以感知到参与聚合的模块有哪些\n\n继承是在子模块中配置关系，父模块无法感知哪些子模块继承了自己\n\n\n\n\n6.4 私服私服其实就是架设在公司局域网内部的一台服务器，就是一种特殊的远程仓库。\n有了私服之后，各个团队就可以直接来连接私服了。 A 连接上私服之后，他就可以把jar包直接上传到私服当中。我公司自己内部搭建的服务器，我是不是有权限操作呀，把jar包上传到私服之后，我让 B 团队的所有开发人员也连接同一台私服。连接上这一台私服之后，他就会根据坐标的信息，直接从私服当中将对应的jar包下载到自己的本地仓库，这样就可以使用到依赖当中所提供的一些工具类了。这样我们就可以通过私服来完成资源的共享。\n\n私服：是一种特殊的远程仓库，它是架设在局域网内的仓库服务，用来代理位于外部的中央仓库，用于解决团队内部的资源共享与资源同步问题。\n依赖查找顺序：\n本地仓库\n私服仓库\n中央仓库\n\n\n注意事项：私服在企业项目开发中，一个项目&#x2F;公司，只需要一台即可（无需我们自己搭建，会使用即可）。\n\n资源的上传与下载\n资源上传与下载，我们需要做三步配置，执行一条指令。\n第一步配置：在maven的配置文件中配置访问私服的用户名、密码。\n第二步配置：在maven的配置文件中配置连接私服的地址(url地址)。\n第三步配置：在项目的pom.xml文件中配置上传资源的位置(url地址)。\n配置好了上述三步之后，要上传资源到私服仓库，就执行执行maven生命周期：deploy。\n\n\n\n\n\n\n\n\n\n私服仓库说明：\n\nRELEASE：存储自己开发的RELEASE发布版本的资源。\nSNAPSHOT：存储自己开发的SNAPSHOT发布版本的资源。\nCentral：存储的是从中央仓库下载下来的依赖。\n\n\n\n\n\n\n\n\n\n\n项目版本说明：\n\nRELEASE(发布版本)：功能趋于稳定、当前更新停止，可以用于发行的版本，存储在私服中的RELEASE仓库中。\nSNAPSHOT(快照版本)：功能不稳定、尚处于开发中的版本，即快照版本，存储在私服的SNAPSHOT仓库中。\n\n1.设置私服的访问用户名&#x2F;密码（在自己maven安装目录下的conf&#x2F;settings.xml中的servers中配置）\n2.设置私服依赖下载的仓库组地址（在自己maven安装目录下的conf&#x2F;settings.xml中的mirrors、profiles中配置）\n3.IDEA的maven工程的pom文件中配置上传（发布）地址(直接在tlias-parent中配置发布地址)\n配置完成之后，我们就可以在tlias-parent中执行deploy生命周期，将项目发布到私服仓库中。 \n","slug":"Maven学习","date":"2024-02-05T14:33:12.000Z","categories_index":"Study","tags_index":"Java,Maven","author_index":"Fioransh"},{"id":"186ee7c09be0c58bb704d8a02925d69c","title":"Javaweb前端速通","content":"Javaweb前端速通1.前端开发介绍前端开发，主要的职责就是将数据以好看的样式呈现出来。说白了，就是开发网页程序。\n2.web标准Web标准也称为网页标准，由一系列的标准组成，大部分由W3C（ World Wide Web Consortium，万维网联盟）负责制定。由三个组成部分：\n\nHTML：负责网页的结构（页面元素和内容）。\n\nCSS：负责网页的表现（页面元素的外观、位置等页面样式，如：颜色、大小等）。\n\nJavaScript：负责网页的行为（交互效果）。\n\n\n随着技术的发展，我们为了更加快速的开发，现在也出现了很多前端开发的高级技术。例如：vue、elementui、Axios等等。\n3.HTML&amp;CSSHTML&amp;CSS基本学习同前端知识点总结一文\n**HTML: **HyperText Markup Language，超文本标记语言。\n\n超文本：超越了文本的限制，比普通文本更强大。除了文字信息，还可以定义图片、音频、视频等内容。\n\n标记语言：由标签构成的语言\n\n\nCSS: Cascading Style Sheet，层叠样式表，用于控制页面的样式（表现）。\n盒子模型：\n\n盒子：页面中所有的元素（标签），都可以看做是一个 盒子，由盒子将页面中的元素包含在一个矩形区域内，通过盒子的视角更方便的进行页面布局\n盒子模型组成：内容区域（content）、内边距区域（padding）、边框区域（border）、外边距区域（margin）\n\n4.文档查阅文档地址: https://www.w3school.com.cn/index.html\n5.JavaScript通过代码&#x2F;js效果演示提供资料进行效果演示，通过浏览器打开，我们点击主题5按钮，页面的主题发生了变化，所以js可以让我们的页面更加的智能，让页面和用户进行交互。\n5.1 引入方式第一种方式：内部脚本，将JS代码定义在HTML页面中\n\nJavaScript代码必须位于&lt;script&gt;&lt;&#x2F;script&gt;标签之间\n在HTML文档中，可以在任意地方，放置任意数量的&lt;script&gt;\n一般会把脚本置于&lt;body&gt;元素的底部，可改善显示速度\n\n第二种方式：外部脚本将， JS代码定义在外部 JS文件中，然后引入到 HTML页面中\n\n外部JS文件中，只包含JS代码，不包含&amp;ltscript&gt;标签\n引入外部js的&lt;script&gt;标签，必须是双标签\n\n5.2 语法基础语法：\n\n区分大小写：与 Java 一样，变量名、函数名以及其他一切东西都是区分大小写的\n\n每行结尾的分号可有可无\n\n大括号表示代码块\n\n\n\n\n\napi\n描述\n\n\n\nwindow.alert()\n警告框\n\n\ndocument.write()\n在HTML 输出内容\n\n\nconsole.log()\n写入浏览器控制台\n\n\n\n\n\n关键字\n解释\n\n\n\nvar\n早期ECMAScript5中用于变量声明的关键字\n\n\nlet\nECMAScript6中新增的用于变量声明的关键字，相比较var，let只在代码块内生效\n\n\nconst\n声明常量的，常量一旦声明，不能修改\n\n\n\nJavaScript 是一门弱类型语言，变量可以存放不同类型的值 。\n变量名需要遵循如下规则：\n组成字符可以是任何字母、数字、下划线（_）或美元符号（$）\n数字不能开头\n建议使用驼峰命名\n\n\n\n\n\n\n数据类型\n描述\n\n\n\nnumber\n数字（整数、小数、NaN(Not a Number)）\n\n\nstring\n字符串，单双引皆可\n\n\nboolean\n布尔。true，false\n\n\nnull\n对象为空\n\n\nundefined\n当声明的变量未初始化时，该变量的默认值是 undefined\n\n\n\n\n\n运算规则\n运算符\n\n\n\n算术运算符\n+ , - , * , &#x2F; , % , ++ , –\n\n\n赋值运算符\n&#x3D; , +&#x3D; , -&#x3D; , *&#x3D; , &#x2F;&#x3D; , %&#x3D;\n\n\n比较运算符\n&gt; , &lt; , &gt;&#x3D; , &lt;&#x3D; , !&#x3D; , &#x3D;&#x3D; , &#x3D;&#x3D;&#x3D;   注意     &#x3D;&#x3D; 会进行类型转换，&#x3D;&#x3D;&#x3D; 不会进行类型转换\n\n\n逻辑运算符\n&amp;&amp; , || , !\n\n\n三元运算符\n条件表达式 ? true_value: false_value\n\n\njsfunction 函数名(参数1,参数2..)&#123;\n    要执行的代码\n&#125;因为JavaScript是弱数据类型的语言，所以有如下几点需要注意：\n\n形式参数不需要声明类型，并且JavaScript中不管什么类型都是let或者var去声明，加上也没有意义。\n返回值也不需要声明类型，直接return即可\n\n第二种可以通过let去定义函数的名字，具体格式如下：\njslet functionName = function (参数1,参数2..)&#123;   \n    //要执行的代码\n&#125;接下来我们按照上述的格式，修改代码如下：只需要将第一种定义方式注释掉，替换成第二种定义方式即可，函数的调用不变\n5.3 JS对象基本对象：Array对象\nArray对象时用来定义数组的。常用语法格式有如下2种：\n方式1：\njslet 变量名 = new Array(元素列表); 方式2：\njslet 变量名 = [ 元素列表 ]; 与java中不一样的是，JavaScript中数组相当于java中的集合，数组的长度是可以变化的。而且JavaScript是弱数据类型的语言，所以数组中可以存储任意数据类型的值。接下来我们通过代码来演示上述特点。\n属性：\n\n\n\n属性\n描述\n\n\n\nlength\n设置或返回数组中元素的数量。\n\n\n方法：\n\n\n\n方法方法\n描述\n\n\n\nforEach()\n遍历数组中的每个有值得元素，并调用一次传入的函数\n\n\npush()\n将新元素添加到数组的末尾，并返回新的长度\n\n\nsplice()\n从数组中删除元素\n\n\nforEach()函数\n首先我们学习forEach()方法，顾名思义，这是用来遍历的，那么遍历做什么事呢？所以这个方法的参数，需要传递一个函数，而且这个函数接受一个参数，就是遍历时数组的值。修改之前的遍历代码如下：\npush()函数\npush()函数是用于向数组的末尾添加元素的，其中函数的参数就是需要添加的元素，编写如下代码：向数组的末尾添加3个元素\nsplice()函数\nsplice()函数用来数组中的元素，函数中填入2个参数。\n参数1：表示从哪个索引位置删除\n参数2：表示删除元素的个数\nString对象\nString对象的创建方式有2种：\n方式1：\njslet 变量名 = new String(&quot;…&quot;) ; //方式一方式2：\njslet 变量名 = &quot;…&quot; ; //方式二String对象也提供了一些常用的属性和方法，如下表格所示：\n属性：\n\n\n\n属性\n描述\n\n\n\nlength\n字符串的长度。\n\n\n方法：\n\n\n\n方法\n描述\n\n\n\ncharAt()\n返回在指定位置的字符。\n\n\nindexOf()\n检索字符串。\n\n\ntrim()\n去除字符串两边的空格\n\n\nsubstring()\n提取字符串中两个指定的索引号之间的字符。\n\n\n\ncharAt()函数：\ncharAt()函数用于返回在指定索引位置的字符，函数的参数就是索引。\n\nindexOf()函数：\nindexOf()函数用于检索指定内容在字符串中的索引位置的，返回值是索引，参数是指定的内容。\n\ntrim()函数：\ntrim()函数用于去除字符串两边的空格的。\n\nsubstring()函数：\nsubstring()函数用于截取字符串的，函数有2个参数。\n参数1：表示从那个索引位置开始截取。包含\n参数2：表示到那个索引位置结束。不包含\n\n\nJSON对象\n在 JavaScript 中自定义对象特别简单，其语法格式如下：\njslet 对象名 = &#123;\n    属性名1: 属性值1, \n    属性名2: 属性值2,\n    属性名3: 属性值3,\n    函数名称: function(形参列表)&#123;&#125;\n&#125;;\n我们可以通过如下语法调用属性：\njs对象名.属性名通过如下语法调用函数：\njs对象名.函数名()JSON对象：JavaScript Object Notation，JavaScript对象标记法。是通过JavaScript标记法书写的文本。其格式如下：\njs&#123;\n    &quot;key&quot;:value,\n    &quot;key&quot;:value,\n    &quot;key&quot;:value\n&#125;其中，key必须使用引号并且是双引号标记，value可以是任意数据类型。\n那么json这种数据格式的文本到底应用在企业开发的什么地方呢？– 经常用来作为前后台交互的数据载体\n前后台交互时，我们需要传输数据，但是java中的对象我们该怎么去描述呢？我们可以使用如图所示的xml格式，可以清晰的描述java中需要传递给前端的java对象。\n但是xml格式存在如下问题：\n\n标签需要编写双份，占用带宽，浪费资源\n解析繁琐\n\n所以我们可以使用json来替代。\nBOM对象\nBOM的全称是Browser Object Model,翻译过来是浏览器对象模型。也就是JavaScript将浏览器的各个组成部分封装成了对象。我们要操作浏览器的部分功能，可以通过操作BOM对象的相关属性或者函数来完成。\nBOM中提供了如下5个对象：\n\n\n\n对象名称\n描述\n\n\n\nWindow\n浏览器窗口对象\n\n\nNavigator\n浏览器对象\n\n\nScreen\n屏幕对象\n\n\nHistory\n历史记录对象\n\n\nLocation\nd地址栏对象\n\n\n1.Window对象 \nwindow对象指的是浏览器窗口对象，是JavaScript的全部对象，所以对于window对象，我们可以直接使用，并且对于window对象的方法和属性，我们可以省略window.\nwindow对象提供了获取其他BOM对象的属性：\n\n\n\n属性\n描述\n\n\n\nhistory\n用于获取history对象\n\n\nlocation\n用于获取location对象\n\n\nNavigator\n用于获取Navigator对象\n\n\nScreen\n用于获取Screen对象\n\n\nwindow也提供了一些常用的函数，如下表格所示：\n\n\n\n函数\n描述\n\n\n\nalert()\n显示带有一段消息和一个确认按钮的警告框。\n\n\ncomfirm()\n显示带有一段消息以及确认按钮和取消按钮的对话框。\n\n\nsetInterval()\n按照指定的周期（以毫秒计）来调用函数或计算表达式。\n\n\nsetTimeout()\n在指定的毫秒数后调用函数或计算表达式。\n\n\nsetInterval(fn,毫秒值)：定时器，用于周期性的执行某个功能，并且是循环执行。该函数需要传递2个参数：\nfn:函数，需要周期性执行的功能代码\n毫秒值：间隔时间\nsetTimeout(fn,毫秒值) ：定时器，只会在一段时间后执行一次功能。参数和上述setInterval一致\n2.Location对象\nlocation是指代浏览器的地址栏对象，对于这个对象，我们常用的是href属性，用于获取或者设置浏览器的地址信息。\nDOM对象\nDOM：Document Object Model 文档对象模型。也就是 JavaScript 将 HTML 文档的各个组成部分封装为对象。\nDOM 其实我们并不陌生，之前在学习 XML 就接触过，只不过 XML 文档中的标签需要我们写代码解析，而 HTML 文档是浏览器解析。封装的对象分为\n\nDocument：整个文档对象\nElement：元素对象\nAttribute：属性对象\nText：文本对象\nComment：注释对象\n\n那么我们学习DOM技术有什么用呢？主要作用如下：\n\n改变 HTML 元素的内容\n改变 HTML 元素的样式（CSS）\n对 HTML DOM 事件作出反应\n添加和删除 HTML 元素\n\nHTML中的Element对象可以通过Document对象获取，而Document对象是通过window对象获取的。document对象提供的用于获取Element元素对象的api如下表所示：\n\n\n\n函数\n描述\n\n\n\ndocument.getElementById()\n根据id属性值获取，返回单个Element对象\n\n\ndocument.getElementsByTagName()\n根据标签名称获取，返回Element对象数组\n\n\ndocument.getElementsByName()\n根据name属性值获取，返回Element对象数组\n\n\ndocument.getElementsByClassName()\n根据class属性值获取，返回Element对象数组\n\n\n5.4 JS对象什么是事件呢？HTML事件是发生在HTML元素上的 “事情”，例如：\n\n按钮被点击\n鼠标移到元素上\n输入框失去焦点\n……..\n\n事件绑定 \nJavaScript对于事件的绑定提供了2种方式：\n\n方式1：通过html标签中的事件属性进行绑定\n例如一个按钮，我们对于按钮可以绑定单机事件，可以借助标签的onclick属性，属性值指向一个函数。\n\n方式2：通过DOM中Element元素的事件属性进行绑定\n依据我们学习过得DOM的知识点，我们知道html中的标签被加载成element对象，所以我们也可以通过element对象的属性来操作标签的属性。\n\n\n需要注意的是：事件绑定的函数，只有在事件被触发时，函数才会被调用。\n常见事件\n\n\n\n事件属性名\n说明\n\n\n\nonclick\n鼠标单击事件\n\n\nonblur\n元素失去焦点\n\n\nonfocus\n元素获得焦点\n\n\nonload\n某个页面或图像被完成加载\n\n\nonsubmit\n当表单提交时触发该事件\n\n\nonmouseover\n鼠标被移到某元素之上\n\n\nonmouseout\n鼠标从某元素移开\n\n\n6. Vue一个完整的html页面包括了视图和数据，数据是通过请求 从后台获取的，那么意味着我们需要将后台获取到的数据呈现到页面上，很明显， 这就需要我们使用DOM操作。正因为这种开发流程，所以我们引入了一种叫做MVVM(Model-View-ViewModel)的前端开发思想，即让我们开发者更加关注数据，而非数据绑定到视图这种机械化的操作。\nMVVM:其实是Model-View-ViewModel的缩写，有3个单词，具体释义如下：\n\nModel: 数据模型，特指前端中通过请求从后台获取的数据\nView: 视图，用于展示数据的页面，可以理解成我们的html+css搭建的页面，但是没有数据\nViewModel: 数据绑定到视图，负责将数据（Model）通过JavaScript的DOM技术，将数据展示到视图（View）上\n\nVue.js（读音 &#x2F;vjuː&#x2F;, 类似于 view） 是一套构建用户界面的 渐进式框架。与其他重量级框架不同的是，Vue 采用自底向上增量开发的设计。Vue 的核心库只关注视图层，并且非常容易学习，非常容易与其它库或已有项目整合。Vue.js 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件。\n框架即是一个半成品软件，是一套可重用的、通用的、软件基础代码模型。基于框架进行开发，更加快捷、更加高效。\n在创建vue对象时，有几个常用的属性：\n\nel:  用来指定哪儿些标签受 Vue 管理。 该属性取值 #app 中的 app 需要是受管理的标签的id属性值\ndata: 用来定义数据模型\nmethods: 用来定义函数。这个我们在后面就会用到\n\n6.1 常用指令在vue中，通过大量的指令来实现数据绑定到视图的，所以接下来我们需要学习vue的常用指令，如下表所示：\n\n\n\n指令\n作用\n\n\n\nv-bind\n为HTML标签绑定属性值，如设置  href , css样式等\n\n\nv-model\n在表单元素上创建双向数据绑定\n\n\nv-on\n为HTML标签绑定事件\n\n\nv-if\n条件性的渲染某元素，判定为true时渲染,否则不渲染\n\n\nv-else\n\n\n\nv-else-if\n\n\n\nv-show\n根据条件展示某元素，区别在于切换的是display属性的值\n\n\nv-for\n列表渲染，遍历容器的元素或者对象的属性\n\n\nv-bind:  为HTML标签绑定属性值，如设置  href , css样式等。当vue对象中的数据模型发生变化时，标签的属性值会随之发生变化。\nv-model： 在表单元素上创建双向数据绑定。什么是双向？\n\nvue对象的data属性中的数据变化，视图展示会一起变化\n视图数据发生变化，vue对象的data属性中的数据也会随着变化。\n\n双向绑定的作用：可以获取表单的数据的值，然后提交给服务器\nv-on: 用来给html标签绑定事件的。需要注意的是如下2点：\n\nv-on语法给标签的事件绑定的函数，必须是vue对象种声明的函数\nv-on语法绑定事件时，事件名相比较js中的事件名，没有on\n\n6.2 生命周期vue的生命周期：指的是vue对象从创建到销毁的过程。vue的生命周期包含8个阶段：每触发一个生命周期事件，会自动执行一个生命周期方法，这些生命周期方法也被称为钩子方法。其完整的生命周期如下图所示：\n\n\n\n状态\n阶段周期\n\n\n\nbeforeCreate\n创建前\n\n\ncreated\n创建后\n\n\nbeforeMount\n挂载前\n\n\nmounted\n挂载完成\n\n\nbeforeUpdate\n更新前\n\n\nupdated\n更新后\n\n\nbeforeDestroy\n销毁前\n\n\ndestroyed\n销毁后\n\n\nmounted：挂载完成，Vue初始化成功，HTML页面渲染成功。以后我们一般用于页面初始化自动的ajax请求后台数据\n","slug":"Javaweb前端速通","date":"2024-02-05T12:56:12.000Z","categories_index":"Study","tags_index":"Java,前端","author_index":"Fioransh"},{"id":"edf904054aa8b48f1e963a1dfb1f4ee3","title":"算法性能分析","content":"1.时间复杂度1.1 什么是时间复杂度时间复杂度是一个函数，它定性描述该算法的运行时间。\n通常会估算算法的操作单元数量来代表程序消耗的时间，这里默认CPU的每个单元运行消耗的时间都是相同的。假设算法的问题规模为n，那么操作单元数量便用函数f(n)来表示，随着数据规模n的增大，算法执行时间的增长率和f(n)的增长率相同，这称作为算法的渐近时间复杂度，简称时间复杂度，记为 O(f(n))。\n1.2 什么是大O算法导论给出的解释：大O用来表示上界的，当用它作为算法的最坏情况运行时间的上界，就是对任意数据输入的运行时间的上界。\n快速排序是O(nlogn)，但是当数据已经有序情况下，快速排序的时间复杂度是O(n^2) 的，**所以严格从大O的定义来讲，快速排序的时间复杂度应该是O(n^2)**。\n但是我们依然说快速排序是O(nlogn)的时间复杂度，这个就是业内的一个默认规定，这里说的O代表的就是一般情况，而不是严格的上界。\n1.3 不同数据规模的差异大O就是数据量级突破一个点且数据量级非常大的情况下所表现出的时间复杂度，这个数据量也就是常数项系数已经不起决定性作用的数据量。\n我们说的时间复杂度都是省略常数项系数的，是因为一般情况下都是默认数据规模足够的大，基于这样的事实，给出的算法时间复杂的的一个排行如下所示：\nO(1)常数阶 &lt; O(logn)对数阶 &lt; O(n)线性阶 &lt; O(nlogn)线性对数阶 &lt; O(n^2)平方阶 &lt; O(n^3)立方阶 &lt; O(2^n)指数阶\n1.4 例子题目描述：找出n个字符串中相同的两个字符串（假设这里只有两个相同的字符串）。\n1）可能会忽略了字符串比较的时间消耗，这里并不像int 型数字做比较那么简单，除了n^2 次的遍历次数外，字符串比较依然要消耗m次操作（m也就是字母串的长度），所以时间复杂度是O(m × n × n)。\n2）先排对n个字符串按字典序来排序，排序后n个字符串就是有序的，意味着两个相同的字符串就是挨在一起，然后在遍历一遍n个字符串，这样就找到两个相同的字符串了。\n那看看这种算法的时间复杂度，快速排序时间复杂度为O(nlogn)，依然要考虑字符串的长度是m，那么快速排序每次的比较都要有m次的字符比较的操作，就是O(m × n × log n) 。\n之后还要遍历一遍这n个字符串找出两个相同的字符串，别忘了遍历的时候依然要比较字符串，所以总共的时间复杂度是 O(m × n × logn + n × m)。\n我们对O(m × n × log n + n × m) 进行简化操作，把m × n提取出来变成 O(m × n × (logn + 1))，再省略常数项最后的时间复杂度是 O(m × n × log n)。\nps：例子仅用于讲解示范时间复杂度。\n2.算法为什么会超时2.1 超时怎么来程序运行的时间超过了规定的时间，一般OJ（online judge）的超时时间就是1s，也就是用例数据输入后最多要1s内得到结果，暂时还不清楚leetcode的判题规则，下文为了方便讲解，暂定超时时间就是1s。\n如果写出了一个$O(n)$的算法 ，其实可以估算出来n是多大的时候算法的执行时间就会超过1s了。\n如果n的规模已经足够让$O(n)$的算法运行时间超过了1s，就应该考虑log(n)的解法了。\n3.递归算法的时间复杂度面试题：求x的n次方\n最直观的方式应该就是，一个for循环求出结果，代码如下：\ncppint function1(int x, int n) &#123;\n    int result = 1;  // 注意 任何数的0次方等于1\n    for (int i = 0; i &lt; n; i++) &#123;\n        result = result * x;\n    &#125;\n    return result;\n&#125;时间复杂度为O(n)，此时面试官会说，有没有效率更好的算法呢。\n如果此时没有思路，不要说：我不会，我不知道了等等。\n可以和面试官探讨一下，询问：“可不可以给点提示”。面试官提示：“考虑一下递归算法”。\n那么就可以写出了如下这样的一个递归的算法，使用递归解决了这个问题。\ncppint function2(int x, int n) &#123;\n    if (n == 0) &#123;\n        return 1; // return 1 同样是因为0次方是等于1的\n    &#125;\n    return function2(x, n - 1) * x;\n&#125;一些同学可能一看到递归就想到了O(log n)，其实并不是这样，递归算法的时间复杂度本质上是要看: 递归的次数 * 每次递归中的操作次数。\n每次n-1，递归了n次时间复杂度是O(n)，每次进行了一个乘法操作，乘法操作的时间复杂度一个常数项O(1)，所以这份代码的时间复杂度是 n × 1 &#x3D; O(n)。\n这个时间复杂度就没有达到面试官的预期。于是又写出了如下的递归算法的代码：\ncppint function3(int x, int n) &#123;\n    if (n == 0) return 1;\n    if (n == 1) return x;\n\n    if (n % 2 == 1) &#123;\n        return function3(x, n / 2) * function3(x, n / 2)*x;\n    &#125;\n    return function3(x, n / 2) * function3(x, n / 2);\n&#125;**时间复杂度忽略掉常数项-1之后，这个递归算法的时间复杂度依然是O(n)**。对，你没看错，依然是O(n)的时间复杂度！\n于是又写出如下递归算法的代码：\ncppint function4(int x, int n) &#123;\n    if (n == 0) return 1;\n    if (n == 1) return x;\n    int t = function4(x, n / 2);// 这里相对于function3，是把这个递归操作抽取出来\n    if (n % 2 == 1) &#123;\n        return t * t * x;\n    &#125;\n    return t * t;\n&#125;依然还是看他递归了多少次，可以看到这里仅仅有一个递归调用，且每次都是n&#x2F;2 ，所以这里我们一共调用了log以2为底n的对数次。\n**每次递归了做都是一次乘法操作，这也是一个常数项的操作，那么这个递归算法的时间复杂度才是真正的O(logn)**。\n4.空间复杂度分析4.1 什么是空间复杂度是对一个算法在运行过程中占用内存空间大小的量度，记做S(n)&#x3D;O(f(n)。\n空间复杂度(Space Complexity)记作S(n) 依然使用大O来表示。利用程序的空间复杂度，可以对程序运行中需要多少内存有个预先估计。\n关注空间复杂度有两个常见的相关问题\n空间复杂度是考虑程序（可执行文件）的大小么？\n空间复杂度是考虑程序运行时占用内存的大小，而不是可执行文件的大小。\n空间复杂度是准确算出程序运行时所占用的内存么？\n不要以为空间复杂度就已经精准的掌握了程序的内存使用大小，很多因素会影响程序真正内存使用大小，例如编译器的内存对齐，编程语言容器的底层实现等等这些都会影响到程序内存的开销。\n所以空间复杂度是预先大体评估程序内存使用的大小。\n说到空间复杂度，我想同学们在OJ（online judge）上应该遇到过这种错误，就是超出内存限制，一般OJ对程序运行时的所消耗的内存都有一个限制。\n为了避免内存超出限制，这也需要我们对算法占用多大的内存有一个大体的预估。\n同样在工程实践中，计算机的内存空间也不是无限的，需要工程师对软件运行时所使用的内存有一个大体评估，这都需要用到算法空间复杂度的分析。\n4.2 例子什么时候的空间复杂度是$O(1)$呢，C++代码如下：\ncppint j = 0;\nfor (int i = 0; i &lt; n; i++) &#123;\n    j++;\n&#125;第一段代码可以看出，随着n的变化，所需开辟的内存空间并不会随着n的变化而变化。即此算法空间复杂度为一个常量，所以表示为大O(1)。\n什么时候的空间复杂度是O(n)？\n当消耗空间和输入参数n保持线性增长，这样的空间复杂度为O(n)，来看一下这段C++代码\ncppint* a = new int(n);\nfor (int i = 0; i &lt; n; i++) &#123;\n    a[i] = i;\n&#125;我们定义了一个数组出来，这个数组占用的大小为n，虽然有一个for循环，但没有再分配新的空间，因此，这段代码的空间复杂度主要看第一行即可，随着n的增大，开辟的内存大小呈线性增长，即 O(n)。\n5.代码内存消耗5.1 不同语言的内存管理不同的编程语言各自的内存管理方式。\n\nC&#x2F;C++这种内存堆空间的申请和释放完全靠自己管理\nJava 依赖JVM来做内存管理，不了解jvm内存管理的机制，很可能会因一些错误的代码写法而导致内存泄漏或内存溢出\nPython内存管理是由私有堆空间管理的，所有的python对象和数据结构都存储在私有堆空间中。程序员没有访问堆的权限，只有解释器才能操作。\n\n例如Python万物皆对象，并且将内存操作封装的很好，所以python的基本数据类型所用的内存会要远大于存放纯数据类型所占的内存，例如，我们都知道存储int型数据需要四个字节，但是使用Python 申请一个对象来存放数据的话，所用空间要远大于四个字节。\n5.2 内存对齐再介绍一下内存管理中另一个重要的知识点：内存对齐。\n不要以为只有C&#x2F;C++才会有内存对齐，只要可以跨平台的编程语言都需要做内存对齐，Java、Python都是一样的。\n而且这是面试中面试官非常喜欢问到的问题，就是：为什么会有内存对齐？\n主要是两个原因\n\n平台原因：不是所有的硬件平台都能访问任意内存地址上的任意数据，某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。为了同一个程序可以在多平台运行，需要内存对齐。\n硬件原因：经过内存对齐后，CPU访问内存的速度大大提升。\n\n参考学习自代码随想录\n","slug":"算法性能分析","date":"2024-01-28T14:25:12.000Z","categories_index":"Study","tags_index":"学习,算法","author_index":"Fioransh"},{"id":"8844fd48687a754eafe1c7b3d89d9e8e","title":"Hexo+gitee博客搭建流程","content":"写在前面本博客只是讲述安装流程，并不是纯面向小白的安装教程，在b站上有许多hexo的安装教程视频，可以参考b站教程进行安装。Hexo可以算是入门门槛最低的一种博客搭建手段了。这篇博客只是防止我以后忘记安装流程而编写，安装如遇到问题可以wx交流一下，不保证能解决。搭建环境开发项目是一件需要耐心的事情，可能会遇到各种各样的问题，要学会灵活网络搜索，你遇到的问题基本上都能解决，保持耐心，说不定马上你的问题就迎刃而解了。\n\n1.node js的安装和环境配置（由Ryan Dahl开发，是一个基于ChromeV8引擎的JavaScript运行环境，\n使用了一个事件驱动、非阻塞式I&#x2F;O模型，让JavaScript 运行在服务端的开发平台，\n它让JavaScript成为与PHP、Python、Perl、Ruby等服务端语言平起平坐的脚本语言\nnode 安装过程截图 \n\n安装可以无脑下一步，注意安装路径就行，不会有问题，如果不放心的话可以参考原文章的安装过程截图，有详细步骤，由于本文篇幅较长，这里就不再转载了。\n1.1 测试是否安装成功node -v\nnpm -v\n成功截图如下：\n解决npm查询不到版本号，方法一：https://past-taleggio-288.notion.site/node-24b6cf34d5c24186b7ef1ea7028b7fda\n1.2 配置环境变量详细截图在刚才安装nodejs的根目录下，创建node_global，node_cache文件夹以管理员身份打开cmd，配置路径`npm config set prefix \"E:\\develop\\nodejs\\node_global\"``npm config set cache \"E:\\develop\\nodejs\\node_cache\"`修改全局路径 node_global, 修改缓存路径 node_cache内路径需要根据自己实际情况来进行修改修改全局安装路径后，需要在系统环境变量Path中添加该路径，否则之后使用npm install –global xxx，xxx都报错找不到命令。 找到电脑环境配置  win10和win11：右键此电脑-属性-高级系统设置-高级-环境变量win11 还可以：点设置-系统-关于-高级系统设置-高级-环境变量\n完成以上操作后，在用户变量中创建NODE_PATH变量，变量值为node_modeules路径地址在系统变量中选择Path添加如下属性：\n\n2.安装git2.1 下载git官网https://git-scm.com/\n找到首页下方的Downloads\n下载对应系统（MAC、Windows、Linux&#x2F;Unix）安装包\n\n2.2 安装git安装git过程\n\n\n\n3.hexo下载npm install hexo-cli -g #安装hexo\n4.检查已安装各框架的版本git：\ngit --version\nhexo:\nhexo -v\n安装成功效果\n\n5.创建仓库及配置SSH连接5.1  创建gitee仓库（github同理）利用gitee仓库，存放静态网站资源，达到挂载网站的目的\n\n需要注意的是作为网站访问的这个仓库，仓库名称一定是，拥有者名+gitee.io\n5.2  生成ssh keys在博客文件夹根目录下，右键，调用git bash here功能\n\n先输入ssh查看是否已经安装ssh，git默认有安装\n本地生成ssh keys\ntxtssh-keygen -t rsa -C &quot;邮箱地址&quot;\n在本地电脑中找到.ssh文件夹\n\n一般默认都是，C:\\Users\\用户名.ssh.pub文件\n找到秘钥的位置，并用记事本打开**.pub文件**，复制其内容 (ctrl+a全选，ctrl+c复制，ctrl+v粘贴)\n打开gitee，头像下拉选项设置，找到SSH公钥（新建ssh秘钥）\n\n把在本地生成的秘钥内容粘贴至此秘钥处，标题可以随便取。\n测试ssh是否绑定成功（在git里操作）\ntxtssh -T git@gitee.com\n如果问你（yes or no），直接yes就可以得到上面这段话\n6.搭建本地博客创建一个放置博客文件夹的文件，在里面启用Git Bash Here\n\n初始化hexo\ntxthexo init\n\n生成hexo本地页面\n\ntxthexo s\n\n复制粘贴该地址到浏览器中，即可访问本地搭建的博客 http://localhost:4000\n\ntxthexo cl #clean #清理编译文件\nhexo g #generate #编译项目\nhexo s #server #本地预览运行项目7.上传本地博客至gitee7.1 修改配置文件在创建博客文件夹的根目录下修改-config.yml文件\n\n\ntxtdeploy:  \n   type: git  \n   repository: 你的gitee地址  \n   branch: main7.2 安装hexo-deployer-git 自动部署发布工具\ntxtnpm install hexo-deployer-git --save7.3  编译文件生成界面\ntxthexo g7.4  本地文件上传到Gitee\ntxthexo d成功后\n\n可以直接访问仓库名如:\n https://xxx.gitee.io\n\n出现如图画面，恭喜你完成了hexo的博客搭建。\n8.安装Aurora主题本步骤非必须，可以在hexo的官方网站寻找自己喜欢的主题进行安装，安装流程大致相似，每个主题也可能有自己独特的地方需要设置，具体参照对应主题自己的官方文档进行参考\nAurora官方文档参考：https://aurora.tridiamond.tech/zh/guide\n建议直接参照官方文档进行设置，官方文档更加详细。\n8.1  配置txtnpm install hexo-theme-aurora --save #进入hexo初始化目录用git执行\n安装好之后，我们需要自己创建一个配置文件。\n我们可以到 node_modules文件夹 下找到 hexo-theme-aurora文件夹。\n里面将_config.yml 复制一份 F2 重命名为_config.aurora.yml\n\n然后将 _config.aurora.yml 移动到你的博客根目录下\n\n8.2 修改配置打开_comfig.yml\n由默认主题改为Aurora\n\n由于Aurora是vue3项目\n打开根目录下的_config.yml\n修改路由方式\n\n运行\ntxthexo clean &amp; hexo g &amp; hexo server我的习惯是分开来：\ntxthexo cl\nhexo g\nhexo s\n8.3 上传并覆盖gitee仓库txthexo d可以使用\ntxthexo s进行本地预览\n打开你的Gitee网页地址，比如本博客主题配置成功\n9.博客参考[搭建博客-图文教程-Luiyang](https://luiyang08.github.io/post/Build Blog)\nhexo+aurora+github搭建-叁鄉浪子\nhexo官方文档\nAurora官方文档\n写在后面搭建完成后的文章编写也会有许多的问题，后续有空再写一下关于文章编写的问题吧，以及一些aurora主题的各种自定义样式修改例如网站图标，个人头像，文章头图等，各类组件的开关安装，编写博客实在需要很多时间，可以网上搜索参考官方文档和他人的教程，这些问题都能得到解决，最重要的是有坚持不懈的心。\n","slug":"hexo博客创建教程","date":"2024-01-25T09:42:12.000Z","categories_index":"Blog","tags_index":"学习,博客搭建","author_index":"Fioransh"},{"id":"40b4e77513d2dcdb879ae29656ac6237","title":"SCAU2023CSAPP期末知识点总结","content":"CSAPP知识点\n进制数转换：十进制转二进制、二进制转十进制、十进制转十六进制、十六进制转十进制、二进制转十六进制、十六进制转二进制。\n\n布尔运算：&amp;与（0&amp;0&#x3D;0 0&amp;1&#x3D;0 1&amp;1&#x3D;1） |或（0|0&#x3D;0 0|1&#x3D;1 1|1&#x3D;1）~非（取反）^异或（0^0&#x3D;0 0^1&#x3D;1 1^1&#x3D;0）\n\n位及运算：获取最低有效字节的值（&amp;0xFF）\n\n逻辑运算（&amp;&amp; || ！）：非0参数都位true（0x01）、参数0表示false(0x00)\n\n移位运算：左移（丢弃左位在最右端补0）逻辑右移（丢弃右位在最左端补0）算数右移（最高位等于0时候与逻辑右移一样、最高位等于1时则是在最高位补1）有符号数为算数右移、无符号数为逻辑右移。\n\n映射(B2U)有符号数无符号数的编码方式：\n\n补码编码映射(B2T)：\n\n有符号数和无符号数的转换：位模式不变、解释位的方式变化。\n\n强制类型转换、影响关系运算的结果：程序运行有符号数会强转成无符号数运算。较大数据类型转较小会损失。\n\n无符号数的转换更大数据类型-扩展：无符号数末尾带有U\n\n有符号数的转换更大数据类型-扩展：\n\n截断的基本规则：\n\n无符号数加法：\n\n有符号数加法：\n\n补码的加法：\n\n使用移位、加法运算的组合代表乘以常数因子：除法无法除尽时候会向0方向舍入、除法为右移\n\n浮点数的权重：\n\n浮点数格式（符号、阶码、尾数）：符号位s（为0时为正数、为1时为负数）阶码exp、尾数M与frac相关\n\n浮点数规格化的值、非规格化的值、特殊值：阶码exp决定了这个数是哪一类\n\n规格化的值和非规格化的值：阶码域全为0的时候E&#x3D;1-bias。M&#x3D;f。\n\n单精度浮点数的二进制表示：\n\n向上舍入、向下舍入、向0舍入、向偶数舍入：\n\nint转化为float不会溢出可能会被舍入、int&#x2F;float转化为double可以保留、double转化为float类型可能会发生溢出转换后可能被舍入、float&#x2F;double转化为int可能向0舍入也可能溢出。\n\n操作数的寄存器：\n\n操作码和操作数以及内存引用：立即数用$表示、内存引用需要加上括号\n\n操作数：\n\n汇编后缀表示：\n\n数据传送指令mov：后缀不同操作的数大小不同，当movq指令的源操作数为立即数时、该立即数只能是32位的补码表示、然后对该数值进行符号位扩展后、讲得到的64位数传送。\n\n压入和弹出栈：\n\n算数和逻辑指令leaq：\n\n通过leaq指令实现算术运算：\n\n一元操作：\n\n二元操作：\n\n移位运算：\n\n其他运算：\n\n常用条件码：CF-进位标志，当CPU最近执行的一条指令最高位产生了进位时，CF会被置1，可以用来检查无符号数的溢出。ZF-零标志，当最近操作的结果为0时，零标志会被置1。SF-符号标志，当最近的操作结果小于0的时候，符号标志会被置1。OF-溢出标志，最近的操作导致正溢出或负溢出时候会被置1。\n\ncmp指令和test指令：\n\n条件控制分支if-else以及条件传送：\n\n循环指令：循环语句是通过条件测试与跳转的结合来实现的。\n\nswitch语句：\n\n理解过程，理解“过程 P 调用过程 Q，Q 执行后返回到 P”包含的三个机制（传递控制、\n传递数据、分配和释放内存）：\n栈帧：当函数执行所需要的存储空间超出寄存器能够存放的大小时，会借助栈上的存储空间，这部分存储空间就叫做栈帧。\n对于函数P调用函数Q的例子，包括较早的帧、调用函数P的帧、还要正在执行函数Q的帧。\n当函数P调用函数Q时，会把返回地址压入栈中，该地址殖知名了函数Q执行结束返回时要从函数P的哪个位置继续进行。这个返回地址的压栈操作并不是由指令push来执行的，而是由函数调用指令call实现的。\n\n数组的分配与访问： short数组2个字节、int数组4个字节、double数组8个字节、指针数组8个字节\n二维数组（嵌套数组）：Xd表示数组的起始地址、L表示数组T的大小、Cij都是常数。\n\n理解内存越界的引用和缓冲区溢出：缓冲区溢出会导致返回时会随机返回到系统的任意位置。对抗缓冲区溢出攻击的方法：栈随机化（ASLR 栈的位置在每次运行时地址都变化）、栈破坏检测（在缓冲区与栈保存的状态值之间存储一个特殊值，这个值被称为金丝雀值、检测金丝雀值是否变化判断是否遭受攻击）、限制可执行代码区域。\n\n消除循环的低效率：CPE表示每个元素执行所需要的周期数（度量效率）。比较操作和分支操作不直接影响程序的数据流，将两个操作以及寄存器rax删除，只保留循环寄存器以及关键操作。将这个视作一个模板重复n次。\n\n减少过程调用（循环展开）：多路并行，10路时接近吞吐界限。\n\n消除不必要的内存引用（加载操作延迟）：加载操作会受存储引用和计算影响。\n\n动态RAM（DRAM）： 电容充电维持信息存储、每个bit位的存储对应一个电容和晶体管，对干扰十分敏感，内存采用DRAM，不断刷新才能保持数据，使用超单元一词来表示DRAM的存储单元，可以通过类似坐标的方式寻址，寻址所需位数关系2的n次方等于行数&#x2F;列数，n即为寻址位数。\n\n磁盘容量和磁盘访问时间的计算：\n\n局部性（时间局部性、空间局部性）：时间局部性（被引用的内存位置在不远的将来还可能被多次引用）、空间局部性（一个内存被引用了一次，程序很可能在不远的将来引用附近的一个内存位置）如两层嵌套的循环遍历二重数组的例子。\n\n高速缓存的参数：基于SRAM，有效位（valid 长1bit 表示当前cache line存储的信息是否有效 1表示有效0表示无效）、标记（tag 确定目标数据是否存在于当前的cache line中） 、数据块（cache block一小部分内存数据的副本，大小用B表示）\n\n高速缓存的三种地址的映射方式：根据每个set所包含的cache line的行数不同，cache被分为不同的类。\n直接缓存（E&#x3D;1 组选择 行匹配 字抽取 根据偏移量来确定目标数据的确切位置，从什么位置开始抽取数据 命中：不命中：cache需要从存储器层次结构的下一层取出被请求的块)\n例子：S表示有几个set、E表示每个set有几行、B表示每个数据块包含几个字节、其中地址m是多少位\n组相联（E&#x3D;2）：字抽取不命中（随机替换、最不常使用、最近最少使用）\n全相联（E&#x3D;C&#x2F;B）：\n\n编写高速缓存友好代码：\n\n理解符号类型和符号解析：全局符号（由该模块定义、同时能被其他模块引用的全局符号）、外部符号（被其他模块定义、同时被该模块引用的全局符号）、局部符号（只能被该模块定义和引用的局部符号 static）\nCOMMON是未初始化的全局变量，注意和.bss区分\n\n强符号和弱符号：强符号（函数和已初始化的全局变量  连接器不允许有多个同名的强符号一起出现）、弱符号（未初始化的全局变量）。\n\n重定位：重定位条目（告诉链接器在合成可执行文件时候应该如何修改这个引用）链接器合并输入模块，并为每个符号分配运行时地址\n重定位相对引用\n绝对地址引用\n\n异常控制流的分类：中断（异步）、陷阱、故障和终止\n\n并发流：一个逻辑流的执行在时间上和另一个流重叠的情况成为并发流，两个流的执行被成为并发运行。（并行是两个进程在不同的处理器核上同时运行）并发是交替运行的，并行是同时运行的。\n\n进程的状态\n\n进程的创建：创建进程时使用的系统函数-fork。父进程调用fork函数创建一个子进程。fork函数一次调用返回两次。父进程和子进程二者并发执行，它们的输出结果都打印出来。\n\n函数execve：调用加载器，在执行可执行程序的main函数之前。\n\nzombie僵死进程：终止运行但是还未回收的进程称为僵死进程，仍在消耗内存。\n\n子进程的回收：父进程通过函数waitpid来等待它的子进程终止或者停止。当第一个参数pid等于0表示等待的进程是一个单独的子进程，pid&#x3D;-1表示等待的进程是由父进程创建的所有子进程组成的集合。statusp是非空，函数waitpid在status上放上导致返回的子进程的状态信息，status就是statusp的值。正常回收返回true，否则未false。\n\n信号所引发事件：\n\n进程组的概念：每个进程都只属于一个进程组，每个进程组都有自己的ID值来唯一标识，通过函数getpgrp来获取当前进程所属的进程组ID值。setpgrp可以进行更改ID\n\n发送信号的方式：\n发送信号的&#x2F;kill方式：通过&#x2F;bin目录中的kill程序可以向其他的进程发送任意的信号。\n从键盘发送信号：当我们在键盘上输入Ctrl+C键会导致内容发送一个中断信号到前台进程组中的所有进程中。\n调用函数kill：调用函数发送信号给其他进程，也包括给自己发送信号。\n使用函数alarm函数：\n\n接收信号：一个待处理信号最多只能接收一次，一种类型的信号最多只能有一次待处理信号。如果一个类型为k的信号有待处理信号，那接下来这个进程中类型为k的信号都不用排队等待，会被简单地丢弃。\n\n虚拟内存：自动完成内存管理的相关工作，可以创建和释放内存空间，将内存空间映射到磁盘文件的某个部分，共享内存。虚拟内存使用不当会使程序产生错误。\n\n物理寻址：\n\n虚拟寻址：将一个虚拟地址转换成物理地址的任务叫做地址翻译\n\n地址空间：地址空间是一个非负整数的有序集合，如果地址空间中的整数是连续的，那么我们说它是一个线性地址空间，一个地址空间的大小是由标识最大地址所需要的位数来描述的。最大可能的虚拟地址是虚拟地址数-1。\n\n虚拟页（存在于磁盘上）和物理页：\n\n页表：是一个页表条目PTE的数组存在于物理内存之中，将虚拟页地址映射到物理页地址。页表条目PTE&#x3D;2的n-p次方，n为虚拟地址大小、页大小P&#x3D;2的p次方。\n\n页命中：虚拟内存中的一个字存在于物理内存中（即DRAM缓存命中）\n\n缺页：引用虚拟内存中的字，不在物理内存中 (DRAM 缓存不命中)\n\n分配页面：分配一个新的虚拟内存页 (VP 5).内核在磁盘上分配VP5， 并且将PTE5指向这个新的位置\n\n使用SRAM缓存来表示CPU与内存之间的L1L2L3这三级高速缓存。DRAM表示虚拟内存系统的缓存。\n\n地址翻译：\n\nP&#x3D;1K&#x3D;2的10次方可以得到p&#x3D;10。虚拟页偏移量VPO&#x3D;物理页偏移量PPO&#x3D;p。虚拟页号VPN&#x3D;虚拟地址空间-虚拟页偏移量VPO。物理页号PPN&#x3D;物理地址-物理页偏移量PPO。\n\n\n","slug":"CSAPP知识点","date":"2024-01-02T05:28:12.000Z","categories_index":"Study","tags_index":"CSAPP,学习","author_index":"Fioransh"},{"id":"c64df93cb58edc8361b9b55ace6a467f","title":"前端部分知识点","content":"HTML部分1. html结构1.html：根标签\n2.head： 头部标签\n3.body： 主体标签\n4.title：标题标签\n5.DOCTYPE： 声明文档类型\n6.lang &#x3D; “en”：页面的语言类型\n7.charset&#x3D;“UTF-8”编码格式\n2. html标签\n标题标h： &lt;h1&gt; ~ &lt;h6&gt; 不同字号大小\n段落标签p\n水平线标签  &lt;hr&#x2F;&gt; 单标签\n换行标签  &lt;br&#x2F;&gt;\nspan 文字标签：一行上可以放多个 \\ 小盒子\ndiv标签： 一行上只能放一个&lt;div&gt;大盒子 \n加粗标签：&lt;strong&gt; 和  &lt;b&gt; 前者语义更强烈\n倾斜标签：&lt;em&gt; 和 &lt;i&gt; 前者语义更强烈\n删除线：&lt;del&gt; 和  &lt;s&gt;  前者语义更强烈\n下划线：&lt;ins&gt; 和 &lt;u&gt; 前者语义更强烈\n\n3.图片标签&lt;img&gt;\nsrc：当前图片的路径\nalt：当图片错误加载时候显示的文字\ntitle：当鼠标悬停在图片上显示的文字\nheight： 图片的高度\nwidth： 图片的宽度\nborder：图片的边框\n\n4.连接标签&lt;a&gt;\n外部链接  &lt;a href&#x3D;”\\\">http://www.baidu.com&quot;&gt;\\  写完整的 协议  域名   网址\n内部链接 &lt;a href&#x3D;”index.html”&gt;&lt;&#x2F;a&gt;   直接写文件名即可\nhref:指定跳转的页面\ntitle：鼠标悬停显示的文字\ntarget:  _self(默认会覆盖原来的窗口)   _blank(会以新的窗口打开)    窗口的打开方式\n#：会阻止页面跳转但是会刷新页面\n绝对路径：目录下的绝对位置，通常从盘符开始\n相对路径：在同一个文件夹直接找名字、向上一级  ..&#x2F; 、向下 &#x2F;\n\n5.表格\n表格：&lt;table&gt;是用于定义表格的标签。\n行：&lt;tr&gt;标签用于定义表格中的行，必须嵌套在 &lt;table&gt; 标签中。\n单元格：&lt;td&gt; 用于定义表格中的单元格，必须嵌套在&lt;tr&gt;标签中。\n表头&lt;th&gt; 加粗加黑自动居中。\n表格的标题：&lt;caption&gt;表格的标题   写在内部  显示外部  居中\n结构头：&lt;thead&gt; 结构头\n结构底：&lt;tfoot&gt;结构底\n结构体：&lt;tbody&gt;结构体\n表格边框border\n宽度 width\n高度 height\n单元格与单元格之间距离 cellspacing\n单元格与内容之间的距离 cellspadding\n居中 align ： left&#x2F; center&#x2F; right \n列合并 colspan\n行合并 rowspan\n\n6.列表\n无序列表 : &lt;ul&gt; &lt;li&gt;\n有序列表 : &lt;ol&gt;&lt;li&gt;\n自定义列表：&lt;dl&gt; &lt;dt&gt; &lt;dd&gt;\n\n7. 表单1. input属性 &lt;input type &#x3D; “属性值”&gt;\ntext：文本框\npassword：密码框\nradio：单选按钮\ncheckbox：复选框\nbutton：普通按钮\nreset：重置按钮  需要配合form表单才有作用\nsubmit：提交按钮\nimage   属性  src\nfile 文件按钮   上传图片\n\n2.其他属性\nname属性：定义input元素的名称\nvalue：规定input氧元素的值\nchecked：规定input元素首次加载时应当被选中\nmaxlength： 输入字段字符的最大长度\nlabel\ntextarea：用户留言 cols&#x3D;“每行中的字符数” ，rows&#x3D;“显示的行数”\nselect：下拉菜单\nform表单：收集用户信息，action：  提交后台的地址 method&#x3D;”get&#x2F;post”   提交（传输）后台的方式 name &#x3D;“a” 告诉服务器  由哪个表单提交过来的\n\nCSS部分1.css引入方式\n行内样式：&lt;标签 style&#x3D;”属性:属性值;”&gt;&lt;&#x2F;标签&gt;\n内部样式：选择器{属性:属性值;属性：属性值}\n外部样式：通过link引入外部css文件  &lt;link  rel&#x3D;”stylesheet”   href&#x3D;”外部css文件”  &#x2F;&gt;\nhref与src   href 是引用   src下载资源到当前页面\n\n2.选择器\n标签选择器：标签{属性：属性值}\nclass（类选择器）：html：&lt;div class&#x3D;”名字”&gt;  css：  .名字{属性：属性值}  .nav{color: red}\nid选择器：html：&lt;div id&#x3D;”名字”&gt;&lt;&#x2F;div&gt;   css：  #名字{属性：属性值} id与class选择器的区别：  id的名字是唯一的（体现在js里面） class名字可以任意多个  #nav{color： red}\n通配符选择器：选择所有的标签 *{color：red}\n\n3.字体属性\n字体大小：font-size \n字体类型：font-family\n字体粗度：font-weight   normal默认值400（不加粗）bold粗体700（加粗的）\n文本风格：font-style:字体倾斜：italic（倾斜）&#x2F;normal（正常）\n文字阴影： text-shadow  水平距离   垂直距离  模糊程度   阴影颜色   \n字体连写：  font:font-style font-weight font-size&#x2F;line-height font-family\n字体颜色：color\n水平对齐方式：text-align:left&#x2F;center&#x2F;right（注意：1.div  h。。标题会居中   span   em  i。。。。不会居中）\n行高：line-height\n首行缩进：text-indent:  em   1em&#x3D;16px\n去掉a链接默认的下划线 ：text-decoration： none(去掉下划线)&#x2F; undefined(添加下划线)\n\n4.快速生成HTML结构语法\n生成标签 直接输入标签名 按tab键即可   比如  div   然后tab 键， 就可以生成 &lt;div&gt;&lt;&#x2F;div&gt;\n如果想要生成多个相同标签  加上 * 就可以了 比如   div*3  就可以快速生成3个div\n如果有父子级关系的标签，可以用 &gt;  比如   ul &gt; li就可以了\n如果有兄弟关系的标签，用  +  就可以了 比如 div+p  \n如果生成带有类名或者id名字的，  直接写  .demo  或者  #two   tab 键就可以了\n如果生成的div 类名是有顺序的， 可以用 自增符号  $ \n如果想要在生成的标签内部写内容可以用  { }  表示\n\n5.快速生成CSS样式语法CSS 基本采取简写形式即可\n​\t\t比如 w200   按tab  可以 生成  width: 200px;\n​\t\t比如 lh26px   按tab  可以生成  line-height: 26px;‘\n6.复合选择器\n后代选择器：元素1 元素2 {样式}   ul li{color：red} 选择ul里面所有的li标签元素\n子选择器：元素1&gt;元素2 {样式}  div &gt; p {样式声明} 选择div里面所有最近一级的p标签元素\n并集选择器：元素1，元素2 {样式声明}  ul，div{样式}  选择ul和div标签元素\n伪类选择器：     （ :hover）\n链接伪类选择器：给某些选择器增加特殊的效果：\ta:hover\t鼠标经过的那个链接\n:focus 伪类选择器：用于选取获得焦点的表单元素\n\n7.CSS的显示模式\n块元素：&lt;h1&gt;~&lt;h6&gt;、&lt;p&gt;、&lt;div&gt;、&lt;ul&gt;、&lt;ol&gt;、&lt;li&gt;  比较霸道，自己独占一行。高度，宽度、外边距以及内边距都可以控制。宽度默认是容器（父级宽度）的100%。是一个容器及盒子，里面可以放行内或者块级元素。\n行内元素：&lt;a&gt;、&lt;strong&gt;、&lt;b&gt;、&lt;em&gt;、&lt;i&gt;、&lt;del&gt;、&lt;s&gt;、&lt;ins&gt;、&lt;u&gt;、&lt;span&gt; 相邻行内元素在一行上，一行可以显示多个。默认宽度就是它本身内容的宽度。\n行内块元素：&lt;img &#x2F;&gt;、&lt;input &#x2F;&gt;、&lt;td&gt;  同时具有块元素和行内元素的特点。\n元素显示模块转换：转换为块元素：display:block;  转换为行内元素：display:inline;  转换为行内块：display: inline-block;\n让文字的行高等于盒子的高度  就可以让文字在当前盒子内垂直居中\n\n8.CSS的背景\n背景颜色：background-color：颜色值；元素背景颜色默认值是 transparent（透明）\n背景图片：background-image：none | url ；\n背景平铺：background-repeat： repeat在纵向和横向上平铺 | no-repeat不平铺 | repeat-x横向 | repeat-y纵向\n背景图片位置：background-position 属性可以改变图片在背景中的位置\n背景图片固定：\tbackground-attachment    scroll随对象内容滚动  fixed 背景图像固定\n背景样式合写：\tbackground: 背景颜色 背景图片地址 背景平铺 背景图像滚动 背景图片位置;\n背景色半透明：background： rgba（0，0，0，0.3） 最后一个参数是 alpha 透明度，取值范围在 0~1之间\n\n9.优先级\n继承或者* 0，0，0，0\n元素选择器 0，0，0，1\n类选择器，伪类选择器 0，0，1，0\nID选择器  0，1，0，0\n行内样式 style&#x3D;“” 1，0，0，0\n！important 重要的 无穷大\n\n10.盒子模型——边框border\nCSS 盒子模型本质上是一个盒子，封装周围的 HTML 元素，它包括：边框、外边距、内边距、和 实际内容\n定义边框粗细：border-width： 单位是px\n边框的样式：border-style  none：没有边框即忽略所有边框的宽度（默认值）solid：边框为单实线(最为常用的) dashed：边框为虚线   dotted：边框为点线\n表格的细线边框：border-collapse \nborder-collapse: collapse; 表示相邻边框合并在一起\n内边距 padding\n外边距 margin\n圆角边框：border-radius 用于设置元素的外边框圆角。\n盒子阴影： box-shadow: h-shadow水平阴影 v-shadow垂直阴影 blur模糊距离 spread阴影的尺寸 color阴影颜色 inset外部阴影改为内部阴影;\n文字阴影：  text-shadow: h-shadow水平阴影 v-shadow垂直阴影 blur模糊距离 color阴影颜色;\n\n11.浮动\n浮动：float：none不浮动   left向左浮动   right向右浮动\n清除浮动： 选择器{clear:属性值;}   left 不允许左侧有浮动   right 不允许右侧有浮动  both 同时清除左右两侧浮动\n额外标签法清除浮动：例如 &lt;div style&#x3D;”clear:both”&gt;&lt;&#x2F;div&gt;，或者其他标签（如&lt;br &#x2F;&gt;等）。\n父级添加 overflow 属性 （溢出）hidden | auto | scroll\n父级添加after伪元素\n\n12.定位（position）\n边偏移 有 top、bottom、left 和 right  4 个属性。\n\nposition 属性定义元素的定位模式  选择器 { position: 属性值; } static  静态定位 relative  相对定位            absolute  绝对定位fixed  固定定位\n\n静态定位(static) ：无定位\n\n相对定位(relative) ：移动位置的时候相对于自己原来的位置来说的，在原来位置继续占有\n\n绝对定位(absolute)：绝对定位是元素在移动位置的时候，是相对于它祖先元素来说的，完全不占位置，父元素要有定位\n\n子绝父相\n\n固定定位(fixed)：固定于浏览器可视区的位置，不随滚动条滚动，不占位置\n\n粘性定位(sticky) ：相对定位和固定定位的混合，占位置\n\n\n\n定位模式\n是否脱标\n移动位置\n是否常用\n\n\n\nstatic   静态定位\n否\n不能使用边偏移\n很少\n\n\nrelative 相对定位\n否 (占有位置)\n相对于自身位置移动\n基本单独使用\n\n\nabsolute绝对定位\n是（不占有位置）\n带有定位的父级\n要和定位父级元素搭配使用\n\n\nfixed 固定定位\n是（不占有位置）\n浏览器可视区\n单独使用，不需要父级\n\n\nsticky 粘性定位\n否   (占有位置)\n浏览器可视区\n当前阶段少\n\n\n\n堆叠顺序（z-index）：正整数、负整数或 0，默认值是 0，数值越大，盒子越靠上；\n\n绝对定位的盒子居中：left: 50%;  margin-left: -100px;\n\n脱标的盒子不会触发外边距塌陷\n\n绝对定位（固定定位）会完全压住盒子\n\n\n13.元素显示隐藏\n显示display：display: none 隐藏对象  display：block 除了转换为块级元素之外，同时还有显示元素的意思。隐藏后不再占有原本位置\n\n可见性 visibility：visibility：visible ; 　元素可视   visibility：hidden; 　  元素隐藏\n\noverflow 溢出：\n\n\n\n\n属性值\n描述\n\n\n\nvisible\n不剪切内容也不添加滚动条\n\n\nhidden\n不显示超过对象尺寸的内容，超出的部分隐藏掉\n\n\nscroll\n不管超出内容否，总是显示滚动条\n\n\nauto\n超出自动显示滚动条，不超出不显示滚动条\n\n\n\n\n14.精灵图\n精灵技术主要针对于背景图片使用。就是把多个小背景图片整合到一张大图片中。\n这个大图片也称为 sprites  精灵图  或者 雪碧图\n移动背景图片位置， 此时可以使用 background-position 。\n移动的距离就是这个目标图片的 x 和 y 坐标。注意网页中的坐标有所不同\n因为一般情况下都是往上往左移动，所以数值是负值。\n使用精灵图的时候需要精确测量，每个小背景图片的大小和位置。\n\n15.字体应用txt @font-face &#123;\n   font-family: &#39;icomoon&#39;;\n   src:  url(&#39;fonts/icomoon.eot?7kkyc2&#39;);\n   src:  url(&#39;fonts/icomoon.eot?7kkyc2#iefix&#39;) format(&#39;embedded-opentype&#39;),\n     url(&#39;fonts/icomoon.ttf?7kkyc2&#39;) format(&#39;truetype&#39;),\n     url(&#39;fonts/icomoon.woff?7kkyc2&#39;) format(&#39;woff&#39;),\n     url(&#39;fonts/icomoon.svg?7kkyc2#icomoon&#39;) format(&#39;svg&#39;);\n   font-weight: normal;\n   font-style: normal;\n &#125;\n定义字体： span {   font-family: “icomoon”;}\n16.CSS界面样式\n鼠标样式 cursor：default 小白默认 pointer小手 move 移动 text文本 not-allowed禁止\n轮廓线 outline：none 去掉默认蓝色边框\n防止拖拽文本域 resize：none\n文字对齐 vertical-align ：baseline默认，放在父元素基线，top 行中最高元素顶端对齐 middle 放在父元素中部 bottom最低元素的顶端对齐\n单行文本溢出显示省略号：先强制一行内显示文本  white-space: nowrap; 超出的部分隐藏  overflow: hidden;  文字用省略号替代超出的部分  text-overflow: ellipsis;\n\nHTML51.语义化标签\n&lt;header&gt; 头部标签\n&lt;nav&gt; 导航标签\n&lt;article&gt; 内容标签\n&lt;section&gt; 定义文档某个区域\n&lt;aside&gt; 侧边栏标签\n&lt;footer&gt; 尾部标签\n\n2.多媒体标签\n音频 audio 和视频 video 两个标签\nautoplay 视频就绪自动播放\nwidth height\nloop 视频播放完毕是否循环播放\npreload auto预先加载 none不预先\nurl地址\nposter 加载等待的画面图片\nmuted 静音播放\ncontrols 显示控件\n\n3.新增表单元素\nemail  \nurl\ndate\ntime\nmonth\nweek\nnumber\ntel\nsearch\ncolor\n\nCSS31.新增选择器\n\n\n\n\n2.盒子模型\nbox-sizing: content-box  盒子大小为 width + padding + border  （以前默认的）\nbox-sizing: border-box  盒子大小为 width\n如果盒子模型我们改为了box-sizing: border-box  ， 那padding和border就不会撑大盒子了（前提padding和border不会超过width宽度）\n\n3.其他特性\n模糊滤镜filter ：filter:   函数(); –&gt;  例如： filter: blur(5px);  –&gt;  blur模糊处理  数值越大越模糊\n计算盒子宽度 – calc 函数：width: calc(100% - 80px);\n\n4.CSS3过渡\n过渡动画： 是从一个状态 渐渐的过渡到另外一个状态\ntransition: 要过渡的属性  花费时间  运动曲线  何时开始;\n\n5.2D转换\n转换 移动：translate  旋转：rotate  缩放：scale\n旋转 translate：transform：translate（x,y）\n缩放 retate：transform：retate（度数）\n2D转换中心点：transform-origin： x， y；\n缩放 transform：scale（x,y）\n\n6.动画\nkeyframes定义动画  @keyframes动画名称\n\n","slug":"前端部分知识总结","date":"2023-11-23T05:28:12.000Z","categories_index":"Study","tags_index":"学习,前端","author_index":"Fioransh"},{"id":"1a206922638b47b5382f6efd345cd840","title":"校园课表微信小程序接口文档示例","content":"基于uni-app框架开发的微信小程序接口文档一. 关系型数据库设计1.数据列表1.student 表\n\n\nstudent_id\nreal_student_id\nname\ncollege\nmajor\nclassNum\ngrade\n\n\n\n1\n202225220801\n张三\n数信\n软件工程\n5班\n2022\n\n\n2\n202325310802\n李四\n材能\n材料\n1班\n2023\n\n\n…\n…\n…\n…\n…\n…\n…\n\n\n2. courses表\n\n\ncourse_id\nname\nteacher\ntime\nlocation\nday_of_week\n\n\n\n101\n数据库原理\n王老师\n周一1-2节\n4210\n1\n\n\n102\n数据结构\n张老师\n周三1-2节\n3302\n3\n\n\n103\n面向对象程序设计\n宋老师\n周四3-4节\n4502\n4\n\n\n…\n…\n…\n…\n…\n\n\n\n3.enrollments表\n\n\nenrollment_id\nstudent_id\ncourse_id\n\n\n\n1\n1\n101\n\n\n2\n1\n102\n\n\n3\n2\n101\n\n\n4\n2\n103\n\n\n…\n…\n…\n\n\n4.tasks表\n\n\ntask_id\nreal_student_id\ndescription\nstatus\ncreate_time\nupdate_time\n\n\n\n1\n202225220501\n完成作业\n未完成(0)\n…\n…\n\n\n2\n202325310502\n准备考试\n完成(1)\n…\n…\n\n\n3\n202225310702\n提交报告\n未完成(0)\n…\n…\n\n\n…\n…\n…\n…\n\n\n\n\n生成语句txt-- 学生表格\ncreate table students (\n    student_id int unsigned primary key auto_increment comment &#39;主键学生id&#39;,\n    real_student_id varchar(20) not null comment &#39;学号&#39;,\n    name varchar(10) not null comment &#39;名字&#39;,\n    college varchar(20) not null comment &#39;学院&#39;,\n    major varchar(20) not null comment &#39;专业&#39;,\n    class int not null comment &#39;班级&#39;,\n    grade int not null comment &#39;年级&#39;\n)comment &#39;学生表格&#39;;\nCREATE INDEX idx_real_student_id ON students(real_student_id);\n-- 学生表测试数据\ninsert into students(student_id, real_student_id, name, college, major, class, grade) values(1, &#39;202225220503&#39;, &#39;冯焯炫&#39;, &#39;软件学院&#39;, &#39;软件工程&#39;, 5, 2022),\n                                                                                            (2, &#39;202225220504&#39;, &#39;郭文杰&#39;, &#39;软件学院&#39;, &#39;软件工程&#39;, 5, 2022),\n                                                                                            (3, &#39;202225220901&#39;, &#39;张三&#39;, &#39;软件学院&#39;, &#39;软件工程&#39;, 9, 2022),\n                                                                                            (4, &#39;202325220904&#39;, &#39;李四&#39;, &#39;软件学院&#39;, &#39;软件工程&#39;, 9, 2023),\n                                                                                            (5, &#39;202225310902&#39;, &#39;王五&#39;, &#39;数学与信息学院&#39;, &#39;计算机科学与技术&#39;, 9, 2022);\n\n\n-- 课程表格\ncreate table courses(\n    course_id int unsigned primary key auto_increment comment &#39;主键课程id&#39;,\n    name varchar(20) not null comment &#39;课程名字&#39;,\n    teacher varchar(10) not null comment &#39;教师名字&#39;,\n    time varchar(20) not null comment &#39;上课时间&#39;,\n    location varchar(20) not null comment &#39;上课地点&#39;,\n    day_of_week int not null comment &#39;星期几上课&#39;\n)comment &#39;课程表格&#39;;\n-- 课程表测试数据\ninsert into courses(course_id, name, teacher, time, location, day_of_week) values(101, &#39;数据结构&#39;, &#39;张老师&#39;, &#39;周一第1-2节&#39;, &#39;4201&#39;, 1),\n                                                                                 (102, &#39;数据库&#39;, &#39;陈老师&#39;, &#39;周三第1-2节&#39;, &#39;4311&#39;, 3),\n                                                                                 (103, &#39;面向对象程序设计&#39;, &#39;王老师&#39;, &#39;周四第3-4节&#39;, &#39;4403&#39;, 4),\n                                                                                 (104, &#39;C语言程序设计&#39;, &#39;周老师&#39;, &#39;周二第7-8节&#39;, &#39;4402&#39;, 2),\n                                                                                 (105, &#39;高等数学&#39;, &#39;王老师&#39;, &#39;周四第3-4节&#39;, &#39;3201&#39;, 4),\n                                                                                 (106, &#39;大学英语&#39;, &#39;冯老师&#39;, &#39;周一第7-8节&#39;, &#39;3311&#39;, 1),\n                                                                                 (107, &#39;数据结构&#39;, &#39;张老师&#39;, &#39;周三第1-2节&#39;, &#39;4301&#39;, 3),\n                                                                                 (108, &#39;计算机组成原理&#39;, &#39;黄老师&#39;, &#39;周五第5-6节&#39;, &#39;1502&#39;, 5),\n                                                                                 (109, &#39;数字电路&#39;, &#39;王老师&#39;, &#39;周二第1-2节&#39;, &#39;3301&#39;, 2),\n                                                                                 (110, &#39;近代史纲要&#39;, &#39;陈老师&#39;, &#39;周五第5-6节&#39;, &#39;5c501&#39;, 5),\n                                                                                 (111, &#39;离散结构&#39;, &#39;李老师&#39;, &#39;周四第1-2节&#39;, &#39;5a601&#39;, 4);\n\n\n\n\n-- 选课表格\ncreate table enrollments(\n    enrollment_id int unsigned primary key auto_increment comment &#39;主键选课id&#39;,\n    student_id int unsigned not null comment &#39;学生id&#39;,\n    course_id int unsigned not null comment &#39;课程id&#39;,\n    FOREIGN KEY (student_id) REFERENCES students(student_id),\n    FOREIGN KEY (course_id) REFERENCES courses(course_id)\n)comment &#39;选课表格&#39;;\n-- 选课表测试数据\ninsert into enrollments(enrollment_id, student_id, course_id) values(1, 1, 101),\n                                                                    (2, 1, 102),\n                                                                    (3, 1, 103),\n                                                                    (4, 1, 106),\n                                                                    (5, 1, 107),\n                                                                    (6, 1, 109),\n                                                                    (7, 2, 101),\n                                                                    (8, 2, 102),\n                                                                    (9, 2, 103),\n                                                                    (10, 2, 106),\n                                                                    (11, 2, 107),\n                                                                    (12, 2, 109),\n                                                                    (13, 3, 103),\n                                                                    (14, 3, 111),\n                                                                    (15, 3, 101),\n                                                                    (16, 3, 107),\n                                                                    (17, 3, 106),\n                                                                    (18, 3, 102),\n                                                                    (19, 4, 104),\n                                                                    (20, 4, 110),\n                                                                    (21, 4, 109),\n                                                                    (22, 4, 108),\n                                                                    (23, 5, 103),\n                                                                    (24, 5, 108),\n                                                                    (25, 5, 109),\n                                                                    (26, 5, 111),\n                                                                    (27, 5, 106);\n\n\n\n\n\n-- 待办表格\ncreate table tasks(\n    task_id int unsigned primary key auto_increment comment &#39;主键任务id&#39;,\n    real_student_id varchar(20) not null comment &#39;学号&#39;,\n    description varchar(100) not null comment &#39;任务描述&#39;,\n    status tinyint(1) not null comment &#39;任务状态&#39;,\n    create_time datetime not null comment &#39;创建时间&#39;,\n    update_time datetime not null comment &#39;更新时间&#39;,\n    FOREIGN KEY (real_student_id) REFERENCES students(real_student_id)\n)comment &#39;待办表格&#39;;\n-- 待办表测试数据\ninsert into tasks(task_id, real_student_id, description, status, create_time, update_time) values (1, &#39;202225220503&#39;, &#39;完成Java实验任务&#39;, 0, now(), now()),\n                                                                                                  (2, &#39;202225220503&#39;, &#39;完成C语言实验任务&#39;, 1, now(), now()),\n                                                                                                  (3, &#39;202225220504&#39;, &#39;完成数据结构课程设计&#39;, 0, now(), now()),\n                                                                                                  (4, &#39;202225220504&#39;, &#39;完成Java实验任务&#39;, 1, now(), now()),\n                                                                                                  (5, &#39;202225220901&#39;, &#39;完成高等数学周末作业&#39;, 0, now(), now()),\n                                                                                                  (6, &#39;202325220904&#39;, &#39;完成大学英语周末作业&#39;, 0, now(), now()),\n                                                                                                  (7, &#39;202225310902&#39;, &#39;完成数据库实验任务&#39;, 1, now(), now()),\n                                                                                                  (8, &#39;202225310902&#39;, &#39;完成Java实验任务&#39;, 0, now(), now());二.接口文档1.课程管理1.1 课程列表查询1.1.1 基本信息​\t\t| 请求路径：&#x2F;courses&#x2F;{realStudentId}\n​        | 请求方式：GET\n​        | 接口描述：该接口用于根据学号进行学生课表数据查询\n1.1.2 请求参数参数格式：路径参数\n参数说明：\n\n\n\n参数名\n类型\n是否必须\n备注\n\n\n\nrealStudentId\nstring\n必须\n学号\n\n\n请求参数样例：\ntxt/courses/2022252205031.1.3响应数据参数格式： application&#x2F;json\n参数说明：\n\n\n\n参数名\n类型\n是否必须\n备注\n\n\n\ncode\nnumber\n必须\n响应码，1代表成功，0代表失败\n\n\nmsg\nstring\n非必须\n提示信息\n\n\ndata\nobject\n非必须\n返回的数据\n\n\n|- courseId\nnumber\n非必须\n课程id\n\n\n|- name\nstring\n非必须\n课程名称\n\n\n|- teacher\nstring\n非必须\n老师名称\n\n\n|- time\nstring\n非必须\n上课时间\n\n\n|- location\nstring\n非必须\n上课地点\n\n\n|- dayOfWeek\nnumber\n非必须\n上课时间是星期几\n\n\n响应数据样例：\ntxt&#123;\n    &quot;code&quot;: 1,\n    &quot;msg&quot;: &quot;success&quot;,\n    &quot;data&quot;: [\n        &#123;\n            &quot;courseId&quot;: 101,\n            &quot;name&quot;: &quot;数据结构&quot;,\n            &quot;teacher&quot;: &quot;张老师&quot;,\n            &quot;time&quot;: &quot;周一第1-2节&quot;,\n            &quot;location&quot;: &quot;4201&quot;,\n            &quot;dayOfWeek&quot;: 1\n        &#125;,\n        &#123;\n            &quot;courseId&quot;: 102,\n            &quot;name&quot;: &quot;数据库&quot;,\n            &quot;teacher&quot;: &quot;陈老师&quot;,\n            &quot;time&quot;: &quot;周三第1-2节&quot;,\n            &quot;location&quot;: &quot;4311&quot;,\n            &quot;dayOfWeek&quot;: 3\n        &#125;,\n        &#123;\n            &quot;courseId&quot;: 103,\n            &quot;name&quot;: &quot;面向对象程序设计&quot;,\n            &quot;teacher&quot;: &quot;王老师&quot;,\n            &quot;time&quot;: &quot;周四第3-4节&quot;,\n            &quot;location&quot;: &quot;4403&quot;,\n            &quot;dayOfWeek&quot;: 4\n        &#125;,\n        &#123;\n            &quot;courseId&quot;: 106,\n            &quot;name&quot;: &quot;大学英语&quot;,\n            &quot;teacher&quot;: &quot;冯老师&quot;,\n            &quot;time&quot;: &quot;周一第7-8节&quot;,\n            &quot;location&quot;: &quot;3311&quot;,\n            &quot;dayOfWeek&quot;: 1\n        &#125;,\n        &#123;\n            &quot;courseId&quot;: 107,\n            &quot;name&quot;: &quot;数据结构&quot;,\n            &quot;teacher&quot;: &quot;张老师&quot;,\n            &quot;time&quot;: &quot;周三第1-2节&quot;,\n            &quot;location&quot;: &quot;4301&quot;,\n            &quot;dayOfWeek&quot;: 3\n        &#125;,\n        &#123;\n            &quot;courseId&quot;: 109,\n            &quot;name&quot;: &quot;数字电路&quot;,\n            &quot;teacher&quot;: &quot;王老师&quot;,\n            &quot;time&quot;: &quot;周二第1-2节&quot;,\n            &quot;location&quot;: &quot;3301&quot;,\n            &quot;dayOfWeek&quot;: 2\n        &#125;\n    ]\n&#125;2.待办管理1.1查询待办1.1.1基本信息​        | 请求路径：&#x2F;tasks&#x2F;{realStudentId}\n​        | 请求方式：GET\n​        | 接口描述：该接口用于根据学号进行待办事项数据查询\n1.1.2请求参数参数格式：路径参数\n参数说明：\n\n\n\n参数名\n类型\n是否必须\n备注\n\n\n\nrealStudentId\nstring\n必须\n学号\n\n\n请求参数样例：\ntxt/tasks/2022252205031.1.3响应数据参数格式： application&#x2F;json\n参数说明：\n\n\n\n参数名\n类型\n是否必须\n备注\n\n\n\ncode\nnumber\n必须\n响应码，1代表成功，0代表失败\n\n\nmsg\nstring\n非必须\n提示信息\n\n\ndata\nobject\n非必须\n返回的数据\n\n\n|- taskId\nnumber\n非必须\n待办id\n\n\n|- description\nstring\n非必须\n待办内容\n\n\n|- status\nnumber\n非必须\n完成状态，0代表未完成，1代表完成\n\n\n|- createTime\nstring\n非必须\n创建时间\n\n\n|- updateTime\nstring\n非必须\n更新时间\n\n\n响应数据样例：\ntxt&#123;\n    &quot;code&quot;: 1,\n    &quot;msg&quot;: &quot;success&quot;,\n    &quot;data&quot;: [\n        &#123;\n            &quot;taskId&quot;: 1,\n            &quot;description&quot;: &quot;完成Java实验任务&quot;,\n            &quot;status&quot;: 0,\n            &quot;createTime&quot;: &quot;2023-11-05T21:36:43&quot;,\n            &quot;updateTime&quot;: &quot;2023-11-05T21:36:43&quot;\n        &#125;,\n        &#123;\n            &quot;taskId&quot;: 2,\n            &quot;description&quot;: &quot;完成C语言实验任务&quot;,\n            &quot;status&quot;: 1,\n            &quot;createTime&quot;: &quot;2023-11-05T21:36:43&quot;,\n            &quot;updateTime&quot;: &quot;2023-11-05T21:36:43&quot;\n        &#125;\n    ]\n&#125;1.2 删除待办1.2.1 基本信息​\t\t| 请求路径： &#x2F;tasks&#x2F;{taskId}\n​        | 请求方式：DELETE\n​        | 接口描述：该接口用于根据待办事项ID删除待办事项数据\n1.2.2 请求参数参数格式：路径参数\n参数说明：\n\n\n\n参数名\n类型\n是否必须\n备注\n\n\n\ntaskId\nnumber\n必须\n待办事项ID\n\n\n请求参数样例：\ntxt/tasks/91.2.3 响应数据参数格式：application&#x2F;json\n参数说明：\n\n\n\n参数名\n类型\n是否必须\n备注\n\n\n\ncode\nnumber\n必须\n响应码，1代表成功，0代表失败\n\n\nmsg\nstring\n非必须\n提示信息\n\n\ndata\nobject\n非必须\n返回的数据\n\n\n响应数据样例：\ntxt&#123;\n    &quot;code&quot;: 1,\n    &quot;msg&quot;: &quot;success&quot;,\n    &quot;data&quot;: null\n&#125;1.3 添加待办1.3.1 基本信息​\t\t| 请求路径： &#x2F;tasks\n​        | 请求方式：POST\n​        | 接口描述：该接口用于添加待办事项数据\n1.3.2 请求参数参数格式：application&#x2F;json\n参数说明：\n\n\n\n参数名\n类型\n是否必须\n备注\n\n\n\nrealStudentId\nstring\n必须\n学号，必须是student表里有的学号\n\n\ndescription\nstring\n必须\n待办事项\n\n\nstatus\nnumber\n必须\n完成状态，0代表未完成，1代表完成\n\n\n请求参数样例：\ntxt&#123;\n   &quot;realStudentId&quot;: &quot;202225220503&quot;,\n   &quot;description&quot;: &quot;完成Java实验任务&quot;,\n   &quot;status&quot;: 0\n&#125;1.3.3 响应数据参数格式：application&#x2F;json\n参数说明：\n\n\n\n参数名\n类型\n是否必须\n备注\n\n\n\ncode\nnumber\n必须\n响应码，1代表成功，0代表失败\n\n\nmsg\nstring\n非必须\n提示信息\n\n\ndata\nobject\n非必须\n返回的数据\n\n\n响应数据样例：\ntxt&#123;\n    &quot;code&quot;: 1,\n    &quot;msg&quot;: &quot;success&quot;,\n    &quot;data&quot;: null\n&#125;1.4 修改待办1.4.1 基本信息​\t\t| 请求路径： &#x2F;tasks&#x2F;{taskId}\n​        | 请求方式：PUT\n​        | 接口描述：该接口用于修改待办事项数据\n1.4.2 请求参数参数格式：application&#x2F;json\n参数说明：\n\n\n\n参数名\n类型\n是否必须\n备注\n\n\n\nrealStudentId\nstring\n必须\n学号，必须是student表里有的学号\n\n\ndescription\nstring\n必须\n待办事项\n\n\nstatus\nnumber\n必须\n完成状态，0代表未完成，1代表完成\n\n\n请求参数样例：\ntxt&#123;\n   &quot;realStudentId&quot;: &quot;202225220503&quot;,\n   &quot;description&quot;: &quot;完成Java实验任务&quot;,\n   &quot;status&quot;: 0\n&#125;,1.4.3 响应数据参数格式：application&#x2F;json\n参数说明：\n\n\n\n参数名\n类型\n是否必须\n备注\n\n\n\ncode\nnumber\n必须\n响应码，1代表成功，0代表失败\n\n\nmsg\nstring\n非必须\n提示信息\n\n\ndata\nobject\n非必须\n返回的数据\n\n\n响应数据样例：\ntxt&#123;\n    &quot;code&quot;: 1,\n    &quot;msg&quot;: &quot;success&quot;,\n    &quot;data&quot;: null\n&#125;3.学生管理3.1 添加学生3.1.1 基本信息​\t\t| 请求路径： &#x2F;students\n​        | 请求方式：POST\n​        | 接口描述：该接口用于添加待办事项数据\n3.1.2 请求参数参数格式：application&#x2F;json\n参数说明：\n\n\n\n参数名\n类型\n是否必须\n备注\n\n\n\nrealStudentId\nstring\n必须\n学号\n\n\nname\nstring\n必须\n学生姓名\n\n\ncollege\nstring\n必须\n学院\n\n\nmajor\nstring\n必须\n专业\n\n\nclassNum\nnumber\n必须\n班级\n\n\ngrade\nnumber\n必须\n年级\n\n\n请求参数样例：\ntxt&#123;\n   &quot;realStudentId&quot;: &quot;202225220505&quot;,\n   &quot;name&quot;: &quot;何泳泳&quot;,\n   &quot;college&quot;: &quot;软件学院&quot;,\n   &quot;major&quot;: &quot;软件工程&quot;,\n   &quot;classNum&quot;: 5,\n   &quot;grade&quot;: 2022\n&#125;3.1.3响应数据参数格式：application&#x2F;json\n参数说明：\n\n\n\n参数名\n类型\n是否必须\n备注\n\n\n\ncode\nnumber\n必须\n响应码，1代表成功，0代表失败\n\n\nmsg\nstring\n非必须\n提示信息\n\n\ndata\nobject\n非必须\n返回的数据\n\n\n响应数据样例：\ntxt&#123;\n    &quot;code&quot;: 1,\n    &quot;msg&quot;: &quot;success&quot;,\n    &quot;data&quot;: null\n&#125;","slug":"基于uni-app框架开发的校园课表微信小程序","date":"2023-11-06T05:28:12.000Z","categories_index":"Program","tags_index":"学习,Java","author_index":"Fioransh"},{"id":"452d114e7a0301edf39e3da31eb54488","title":"6神，启动！","content":"本文旨在测试博客图片上传功能，为了解决博客上传图片失败问题努力了几个小时后终于发现了问题所在，在hexo中的 hexo-asset-image 图片模块和 hexo-abbrlink 不兼容导致。\n解决方法：在node_modules&#x2F;hexo-asset-image&#x2F;index.js中将代码中的”var endPos &#x3D; link.length - 1”改为”-5”即可解决。\n\n6神，启动！\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"6神，启动！","date":"2023-09-09T16:00:00.000Z","categories_index":"Blog","tags_index":"黄怡慈","author_index":"Fioransh"},{"id":"a5170803adaf724d5767bb183841fa47","title":"SCAU软件工程经济学知识点","content":"SCAU软件工程经济学知识点*有哪些分类，有哪些方法，有哪些特点*\n第一章\n1.软件的定义：它是包括程序、数据及其相关文档的完整集合。\n2.按软件功能分类：系统、支撑、应用。\n3.按规模分类：微型、小型、中型、大型、超大型、极大型。\n4.按标准化程度分类：标准化、半定制、软件服务（定制软件）。\n5.按硬件或软件关联分类：嵌入型、组织型、半独立型。\n6.按工作方式：实时处理、多用户分时处理、交互式、批处理。\n7.软件特点：信息产品、从头开始生产、知识结晶、手工方式生产、无需库存成本、壁垒低、对用户有粘性。\n8.软件产业是指软件产品和软件服务相关的一切经济活动和关系的总称。\n9.软件产业特点：高技术高附加值高效益、高度关联性、国际化、专业化分工、规模化经济效益。\n10.发展模式：“全面领先”技术与服务领导型——美国，“整机带动”嵌入式系统开发型——日韩，“软件集散”生产本地化型——爱尔兰，“外包服务”国际加工服务型——印度。\n11.产业不足：关键核心缺乏、自主创新能力弱、企业规模小、产权保护力度弱。\n12.软件企业：分为软件产品企业和软件服务企业。\n13.软件工程生产过程方法论：技术学、经济学、管理学。 \n14.软件生产周期：从概念形成开始，经过开发、使用和维护，直到最后退役的全过程。\n15.计算题：功能点计算方法\n\nW为加权系数，d为基本信息量。\nwd为题目表格中数据相乘后相加。\nFi环境复杂度参数（题目给出）\n16.衡量产品质量高低的指标：技术性能指标（处理能力）和可靠性指标（持久能力）。\n17.软件的可靠性是关系到系统成败的重要因素。\n18.软件工程经济学四个部分：\n\n第二章\n1.沉没成本：已经发生的不可收回的支出。\n2.任何对软件项目的工程经济分析与研究都必须从实体维、时间维和要素维等三个维度展开。\n3.经济活动分析与评价特征：系统分析的目的是为了提高工程经济活动的经济效果，经济效果大多与“未来”有关，系统分析强调的是在技术可行性基础上的经济分析，系统评价是通过“比较”来完成的，统评价应是各利益主体目标的相互协调与均衡。\n4.投资：实现目标而进行资金投放或运行的经济活动。\n5.投资活动包括：生产性投资（保证生产运行）和非生产性投资（证券投资）。\n6.建设项目投资包括：固定资产投资（设备）、流动资金投资（工资原材料）、无形资产投资（使用权）。\n7.筹资和资金运用、项目可行性、市场调查。\n8.项目的可行性分析：必要性、可实现性、效果性与风险性。\n9.总成本费用：生产成本、管理费用、财务费用和销售费用。\n10.收入：销售收入、劳务收入、使用费收入、股利收入及利息收入。\n11.税金：增值税（增值额）、营业税、企业所得税（生产经营）、城乡维护建设税（维护公共设施）、教育费附加。\n12.所得税：企业所得税与个人所得税。\n13.利润：\n\n14.资金的时间价值：绝对金额随时间转移后其增加或减少的金额部分。\n15.计算题：年利率（本利和）的计算。\n\n16.现金流量图：箭头向上者表示现金流入(或正现金流)，箭头向下者表示现金流出(或负现金流)。注意现金流量图对象！\n17.计算题：初值和本利的计算。\n\n例题：\n\n\n\n\n18.***计算题：等额系列现金流。\n\n\nA为每年等额偿还&#x2F;存储的金额。Sn为最后一年金额。P0为首年金额。\nA&#x3D;P0 × CRF（偿还）\nA&#x3D;Sn × SFF （存储）\n例题：\n\n\n19.招标与投标的特征：组织性（招标特有）、公开性、一次性决定、公平性。\n20.招标类型：按公开程度和参加人数的限制条件分类，可划分为竞争性招标（公开招标）和有限招标（邀请招标），按合同的条件分类，可分为自动条件招标、随机条件招标、谈判招标。\n 第三章\n1.成本的经济内容：劳动资料方面的消耗、劳动对象方面的消耗、人工方面的消费的消耗。\n2.成本的特点：消耗性、补偿性、目的性、综合性、代偿性。\n3.成本的分类：按企业主要经营活动——研究与开发成本、采购成本、生产成本、经营成本、管理费用。按成本与产量的对应关系——变动成本与固定成本。按成本的确定时间——预测成本、定额成本、计划成本、实际成本。\n4.软件成本构成：硬件购置费用、网络通信费用、软件购置费用、基建费用、人力资源费用、硬件生产测试费、软件开发&#x2F;测试费用、水、电、运输费用、消耗材料及废品损失费用、培训费用、系统营销费用、管理费用、其他费用。\n5.减少成本测算误差的策略。\n6.计算题：功能分解法（不考大题）\n最小可能值ai、最大可能值bi、最可能值mi、平均规模Ej\n\n成本费用Coi、劳动生产率Eoi、各子系统模块成本Ci、各子系统工作量Mi\n软件总成本Cs、总工作量Es（Ms）\n\n\n例题：习题三第3题\n7.计算题：影响因子法与COCOMO模型\nU为综合影响要素\n\n\nCs软件开发成本、a工时费用率、Ms修正工作量、Mo基本工作量\nL软件开发规模、Td工期、rkhd形式参数（根据类型判断）。\n组织性：程序规模较小；嵌入型：硬件软件限制条件下运行；半独立型：规模较大。\n例题：\n\n\n8.计算题：类比法估计目标软件成本\n改变调整系数AAF、原软件开发规模La、新软件开发规模Lb\nDM设计修改百分比、CM代码修改百分比、IM集成修改百分比\n\nW1 &#x3D; 0.4、 W2 &#x3D; W3 &#x3D; 0.3\n\n9.ABC分类法\n\n\n成本控制的重点研究对象：ABC分类（从大到小排序）\n10.计算题：挣值管理法\n四个关键指标：总预算成本TBC、累计预算成本CBC、累计实现成本CAC、累计实现价值CEV。\n四个绩效评价参数：成本偏差CV：CV&#x3D;CEV-CAC、成本绩效CPI：CPI&#x3D;CEV&#x2F;CAC、进度偏差SV：SV&#x3D;CEV-CBC、进度绩效SPI：SPI&#x3D;CEV&#x2F;CBC。\n完工预测成本FCAC：FCAC&#x3D;TBC&#x2F;CPI、FCAC&#x3D;CAC+(TBC-CEV)、FCAC&#x3D;CAC+重估剩余工程预算。\n11.软件产品的定价和营销是软件生存周期中的两项重要工程经济活动。\n12.产品价格是由其价值所决定的。\n13.软件价格的影响因素：用户需求、产品成本、市场竞争和垄断及环境因素。\n14.软件的定价目标：利润导向、收益导向、销售导向、竞争导向、品牌导向、维持生存导向。\n15.软件的定价方法：成本导向定价法、需求导向定价法、竞争导向定价法。\n16.软件的定价策略：撇脂和渗透定价策略，捆绑定价策略，免费使用策略，歧视定价策略。\n17.软件的市场营销过程一般包括： ① 目标市场定位 ② 确定产品策略③ 确定定价策略④ 确定(销售)渠道策略 ⑤ 确定促销策略⑥ 确定服务策略。\n第四章\n1.项目评价：净现值法、内部收益率法和投资回收期法。\n2.计算题：净现值法NPV\n\nBt寿命期内收益、Ct支出（成本）、Dt残值、Kt投资额、i基准贴现率、N使用年限\nNPV&gt;0 投资可行 NPV&lt;&#x3D;0投资不可行\n3.计算题：内部收益法（不要求计算）了解原理：求NPV(IRR)（对分法）。\n4.计算题：投资回收期法\n\n5.计算题：净现值法进行多方案比较\n\n6.计算题：净年值法进行多方案比较\nCRF资金回收系数\n\n7.计算题：研究期法（是否承认未使用价值）\n\n8.计算题：费用现值法\n\n9.计算题：年费用现值法\n\n10.效益的分类：成本与支出费用的节省、社会财富的增加、服务水平的提高、管理水平的提高。\n11.对软件项目实际效益与预测效益评价常采用系统运行前后对比法和参数估计法。\n12.软件的社会效益评价：系统评价以定性分析为主、社会评价无通用方法、对社会的贡献以间接效益、无形效果和外部效果为主。\n13.软件项目的风险：\n\n第五章（略）\n第六章\n1.软件的开发的产品目标：质量、成本、进度和团队。\n2.计划网络图与关键路径！！！\n特征：有向性和不可逆转性、连通性、封闭性。\n当计划网络出现多个起始结点或多个终止结点时，应引入虚活动。\n\n\n\n\n3.软件开发团队的组织建设\n\n\n\n","slug":"SCAU软件工程经济学","date":"2023-06-28T18:28:12.000Z","categories_index":"Study","tags_index":"学习","author_index":"Fioransh"},{"id":"bc926e4a66038b5c73c00f3880f05287","title":"响应状态码","content":"一、状态码大类\n\n\n状态码分类\n说明\n\n\n\n1xx\n响应中——临时状态码，表示请求已经接受，告诉客户端应该继续请求或者如果它已经完成则忽略它\n\n\n2xx\n成功——表示请求已经被成功接收，处理已完成\n\n\n3xx\n重定向——重定向到其它地方：它让客户端再发起一个请求以完成整个处理。\n\n\n4xx\n客户端错误——处理发生错误，责任在客户端，如：客户端的请求一个不存在的资源，客户端未被授权，禁止访问等\n\n\n5xx\n服务器端错误——处理发生错误，责任在服务端，如：服务端抛出异常，路由出错，HTTP版本不支持等\n\n\n二、常见的响应状态码\n\n\n状态码\n英文描述\n解释\n\n\n\n&#x3D;&#x3D;200&#x3D;&#x3D;\nOK\n客户端请求成功，即处理成功，这是我们最想看到的状态码\n\n\n302\nFound\n指示所请求的资源已移动到由Location响应头给定的 URL，浏览器会自动重新访问到这个页面\n\n\n304\nNot Modified\n告诉客户端，你请求的资源至上次取得后，服务端并未更改，你直接用你本地缓存吧。隐式重定向\n\n\n400\nBad Request\n客户端请求有语法错误，不能被服务器所理解\n\n\n403\nForbidden\n服务器收到请求，但是拒绝提供服务，比如：没有权限访问相关资源\n\n\n&#x3D;&#x3D;404&#x3D;&#x3D;\nNot Found\n请求资源不存在，一般是URL输入有误，或者网站资源被删除了\n\n\n405\nMethod Not Allowed\n请求方式有误，比如应该用GET请求方式的资源，用了POST\n\n\n428\nPrecondition Required\n服务器要求有条件的请求，告诉客户端要想访问该资源，必须携带特定的请求头\n\n\n429\nToo Many Requests\n指示用户在给定时间内发送了太多请求（“限速”），配合 Retry-After(多长时间后可以请求)响应头一起使用\n\n\n431\n Request Header Fields Too Large\n请求头太大，服务器不愿意处理请求，因为它的头部字段太大。请求可以在减少请求头域的大小后重新提交。\n\n\n&#x3D;&#x3D;500&#x3D;&#x3D;\nInternal Server Error\n服务器发生不可预期的错误。服务器出异常了，赶紧看日志去吧\n\n\n503\nService Unavailable\n服务器尚未准备好处理请求，服务器刚刚启动，还未初始化好\n\n\n状态码大全：https://cloud.tencent.com/developer/chapter/13553 \n","slug":"响应状态码","date":"2023-03-14T05:28:12.000Z","categories_index":"Study","tags_index":"学习,网络","author_index":"Fioransh"}]