[{"id":"edf904054aa8b48f1e963a1dfb1f4ee3","title":"算法性能分析","content":"1.时间复杂度1.1 什么是时间复杂度时间复杂度是一个函数，它定性描述该算法的运行时间。\n通常会估算算法的操作单元数量来代表程序消耗的时间，这里默认CPU的每个单元运行消耗的时间都是相同的。假设算法的问题规模为n，那么操作单元数量便用函数f(n)来表示，随着数据规模n的增大，算法执行时间的增长率和f(n)的增长率相同，这称作为算法的渐近时间复杂度，简称时间复杂度，记为 O(f(n))。\n1.2什么是大O算法导论给出的解释：大O用来表示上界的，当用它作为算法的最坏情况运行时间的上界，就是对任意数据输入的运行时间的上界。\n快速排序是O(nlogn)，但是当数据已经有序情况下，快速排序的时间复杂度是O(n^2) 的，**所以严格从大O的定义来讲，快速排序的时间复杂度应该是O(n^2)**。\n但是我们依然说快速排序是O(nlogn)的时间复杂度，这个就是业内的一个默认规定，这里说的O代表的就是一般情况，而不是严格的上界。\n1.3不同数据规模的差异大O就是数据量级突破一个点且数据量级非常大的情况下所表现出的时间复杂度，这个数据量也就是常数项系数已经不起决定性作用的数据量。\n我们说的时间复杂度都是省略常数项系数的，是因为一般情况下都是默认数据规模足够的大，基于这样的事实，给出的算法时间复杂的的一个排行如下所示：\nO(1)常数阶 &lt; O(logn)对数阶 &lt; O(n)线性阶 &lt; O(nlogn)线性对数阶 &lt; O(n^2)平方阶 &lt; O(n^3)立方阶 &lt; O(2^n)指数阶\n1.4例子题目描述：找出n个字符串中相同的两个字符串（假设这里只有两个相同的字符串）。\n1）可能会忽略了字符串比较的时间消耗，这里并不像int 型数字做比较那么简单，除了n^2 次的遍历次数外，字符串比较依然要消耗m次操作（m也就是字母串的长度），所以时间复杂度是O(m × n × n)。\n2）先排对n个字符串按字典序来排序，排序后n个字符串就是有序的，意味着两个相同的字符串就是挨在一起，然后在遍历一遍n个字符串，这样就找到两个相同的字符串了。\n那看看这种算法的时间复杂度，快速排序时间复杂度为O(nlogn)，依然要考虑字符串的长度是m，那么快速排序每次的比较都要有m次的字符比较的操作，就是O(m × n × log n) 。\n之后还要遍历一遍这n个字符串找出两个相同的字符串，别忘了遍历的时候依然要比较字符串，所以总共的时间复杂度是 O(m × n × logn + n × m)。\n我们对O(m × n × log n + n × m) 进行简化操作，把m × n提取出来变成 O(m × n × (logn + 1))，再省略常数项最后的时间复杂度是 O(m × n × log n)。\nps：例子仅用于讲解示范时间复杂度。\n2.算法为什么会超时2.1 超时怎么来程序运行的时间超过了规定的时间，一般OJ（online judge）的超时时间就是1s，也就是用例数据输入后最多要1s内得到结果，暂时还不清楚leetcode的判题规则，下文为了方便讲解，暂定超时时间就是1s。\n如果写出了一个$O(n)$的算法 ，其实可以估算出来n是多大的时候算法的执行时间就会超过1s了。\n如果n的规模已经足够让$O(n)$的算法运行时间超过了1s，就应该考虑log(n)的解法了。\n3.递归算法的时间复杂度面试题：求x的n次方\n最直观的方式应该就是，一个for循环求出结果，代码如下：\ncppint function1(int x, int n) &#123;\n    int result = 1;  // 注意 任何数的0次方等于1\n    for (int i = 0; i &lt; n; i++) &#123;\n        result = result * x;\n    &#125;\n    return result;\n&#125;时间复杂度为O(n)，此时面试官会说，有没有效率更好的算法呢。\n如果此时没有思路，不要说：我不会，我不知道了等等。\n可以和面试官探讨一下，询问：“可不可以给点提示”。面试官提示：“考虑一下递归算法”。\n那么就可以写出了如下这样的一个递归的算法，使用递归解决了这个问题。\ncppint function2(int x, int n) &#123;\n    if (n == 0) &#123;\n        return 1; // return 1 同样是因为0次方是等于1的\n    &#125;\n    return function2(x, n - 1) * x;\n&#125;一些同学可能一看到递归就想到了O(log n)，其实并不是这样，递归算法的时间复杂度本质上是要看: 递归的次数 * 每次递归中的操作次数。\n每次n-1，递归了n次时间复杂度是O(n)，每次进行了一个乘法操作，乘法操作的时间复杂度一个常数项O(1)，所以这份代码的时间复杂度是 n × 1 &#x3D; O(n)。\n这个时间复杂度就没有达到面试官的预期。于是又写出了如下的递归算法的代码：\ncppint function3(int x, int n) &#123;\n    if (n == 0) return 1;\n    if (n == 1) return x;\n\n    if (n % 2 == 1) &#123;\n        return function3(x, n / 2) * function3(x, n / 2)*x;\n    &#125;\n    return function3(x, n / 2) * function3(x, n / 2);\n&#125;**时间复杂度忽略掉常数项-1之后，这个递归算法的时间复杂度依然是O(n)**。对，你没看错，依然是O(n)的时间复杂度！\n于是又写出如下递归算法的代码：\ncppint function4(int x, int n) &#123;\n    if (n == 0) return 1;\n    if (n == 1) return x;\n    int t = function4(x, n / 2);// 这里相对于function3，是把这个递归操作抽取出来\n    if (n % 2 == 1) &#123;\n        return t * t * x;\n    &#125;\n    return t * t;\n&#125;依然还是看他递归了多少次，可以看到这里仅仅有一个递归调用，且每次都是n&#x2F;2 ，所以这里我们一共调用了log以2为底n的对数次。\n**每次递归了做都是一次乘法操作，这也是一个常数项的操作，那么这个递归算法的时间复杂度才是真正的O(logn)**。\n4.空间复杂度分析4.1什么是空间复杂度是对一个算法在运行过程中占用内存空间大小的量度，记做S(n)&#x3D;O(f(n)。\n空间复杂度(Space Complexity)记作S(n) 依然使用大O来表示。利用程序的空间复杂度，可以对程序运行中需要多少内存有个预先估计。\n关注空间复杂度有两个常见的相关问题\n空间复杂度是考虑程序（可执行文件）的大小么？\n空间复杂度是考虑程序运行时占用内存的大小，而不是可执行文件的大小。\n空间复杂度是准确算出程序运行时所占用的内存么？\n不要以为空间复杂度就已经精准的掌握了程序的内存使用大小，很多因素会影响程序真正内存使用大小，例如编译器的内存对齐，编程语言容器的底层实现等等这些都会影响到程序内存的开销。\n所以空间复杂度是预先大体评估程序内存使用的大小。\n说到空间复杂度，我想同学们在OJ（online judge）上应该遇到过这种错误，就是超出内存限制，一般OJ对程序运行时的所消耗的内存都有一个限制。\n为了避免内存超出限制，这也需要我们对算法占用多大的内存有一个大体的预估。\n同样在工程实践中，计算机的内存空间也不是无限的，需要工程师对软件运行时所使用的内存有一个大体评估，这都需要用到算法空间复杂度的分析。\n4.2例子什么时候的空间复杂度是$O(1)$呢，C++代码如下：\ncppint j = 0;\nfor (int i = 0; i &lt; n; i++) &#123;\n    j++;\n&#125;第一段代码可以看出，随着n的变化，所需开辟的内存空间并不会随着n的变化而变化。即此算法空间复杂度为一个常量，所以表示为大O(1)。\n什么时候的空间复杂度是O(n)？\n当消耗空间和输入参数n保持线性增长，这样的空间复杂度为O(n)，来看一下这段C++代码\ncppint* a = new int(n);\nfor (int i = 0; i &lt; n; i++) &#123;\n    a[i] = i;\n&#125;我们定义了一个数组出来，这个数组占用的大小为n，虽然有一个for循环，但没有再分配新的空间，因此，这段代码的空间复杂度主要看第一行即可，随着n的增大，开辟的内存大小呈线性增长，即 O(n)。\n5.代码内存消耗5.1不同语言的内存管理不同的编程语言各自的内存管理方式。\n\nC&#x2F;C++这种内存堆空间的申请和释放完全靠自己管理\nJava 依赖JVM来做内存管理，不了解jvm内存管理的机制，很可能会因一些错误的代码写法而导致内存泄漏或内存溢出\nPython内存管理是由私有堆空间管理的，所有的python对象和数据结构都存储在私有堆空间中。程序员没有访问堆的权限，只有解释器才能操作。\n\n例如Python万物皆对象，并且将内存操作封装的很好，所以python的基本数据类型所用的内存会要远大于存放纯数据类型所占的内存，例如，我们都知道存储int型数据需要四个字节，但是使用Python 申请一个对象来存放数据的话，所用空间要远大于四个字节。\n5.2内存对齐再介绍一下内存管理中另一个重要的知识点：内存对齐。\n不要以为只有C&#x2F;C++才会有内存对齐，只要可以跨平台的编程语言都需要做内存对齐，Java、Python都是一样的。\n而且这是面试中面试官非常喜欢问到的问题，就是：为什么会有内存对齐？\n主要是两个原因\n\n平台原因：不是所有的硬件平台都能访问任意内存地址上的任意数据，某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。为了同一个程序可以在多平台运行，需要内存对齐。\n硬件原因：经过内存对齐后，CPU访问内存的速度大大提升。\n\n参考学习自代码随想录\n","slug":"算法性能分析","date":"2024-01-28T14:25:12.000Z","categories_index":"Blog","tags_index":"学习,算法","author_index":"Fioransh"},{"id":"8844fd48687a754eafe1c7b3d89d9e8e","title":"Hexo+gitee博客搭建流程","content":"写在前面本博客只是讲述安装流程，并不是纯面向小白的安装教程，在b站上有许多hexo的安装教程视频，可以参考b站教程进行安装。Hexo可以算是入门门槛最低的一种博客搭建手段了。这篇博客只是防止我以后忘记安装流程而编写，安装如遇到问题可以wx交流一下，不保证能解决。搭建环境开发项目是一件需要耐心的事情，可能会遇到各种各样的问题，要学会灵活网络搜索，你遇到的问题基本上都能解决，保持耐心，说不定马上你的问题就迎刃而解了。\n\n1.node js的安装和环境配置（由Ryan Dahl开发，是一个基于ChromeV8引擎的JavaScript运行环境，\n使用了一个事件驱动、非阻塞式I&#x2F;O模型，让JavaScript 运行在服务端的开发平台，\n它让JavaScript成为与PHP、Python、Perl、Ruby等服务端语言平起平坐的脚本语言\nnode 安装过程截图 \n\n安装可以无脑下一步，注意安装路径就行，不会有问题，如果不放心的话可以参考原文章的安装过程截图，有详细步骤，由于本文篇幅较长，这里就不再转载了。\n1.1 测试是否安装成功node -v\nnpm -v\n成功截图如下：\n解决npm查询不到版本号，方法一：https://past-taleggio-288.notion.site/node-24b6cf34d5c24186b7ef1ea7028b7fda\n1.2 配置环境变量详细截图在刚才安装nodejs的根目录下，创建node_global，node_cache文件夹以管理员身份打开cmd，配置路径`npm config set prefix \"E:\\develop\\nodejs\\node_global\"``npm config set cache \"E:\\develop\\nodejs\\node_cache\"`修改全局路径 node_global, 修改缓存路径 node_cache内路径需要根据自己实际情况来进行修改修改全局安装路径后，需要在系统环境变量Path中添加该路径，否则之后使用npm install –global xxx，xxx都报错找不到命令。 找到电脑环境配置  win10和win11：右键此电脑-属性-高级系统设置-高级-环境变量win11 还可以：点设置-系统-关于-高级系统设置-高级-环境变量\n完成以上操作后，在用户变量中创建NODE_PATH变量，变量值为node_modeules路径地址在系统变量中选择Path添加如下属性：\n\n2.安装git2.1 下载git官网https://git-scm.com/\n找到首页下方的Downloads\n下载对应系统（MAC、Windows、Linux&#x2F;Unix）安装包\n\n2.2 安装git安装git过程\n\n\n\n3.hexo下载npm install hexo-cli -g #安装hexo\n4.检查已安装各框架的版本git：\ngit --version\nhexo:\nhexo -v\n安装成功效果\n\n5.创建仓库及配置SSH连接5.1  创建gitee仓库（github同理）利用gitee仓库，存放静态网站资源，达到挂载网站的目的\n\n需要注意的是作为网站访问的这个仓库，仓库名称一定是，拥有者名+gitee.io\n5.2  生成ssh keys在博客文件夹根目录下，右键，调用git bash here功能\n\n先输入ssh查看是否已经安装ssh，git默认有安装\n本地生成ssh keys\ntxtssh-keygen -t rsa -C &quot;邮箱地址&quot;\n在本地电脑中找到.ssh文件夹\n\n一般默认都是，C:\\Users\\用户名.ssh.pub文件\n找到秘钥的位置，并用记事本打开**.pub文件**，复制其内容 (ctrl+a全选，ctrl+c复制，ctrl+v粘贴)\n打开gitee，头像下拉选项设置，找到SSH公钥（新建ssh秘钥）\n\n把在本地生成的秘钥内容粘贴至此秘钥处，标题可以随便取。\n测试ssh是否绑定成功（在git里操作）\ntxtssh -T git@gitee.com\n如果问你（yes or no），直接yes就可以得到上面这段话\n6.搭建本地博客创建一个放置博客文件夹的文件，在里面启用Git Bash Here\n\n初始化hexo\ntxthexo init\n\n生成hexo本地页面\n\ntxthexo s\n\n复制粘贴该地址到浏览器中，即可访问本地搭建的博客 http://localhost:4000\n\ntxthexo cl #clean #清理编译文件\nhexo g #generate #编译项目\nhexo s #server #本地预览运行项目7.上传本地博客至gitee7.1 修改配置文件在创建博客文件夹的根目录下修改-config.yml文件\n\n\ntxtdeploy:  \n   type: git  \n   repository: 你的gitee地址  \n   branch: main7.2 安装hexo-deployer-git 自动部署发布工具\ntxtnpm install hexo-deployer-git --save7.3  编译文件生成界面\ntxthexo g7.4  本地文件上传到Gitee\ntxthexo d成功后\n\n可以直接访问仓库名如:\n https://xxx.gitee.io\n\n出现如图画面，恭喜你完成了hexo的博客搭建。\n8.安装Aurora主题本步骤非必须，可以在hexo的官方网站寻找自己喜欢的主题进行安装，安装流程大致相似，每个主题也可能有自己独特的地方需要设置，具体参照对应主题自己的官方文档进行参考\nAurora官方文档参考：https://aurora.tridiamond.tech/zh/guide\n建议直接参照官方文档进行设置，官方文档更加详细。\n8.1  配置txtnpm install hexo-theme-aurora --save #进入hexo初始化目录用git执行\n安装好之后，我们需要自己创建一个配置文件。\n我们可以到 node_modules文件夹 下找到 hexo-theme-aurora文件夹。\n里面将_config.yml 复制一份 F2 重命名为_config.aurora.yml\n\n然后将 _config.aurora.yml 移动到你的博客根目录下\n\n8.2 修改配置打开_comfig.yml\n由默认主题改为Aurora\n\n由于Aurora是vue3项目\n打开根目录下的_config.yml\n修改路由方式\n\n运行\ntxthexo clean &amp; hexo g &amp; hexo server我的习惯是分开来：\ntxthexo cl\nhexo g\nhexo s\n8.3 上传并覆盖gitee仓库txthexo d可以使用\ntxthexo s进行本地预览\n打开你的Gitee网页地址，比如本博客主题配置成功\n9.博客参考[搭建博客-图文教程-Luiyang](https://luiyang08.github.io/post/Build Blog)\nhexo+aurora+github搭建-叁鄉浪子\nhexo官方文档\nAurora官方文档\n写在后面搭建完成后的文章编写也会有许多的问题，后续有空再写一下关于文章编写的问题吧，以及一些aurora主题的各种自定义样式修改例如网站图标，个人头像，文章头图等，各类组件的开关安装，编写博客实在需要很多时间，可以网上搜索参考官方文档和他人的教程，这些问题都能得到解决，最重要的是有坚持不懈的心。\n","slug":"hexo博客创建流程","date":"2024-01-25T09:42:12.000Z","categories_index":"Blog","tags_index":"学习,博客搭建","author_index":"Fioransh"},{"id":"40b4e77513d2dcdb879ae29656ac6237","title":"SCAU2023CSAPP期末知识点总结","content":"CSAPP知识点\n进制数转换：十进制转二进制、二进制转十进制、十进制转十六进制、十六进制转十进制、二进制转十六进制、十六进制转二进制。\n\n布尔运算：&amp;与（0&amp;0&#x3D;0 0&amp;1&#x3D;0 1&amp;1&#x3D;1） |或（0|0&#x3D;0 0|1&#x3D;1 1|1&#x3D;1）~非（取反）^异或（0^0&#x3D;0 0^1&#x3D;1 1^1&#x3D;0）\n\n位及运算：获取最低有效字节的值（&amp;0xFF）\n\n逻辑运算（&amp;&amp; || ！）：非0参数都位true（0x01）、参数0表示false(0x00)\n\n移位运算：左移（丢弃左位在最右端补0）逻辑右移（丢弃右位在最左端补0）算数右移（最高位等于0时候与逻辑右移一样、最高位等于1时则是在最高位补1）有符号数为算数右移、无符号数为逻辑右移。\n\n映射(B2U)有符号数无符号数的编码方式：\n\n补码编码映射(B2T)：\n\n有符号数和无符号数的转换：位模式不变、解释位的方式变化。\n\n强制类型转换、影响关系运算的结果：程序运行有符号数会强转成无符号数运算。较大数据类型转较小会损失。\n\n无符号数的转换更大数据类型-扩展：无符号数末尾带有U\n\n有符号数的转换更大数据类型-扩展：\n\n截断的基本规则：\n\n无符号数加法：\n\n有符号数加法：\n\n补码的加法：\n\n使用移位、加法运算的组合代表乘以常数因子：除法无法除尽时候会向0方向舍入、除法为右移\n\n浮点数的权重：\n\n浮点数格式（符号、阶码、尾数）：符号位s（为0时为正数、为1时为负数）阶码exp、尾数M与frac相关\n\n浮点数规格化的值、非规格化的值、特殊值：阶码exp决定了这个数是哪一类\n\n规格化的值和非规格化的值：阶码域全为0的时候E&#x3D;1-bias。M&#x3D;f。\n\n单精度浮点数的二进制表示：\n\n向上舍入、向下舍入、向0舍入、向偶数舍入：\n\nint转化为float不会溢出可能会被舍入、int&#x2F;float转化为double可以保留、double转化为float类型可能会发生溢出转换后可能被舍入、float&#x2F;double转化为int可能向0舍入也可能溢出。\n\n操作数的寄存器：\n\n操作码和操作数以及内存引用：立即数用$表示、内存引用需要加上括号\n\n操作数：\n\n汇编后缀表示：\n\n数据传送指令mov：后缀不同操作的数大小不同，当movq指令的源操作数为立即数时、该立即数只能是32位的补码表示、然后对该数值进行符号位扩展后、讲得到的64位数传送。\n\n压入和弹出栈：\n\n算数和逻辑指令leaq：\n\n通过leaq指令实现算术运算：\n\n一元操作：\n\n二元操作：\n\n移位运算：\n\n其他运算：\n\n常用条件码：CF-进位标志，当CPU最近执行的一条指令最高位产生了进位时，CF会被置1，可以用来检查无符号数的溢出。ZF-零标志，当最近操作的结果为0时，零标志会被置1。SF-符号标志，当最近的操作结果小于0的时候，符号标志会被置1。OF-溢出标志，最近的操作导致正溢出或负溢出时候会被置1。\n\ncmp指令和test指令：\n\n条件控制分支if-else以及条件传送：\n\n循环指令：循环语句是通过条件测试与跳转的结合来实现的。\n\nswitch语句：\n\n理解过程，理解“过程 P 调用过程 Q，Q 执行后返回到 P”包含的三个机制（传递控制、\n传递数据、分配和释放内存）：\n栈帧：当函数执行所需要的存储空间超出寄存器能够存放的大小时，会借助栈上的存储空间，这部分存储空间就叫做栈帧。\n对于函数P调用函数Q的例子，包括较早的帧、调用函数P的帧、还要正在执行函数Q的帧。\n当函数P调用函数Q时，会把返回地址压入栈中，该地址殖知名了函数Q执行结束返回时要从函数P的哪个位置继续进行。这个返回地址的压栈操作并不是由指令push来执行的，而是由函数调用指令call实现的。\n\n数组的分配与访问： short数组2个字节、int数组4个字节、double数组8个字节、指针数组8个字节\n二维数组（嵌套数组）：Xd表示数组的起始地址、L表示数组T的大小、Cij都是常数。\n\n理解内存越界的引用和缓冲区溢出：缓冲区溢出会导致返回时会随机返回到系统的任意位置。对抗缓冲区溢出攻击的方法：栈随机化（ASLR 栈的位置在每次运行时地址都变化）、栈破坏检测（在缓冲区与栈保存的状态值之间存储一个特殊值，这个值被称为金丝雀值、检测金丝雀值是否变化判断是否遭受攻击）、限制可执行代码区域。\n\n消除循环的低效率：CPE表示每个元素执行所需要的周期数（度量效率）。比较操作和分支操作不直接影响程序的数据流，将两个操作以及寄存器rax删除，只保留循环寄存器以及关键操作。将这个视作一个模板重复n次。\n\n减少过程调用（循环展开）：多路并行，10路时接近吞吐界限。\n\n消除不必要的内存引用（加载操作延迟）：加载操作会受存储引用和计算影响。\n\n动态RAM（DRAM）： 电容充电维持信息存储、每个bit位的存储对应一个电容和晶体管，对干扰十分敏感，内存采用DRAM，不断刷新才能保持数据，使用超单元一词来表示DRAM的存储单元，可以通过类似坐标的方式寻址，寻址所需位数关系2的n次方等于行数&#x2F;列数，n即为寻址位数。\n\n磁盘容量和磁盘访问时间的计算：\n\n局部性（时间局部性、空间局部性）：时间局部性（被引用的内存位置在不远的将来还可能被多次引用）、空间局部性（一个内存被引用了一次，程序很可能在不远的将来引用附近的一个内存位置）如两层嵌套的循环遍历二重数组的例子。\n\n高速缓存的参数：基于SRAM，有效位（valid 长1bit 表示当前cache line存储的信息是否有效 1表示有效0表示无效）、标记（tag 确定目标数据是否存在于当前的cache line中） 、数据块（cache block一小部分内存数据的副本，大小用B表示）\n\n高速缓存的三种地址的映射方式：根据每个set所包含的cache line的行数不同，cache被分为不同的类。\n直接缓存（E&#x3D;1 组选择 行匹配 字抽取 根据偏移量来确定目标数据的确切位置，从什么位置开始抽取数据 命中：不命中：cache需要从存储器层次结构的下一层取出被请求的块)\n例子：S表示有几个set、E表示每个set有几行、B表示每个数据块包含几个字节、其中地址m是多少位\n组相联（E&#x3D;2）：字抽取不命中（随机替换、最不常使用、最近最少使用）\n全相联（E&#x3D;C&#x2F;B）：\n\n编写高速缓存友好代码：\n\n理解符号类型和符号解析：全局符号（由该模块定义、同时能被其他模块引用的全局符号）、外部符号（被其他模块定义、同时被该模块引用的全局符号）、局部符号（只能被该模块定义和引用的局部符号 static）\nCOMMON是未初始化的全局变量，注意和.bss区分\n\n强符号和弱符号：强符号（函数和已初始化的全局变量  连接器不允许有多个同名的强符号一起出现）、弱符号（未初始化的全局变量）。\n\n重定位：重定位条目（告诉链接器在合成可执行文件时候应该如何修改这个引用）链接器合并输入模块，并为每个符号分配运行时地址\n重定位相对引用\n绝对地址引用\n\n异常控制流的分类：中断（异步）、陷阱、故障和终止\n\n并发流：一个逻辑流的执行在时间上和另一个流重叠的情况成为并发流，两个流的执行被成为并发运行。（并行是两个进程在不同的处理器核上同时运行）并发是交替运行的，并行是同时运行的。\n\n进程的状态\n\n进程的创建：创建进程时使用的系统函数-fork。父进程调用fork函数创建一个子进程。fork函数一次调用返回两次。父进程和子进程二者并发执行，它们的输出结果都打印出来。\n\n函数execve：调用加载器，在执行可执行程序的main函数之前。\n\nzombie僵死进程：终止运行但是还未回收的进程称为僵死进程，仍在消耗内存。\n\n子进程的回收：父进程通过函数waitpid来等待它的子进程终止或者停止。当第一个参数pid等于0表示等待的进程是一个单独的子进程，pid&#x3D;-1表示等待的进程是由父进程创建的所有子进程组成的集合。statusp是非空，函数waitpid在status上放上导致返回的子进程的状态信息，status就是statusp的值。正常回收返回true，否则未false。\n\n信号所引发事件：\n\n进程组的概念：每个进程都只属于一个进程组，每个进程组都有自己的ID值来唯一标识，通过函数getpgrp来获取当前进程所属的进程组ID值。setpgrp可以进行更改ID\n\n发送信号的方式：\n发送信号的&#x2F;kill方式：通过&#x2F;bin目录中的kill程序可以向其他的进程发送任意的信号。\n从键盘发送信号：当我们在键盘上输入Ctrl+C键会导致内容发送一个中断信号到前台进程组中的所有进程中。\n调用函数kill：调用函数发送信号给其他进程，也包括给自己发送信号。\n使用函数alarm函数：\n\n接收信号：一个待处理信号最多只能接收一次，一种类型的信号最多只能有一次待处理信号。如果一个类型为k的信号有待处理信号，那接下来这个进程中类型为k的信号都不用排队等待，会被简单地丢弃。\n\n虚拟内存：自动完成内存管理的相关工作，可以创建和释放内存空间，将内存空间映射到磁盘文件的某个部分，共享内存。虚拟内存使用不当会使程序产生错误。\n\n物理寻址：\n\n虚拟寻址：将一个虚拟地址转换成物理地址的任务叫做地址翻译\n\n地址空间：地址空间是一个非负整数的有序集合，如果地址空间中的整数是连续的，那么我们说它是一个线性地址空间，一个地址空间的大小是由标识最大地址所需要的位数来描述的。最大可能的虚拟地址是虚拟地址数-1。\n\n虚拟页（存在于磁盘上）和物理页：\n\n页表：是一个页表条目PTE的数组存在于物理内存之中，将虚拟页地址映射到物理页地址。页表条目PTE&#x3D;2的n-p次方，n为虚拟地址大小、页大小P&#x3D;2的p次方。\n\n页命中：虚拟内存中的一个字存在于物理内存中（即DRAM缓存命中）\n\n缺页：引用虚拟内存中的字，不在物理内存中 (DRAM 缓存不命中)\n\n分配页面：分配一个新的虚拟内存页 (VP 5).内核在磁盘上分配VP5， 并且将PTE5指向这个新的位置\n\n使用SRAM缓存来表示CPU与内存之间的L1L2L3这三级高速缓存。DRAM表示虚拟内存系统的缓存。\n\n地址翻译：\n\nP&#x3D;1K&#x3D;2的10次方可以得到p&#x3D;10。虚拟页偏移量VPO&#x3D;物理页偏移量PPO&#x3D;p。虚拟页号VPN&#x3D;虚拟地址空间-虚拟页偏移量VPO。物理页号PPN&#x3D;物理地址-物理页偏移量PPO。\n\n\n","slug":"CSAPP知识点","date":"2024-01-02T05:28:12.000Z","categories_index":"Blog","tags_index":"CSAPP,学习","author_index":"Fioransh"},{"id":"c64df93cb58edc8361b9b55ace6a467f","title":"前端部分知识点","content":"HTML部分1. html结构1.html：根标签\n2.head： 头部标签\n3.body： 主体标签\n4.title：标题标签\n5.DOCTYPE： 声明文档类型\n6.lang &#x3D; “en”：页面的语言类型\n7.charset&#x3D;“UTF-8”编码格式\n2. html标签\n标题标h： &lt;h1&gt; ~ &lt;h6&gt; 不同字号大小\n段落标签p\n水平线标签  &lt;hr&#x2F;&gt; 单标签\n换行标签  &lt;br&#x2F;&gt;\nspan 文字标签：一行上可以放多个 \\ 小盒子\ndiv标签： 一行上只能放一个&lt;div&gt;大盒子 \n加粗标签：&lt;strong&gt; 和  &lt;b&gt; 前者语义更强烈\n倾斜标签：&lt;em&gt; 和 &lt;i&gt; 前者语义更强烈\n删除线：&lt;del&gt; 和  &lt;s&gt;  前者语义更强烈\n下划线：&lt;ins&gt; 和 &lt;u&gt; 前者语义更强烈\n\n3.图片标签&lt;img&gt;\nsrc：当前图片的路径\nalt：当图片错误加载时候显示的文字\ntitle：当鼠标悬停在图片上显示的文字\nheight： 图片的高度\nwidth： 图片的宽度\nborder：图片的边框\n\n4.连接标签&lt;a&gt;\n外部链接  &lt;a href&#x3D;”\\\">http://www.baidu.com&quot;&gt;\\  写完整的 协议  域名   网址\n内部链接 &lt;a href&#x3D;”index.html”&gt;&lt;&#x2F;a&gt;   直接写文件名即可\nhref:指定跳转的页面\ntitle：鼠标悬停显示的文字\ntarget:  _self(默认会覆盖原来的窗口)   _blank(会以新的窗口打开)    窗口的打开方式\n#：会阻止页面跳转但是会刷新页面\n绝对路径：目录下的绝对位置，通常从盘符开始\n相对路径：在同一个文件夹直接找名字、向上一级  ..&#x2F; 、向下 &#x2F;\n\n5.表格\n表格：&lt;table&gt;是用于定义表格的标签。\n行：&lt;tr&gt;标签用于定义表格中的行，必须嵌套在 &lt;table&gt; 标签中。\n单元格：&lt;td&gt; 用于定义表格中的单元格，必须嵌套在&lt;tr&gt;标签中。\n表头&lt;th&gt; 加粗加黑自动居中。\n表格的标题：&lt;caption&gt;表格的标题   写在内部  显示外部  居中\n结构头：&lt;thead&gt; 结构头\n结构底：&lt;tfoot&gt;结构底\n结构体：&lt;tbody&gt;结构体\n表格边框border\n宽度 width\n高度 height\n单元格与单元格之间距离 cellspacing\n单元格与内容之间的距离 cellspadding\n居中 align ： left&#x2F; center&#x2F; right \n列合并 colspan\n行合并 rowspan\n\n6.列表\n无序列表 : &lt;ul&gt; &lt;li&gt;\n有序列表 : &lt;ol&gt;&lt;li&gt;\n自定义列表：&lt;dl&gt; &lt;dt&gt; &lt;dd&gt;\n\n7. 表单1. input属性 &lt;input type &#x3D; “属性值”&gt;\ntext：文本框\npassword：密码框\nradio：单选按钮\ncheckbox：复选框\nbutton：普通按钮\nreset：重置按钮  需要配合form表单才有作用\nsubmit：提交按钮\nimage   属性  src\nfile 文件按钮   上传图片\n\n2.其他属性\nname属性：定义input元素的名称\nvalue：规定input氧元素的值\nchecked：规定input元素首次加载时应当被选中\nmaxlength： 输入字段字符的最大长度\nlabel\ntextarea：用户留言 cols&#x3D;“每行中的字符数” ，rows&#x3D;“显示的行数”\nselect：下拉菜单\nform表单：收集用户信息，action：  提交后台的地址 method&#x3D;”get&#x2F;post”   提交（传输）后台的方式 name &#x3D;“a” 告诉服务器  由哪个表单提交过来的\n\nCSS部分1.css引入方式\n行内样式：&lt;标签 style&#x3D;”属性:属性值;”&gt;&lt;&#x2F;标签&gt;\n内部样式：选择器{属性:属性值;属性：属性值}\n外部样式：通过link引入外部css文件  &lt;link  rel&#x3D;”stylesheet”   href&#x3D;”外部css文件”  &#x2F;&gt;\nhref与src   href 是引用   src下载资源到当前页面\n\n2.选择器\n标签选择器：标签{属性：属性值}\nclass（类选择器）：html：&lt;div class&#x3D;”名字”&gt;  css：  .名字{属性：属性值}  .nav{color: red}\nid选择器：html：&lt;div id&#x3D;”名字”&gt;&lt;&#x2F;div&gt;   css：  #名字{属性：属性值} id与class选择器的区别：  id的名字是唯一的（体现在js里面） class名字可以任意多个  #nav{color： red}\n通配符选择器：选择所有的标签 *{color：red}\n\n3.字体属性\n字体大小：font-size \n字体类型：font-family\n字体粗度：font-weight   normal默认值400（不加粗）bold粗体700（加粗的）\n文本风格：font-style:字体倾斜：italic（倾斜）&#x2F;normal（正常）\n文字阴影： text-shadow  水平距离   垂直距离  模糊程度   阴影颜色   \n字体连写：  font:font-style font-weight font-size&#x2F;line-height font-family\n字体颜色：color\n水平对齐方式：text-align:left&#x2F;center&#x2F;right（注意：1.div  h。。标题会居中   span   em  i。。。。不会居中）\n行高：line-height\n首行缩进：text-indent:  em   1em&#x3D;16px\n去掉a链接默认的下划线 ：text-decoration： none(去掉下划线)&#x2F; undefined(添加下划线)\n\n4.快速生成HTML结构语法\n生成标签 直接输入标签名 按tab键即可   比如  div   然后tab 键， 就可以生成 &lt;div&gt;&lt;&#x2F;div&gt;\n如果想要生成多个相同标签  加上 * 就可以了 比如   div*3  就可以快速生成3个div\n如果有父子级关系的标签，可以用 &gt;  比如   ul &gt; li就可以了\n如果有兄弟关系的标签，用  +  就可以了 比如 div+p  \n如果生成带有类名或者id名字的，  直接写  .demo  或者  #two   tab 键就可以了\n如果生成的div 类名是有顺序的， 可以用 自增符号  $ \n如果想要在生成的标签内部写内容可以用  { }  表示\n\n5.快速生成CSS样式语法CSS 基本采取简写形式即可\n​\t\t比如 w200   按tab  可以 生成  width: 200px;\n​\t\t比如 lh26px   按tab  可以生成  line-height: 26px;‘\n6.复合选择器\n后代选择器：元素1 元素2 {样式}   ul li{color：red} 选择ul里面所有的li标签元素\n子选择器：元素1&gt;元素2 {样式}  div &gt; p {样式声明} 选择div里面所有最近一级的p标签元素\n并集选择器：元素1，元素2 {样式声明}  ul，div{样式}  选择ul和div标签元素\n伪类选择器：     （ :hover）\n链接伪类选择器：给某些选择器增加特殊的效果：\ta:hover\t鼠标经过的那个链接\n:focus 伪类选择器：用于选取获得焦点的表单元素\n\n7.CSS的显示模式\n块元素：&lt;h1&gt;~&lt;h6&gt;、&lt;p&gt;、&lt;div&gt;、&lt;ul&gt;、&lt;ol&gt;、&lt;li&gt;  比较霸道，自己独占一行。高度，宽度、外边距以及内边距都可以控制。宽度默认是容器（父级宽度）的100%。是一个容器及盒子，里面可以放行内或者块级元素。\n行内元素：&lt;a&gt;、&lt;strong&gt;、&lt;b&gt;、&lt;em&gt;、&lt;i&gt;、&lt;del&gt;、&lt;s&gt;、&lt;ins&gt;、&lt;u&gt;、&lt;span&gt; 相邻行内元素在一行上，一行可以显示多个。默认宽度就是它本身内容的宽度。\n行内块元素：&lt;img &#x2F;&gt;、&lt;input &#x2F;&gt;、&lt;td&gt;  同时具有块元素和行内元素的特点。\n元素显示模块转换：转换为块元素：display:block;  转换为行内元素：display:inline;  转换为行内块：display: inline-block;\n让文字的行高等于盒子的高度  就可以让文字在当前盒子内垂直居中\n\n8.CSS的背景\n背景颜色：background-color：颜色值；元素背景颜色默认值是 transparent（透明）\n背景图片：background-image：none | url ；\n背景平铺：background-repeat： repeat在纵向和横向上平铺 | no-repeat不平铺 | repeat-x横向 | repeat-y纵向\n背景图片位置：background-position 属性可以改变图片在背景中的位置\n背景图片固定：\tbackground-attachment    scroll随对象内容滚动  fixed 背景图像固定\n背景样式合写：\tbackground: 背景颜色 背景图片地址 背景平铺 背景图像滚动 背景图片位置;\n背景色半透明：background： rgba（0，0，0，0.3） 最后一个参数是 alpha 透明度，取值范围在 0~1之间\n\n9.优先级\n继承或者* 0，0，0，0\n元素选择器 0，0，0，1\n类选择器，伪类选择器 0，0，1，0\nID选择器  0，1，0，0\n行内样式 style&#x3D;“” 1，0，0，0\n！important 重要的 无穷大\n\n10.盒子模型——边框border\nCSS 盒子模型本质上是一个盒子，封装周围的 HTML 元素，它包括：边框、外边距、内边距、和 实际内容\n定义边框粗细：border-width： 单位是px\n边框的样式：border-style  none：没有边框即忽略所有边框的宽度（默认值）solid：边框为单实线(最为常用的) dashed：边框为虚线   dotted：边框为点线\n表格的细线边框：border-collapse \nborder-collapse: collapse; 表示相邻边框合并在一起\n内边距 padding\n外边距 margin\n圆角边框：border-radius 用于设置元素的外边框圆角。\n盒子阴影： box-shadow: h-shadow水平阴影 v-shadow垂直阴影 blur模糊距离 spread阴影的尺寸 color阴影颜色 inset外部阴影改为内部阴影;\n文字阴影：  text-shadow: h-shadow水平阴影 v-shadow垂直阴影 blur模糊距离 color阴影颜色;\n\n11.浮动\n浮动：float：none不浮动   left向左浮动   right向右浮动\n清除浮动： 选择器{clear:属性值;}   left 不允许左侧有浮动   right 不允许右侧有浮动  both 同时清除左右两侧浮动\n额外标签法清除浮动：例如 &lt;div style&#x3D;”clear:both”&gt;&lt;&#x2F;div&gt;，或者其他标签（如&lt;br &#x2F;&gt;等）。\n父级添加 overflow 属性 （溢出）hidden | auto | scroll\n父级添加after伪元素\n\n12.定位（position）\n边偏移 有 top、bottom、left 和 right  4 个属性。\n\nposition 属性定义元素的定位模式  选择器 { position: 属性值; } static  静态定位 relative  相对定位            absolute  绝对定位fixed  固定定位\n\n静态定位(static) ：无定位\n\n相对定位(relative) ：移动位置的时候相对于自己原来的位置来说的，在原来位置继续占有\n\n绝对定位(absolute)：绝对定位是元素在移动位置的时候，是相对于它祖先元素来说的，完全不占位置，父元素要有定位\n\n子绝父相\n\n固定定位(fixed)：固定于浏览器可视区的位置，不随滚动条滚动，不占位置\n\n粘性定位(sticky) ：相对定位和固定定位的混合，占位置\n\n\n\n定位模式\n是否脱标\n移动位置\n是否常用\n\n\n\nstatic   静态定位\n否\n不能使用边偏移\n很少\n\n\nrelative 相对定位\n否 (占有位置)\n相对于自身位置移动\n基本单独使用\n\n\nabsolute绝对定位\n是（不占有位置）\n带有定位的父级\n要和定位父级元素搭配使用\n\n\nfixed 固定定位\n是（不占有位置）\n浏览器可视区\n单独使用，不需要父级\n\n\nsticky 粘性定位\n否   (占有位置)\n浏览器可视区\n当前阶段少\n\n\n\n堆叠顺序（z-index）：正整数、负整数或 0，默认值是 0，数值越大，盒子越靠上；\n\n绝对定位的盒子居中：left: 50%;  margin-left: -100px;\n\n脱标的盒子不会触发外边距塌陷\n\n绝对定位（固定定位）会完全压住盒子\n\n\n13.元素显示隐藏\n显示display：display: none 隐藏对象  display：block 除了转换为块级元素之外，同时还有显示元素的意思。隐藏后不再占有原本位置\n\n可见性 visibility：visibility：visible ; 　元素可视   visibility：hidden; 　  元素隐藏\n\noverflow 溢出：\n\n\n\n\n属性值\n描述\n\n\n\nvisible\n不剪切内容也不添加滚动条\n\n\nhidden\n不显示超过对象尺寸的内容，超出的部分隐藏掉\n\n\nscroll\n不管超出内容否，总是显示滚动条\n\n\nauto\n超出自动显示滚动条，不超出不显示滚动条\n\n\n\n\n14.精灵图\n精灵技术主要针对于背景图片使用。就是把多个小背景图片整合到一张大图片中。\n这个大图片也称为 sprites  精灵图  或者 雪碧图\n移动背景图片位置， 此时可以使用 background-position 。\n移动的距离就是这个目标图片的 x 和 y 坐标。注意网页中的坐标有所不同\n因为一般情况下都是往上往左移动，所以数值是负值。\n使用精灵图的时候需要精确测量，每个小背景图片的大小和位置。\n\n15.字体应用txt @font-face &#123;\n   font-family: &#39;icomoon&#39;;\n   src:  url(&#39;fonts/icomoon.eot?7kkyc2&#39;);\n   src:  url(&#39;fonts/icomoon.eot?7kkyc2#iefix&#39;) format(&#39;embedded-opentype&#39;),\n     url(&#39;fonts/icomoon.ttf?7kkyc2&#39;) format(&#39;truetype&#39;),\n     url(&#39;fonts/icomoon.woff?7kkyc2&#39;) format(&#39;woff&#39;),\n     url(&#39;fonts/icomoon.svg?7kkyc2#icomoon&#39;) format(&#39;svg&#39;);\n   font-weight: normal;\n   font-style: normal;\n &#125;\n定义字体： span {   font-family: “icomoon”;}\n16.CSS界面样式\n鼠标样式 cursor：default 小白默认 pointer小手 move 移动 text文本 not-allowed禁止\n轮廓线 outline：none 去掉默认蓝色边框\n防止拖拽文本域 resize：none\n文字对齐 vertical-align ：baseline默认，放在父元素基线，top 行中最高元素顶端对齐 middle 放在父元素中部 bottom最低元素的顶端对齐\n单行文本溢出显示省略号：先强制一行内显示文本  white-space: nowrap; 超出的部分隐藏  overflow: hidden;  文字用省略号替代超出的部分  text-overflow: ellipsis;\n\nHTML51.语义化标签\n&lt;header&gt; 头部标签\n&lt;nav&gt; 导航标签\n&lt;article&gt; 内容标签\n&lt;section&gt; 定义文档某个区域\n&lt;aside&gt; 侧边栏标签\n&lt;footer&gt; 尾部标签\n\n2.多媒体标签\n音频 audio 和视频 video 两个标签\nautoplay 视频就绪自动播放\nwidth height\nloop 视频播放完毕是否循环播放\npreload auto预先加载 none不预先\nurl地址\nposter 加载等待的画面图片\nmuted 静音播放\ncontrols 显示控件\n\n3.新增表单元素\nemail  \nurl\ndate\ntime\nmonth\nweek\nnumber\ntel\nsearch\ncolor\n\nCSS31.新增选择器\n\n\n\n\n2.盒子模型\nbox-sizing: content-box  盒子大小为 width + padding + border  （以前默认的）\nbox-sizing: border-box  盒子大小为 width\n如果盒子模型我们改为了box-sizing: border-box  ， 那padding和border就不会撑大盒子了（前提padding和border不会超过width宽度）\n\n3.其他特性\n模糊滤镜filter ：filter:   函数(); –&gt;  例如： filter: blur(5px);  –&gt;  blur模糊处理  数值越大越模糊\n计算盒子宽度 – calc 函数：width: calc(100% - 80px);\n\n4.CSS3过渡\n过渡动画： 是从一个状态 渐渐的过渡到另外一个状态\ntransition: 要过渡的属性  花费时间  运动曲线  何时开始;\n\n5.2D转换\n转换 移动：translate  旋转：rotate  缩放：scale\n旋转 translate：transform：translate（x,y）\n缩放 retate：transform：retate（度数）\n2D转换中心点：transform-origin： x， y；\n缩放 transform：scale（x,y）\n\n6.动画\nkeyframes定义动画  @keyframes动画名称\n\n","slug":"前端部分知识总结","date":"2023-11-23T05:28:12.000Z","categories_index":"Blog","tags_index":"学习,前端","author_index":"Fioransh"},{"id":"1a206922638b47b5382f6efd345cd840","title":"校园课表微信小程序接口文档示例","content":"基于uni-app框架开发的微信小程序接口文档一. 关系型数据库设计1.数据列表1.student 表\n\n\nstudent_id\nreal_student_id\nname\ncollege\nmajor\nclassNum\ngrade\n\n\n\n1\n202225220801\n张三\n数信\n软件工程\n5班\n2022\n\n\n2\n202325310802\n李四\n材能\n材料\n1班\n2023\n\n\n…\n…\n…\n…\n…\n…\n…\n\n\n2. courses表\n\n\ncourse_id\nname\nteacher\ntime\nlocation\nday_of_week\n\n\n\n101\n数据库原理\n王老师\n周一1-2节\n4210\n1\n\n\n102\n数据结构\n张老师\n周三1-2节\n3302\n3\n\n\n103\n面向对象程序设计\n宋老师\n周四3-4节\n4502\n4\n\n\n…\n…\n…\n…\n…\n\n\n\n3.enrollments表\n\n\nenrollment_id\nstudent_id\ncourse_id\n\n\n\n1\n1\n101\n\n\n2\n1\n102\n\n\n3\n2\n101\n\n\n4\n2\n103\n\n\n…\n…\n…\n\n\n4.tasks表\n\n\ntask_id\nreal_student_id\ndescription\nstatus\ncreate_time\nupdate_time\n\n\n\n1\n202225220501\n完成作业\n未完成(0)\n…\n…\n\n\n2\n202325310502\n准备考试\n完成(1)\n…\n…\n\n\n3\n202225310702\n提交报告\n未完成(0)\n…\n…\n\n\n…\n…\n…\n…\n\n\n\n\n生成语句txt-- 学生表格\ncreate table students (\n    student_id int unsigned primary key auto_increment comment &#39;主键学生id&#39;,\n    real_student_id varchar(20) not null comment &#39;学号&#39;,\n    name varchar(10) not null comment &#39;名字&#39;,\n    college varchar(20) not null comment &#39;学院&#39;,\n    major varchar(20) not null comment &#39;专业&#39;,\n    class int not null comment &#39;班级&#39;,\n    grade int not null comment &#39;年级&#39;\n)comment &#39;学生表格&#39;;\nCREATE INDEX idx_real_student_id ON students(real_student_id);\n-- 学生表测试数据\ninsert into students(student_id, real_student_id, name, college, major, class, grade) values(1, &#39;202225220503&#39;, &#39;冯焯炫&#39;, &#39;软件学院&#39;, &#39;软件工程&#39;, 5, 2022),\n                                                                                            (2, &#39;202225220504&#39;, &#39;郭文杰&#39;, &#39;软件学院&#39;, &#39;软件工程&#39;, 5, 2022),\n                                                                                            (3, &#39;202225220901&#39;, &#39;张三&#39;, &#39;软件学院&#39;, &#39;软件工程&#39;, 9, 2022),\n                                                                                            (4, &#39;202325220904&#39;, &#39;李四&#39;, &#39;软件学院&#39;, &#39;软件工程&#39;, 9, 2023),\n                                                                                            (5, &#39;202225310902&#39;, &#39;王五&#39;, &#39;数学与信息学院&#39;, &#39;计算机科学与技术&#39;, 9, 2022);\n\n\n-- 课程表格\ncreate table courses(\n    course_id int unsigned primary key auto_increment comment &#39;主键课程id&#39;,\n    name varchar(20) not null comment &#39;课程名字&#39;,\n    teacher varchar(10) not null comment &#39;教师名字&#39;,\n    time varchar(20) not null comment &#39;上课时间&#39;,\n    location varchar(20) not null comment &#39;上课地点&#39;,\n    day_of_week int not null comment &#39;星期几上课&#39;\n)comment &#39;课程表格&#39;;\n-- 课程表测试数据\ninsert into courses(course_id, name, teacher, time, location, day_of_week) values(101, &#39;数据结构&#39;, &#39;张老师&#39;, &#39;周一第1-2节&#39;, &#39;4201&#39;, 1),\n                                                                                 (102, &#39;数据库&#39;, &#39;陈老师&#39;, &#39;周三第1-2节&#39;, &#39;4311&#39;, 3),\n                                                                                 (103, &#39;面向对象程序设计&#39;, &#39;王老师&#39;, &#39;周四第3-4节&#39;, &#39;4403&#39;, 4),\n                                                                                 (104, &#39;C语言程序设计&#39;, &#39;周老师&#39;, &#39;周二第7-8节&#39;, &#39;4402&#39;, 2),\n                                                                                 (105, &#39;高等数学&#39;, &#39;王老师&#39;, &#39;周四第3-4节&#39;, &#39;3201&#39;, 4),\n                                                                                 (106, &#39;大学英语&#39;, &#39;冯老师&#39;, &#39;周一第7-8节&#39;, &#39;3311&#39;, 1),\n                                                                                 (107, &#39;数据结构&#39;, &#39;张老师&#39;, &#39;周三第1-2节&#39;, &#39;4301&#39;, 3),\n                                                                                 (108, &#39;计算机组成原理&#39;, &#39;黄老师&#39;, &#39;周五第5-6节&#39;, &#39;1502&#39;, 5),\n                                                                                 (109, &#39;数字电路&#39;, &#39;王老师&#39;, &#39;周二第1-2节&#39;, &#39;3301&#39;, 2),\n                                                                                 (110, &#39;近代史纲要&#39;, &#39;陈老师&#39;, &#39;周五第5-6节&#39;, &#39;5c501&#39;, 5),\n                                                                                 (111, &#39;离散结构&#39;, &#39;李老师&#39;, &#39;周四第1-2节&#39;, &#39;5a601&#39;, 4);\n\n\n\n\n-- 选课表格\ncreate table enrollments(\n    enrollment_id int unsigned primary key auto_increment comment &#39;主键选课id&#39;,\n    student_id int unsigned not null comment &#39;学生id&#39;,\n    course_id int unsigned not null comment &#39;课程id&#39;,\n    FOREIGN KEY (student_id) REFERENCES students(student_id),\n    FOREIGN KEY (course_id) REFERENCES courses(course_id)\n)comment &#39;选课表格&#39;;\n-- 选课表测试数据\ninsert into enrollments(enrollment_id, student_id, course_id) values(1, 1, 101),\n                                                                    (2, 1, 102),\n                                                                    (3, 1, 103),\n                                                                    (4, 1, 106),\n                                                                    (5, 1, 107),\n                                                                    (6, 1, 109),\n                                                                    (7, 2, 101),\n                                                                    (8, 2, 102),\n                                                                    (9, 2, 103),\n                                                                    (10, 2, 106),\n                                                                    (11, 2, 107),\n                                                                    (12, 2, 109),\n                                                                    (13, 3, 103),\n                                                                    (14, 3, 111),\n                                                                    (15, 3, 101),\n                                                                    (16, 3, 107),\n                                                                    (17, 3, 106),\n                                                                    (18, 3, 102),\n                                                                    (19, 4, 104),\n                                                                    (20, 4, 110),\n                                                                    (21, 4, 109),\n                                                                    (22, 4, 108),\n                                                                    (23, 5, 103),\n                                                                    (24, 5, 108),\n                                                                    (25, 5, 109),\n                                                                    (26, 5, 111),\n                                                                    (27, 5, 106);\n\n\n\n\n\n-- 待办表格\ncreate table tasks(\n    task_id int unsigned primary key auto_increment comment &#39;主键任务id&#39;,\n    real_student_id varchar(20) not null comment &#39;学号&#39;,\n    description varchar(100) not null comment &#39;任务描述&#39;,\n    status tinyint(1) not null comment &#39;任务状态&#39;,\n    create_time datetime not null comment &#39;创建时间&#39;,\n    update_time datetime not null comment &#39;更新时间&#39;,\n    FOREIGN KEY (real_student_id) REFERENCES students(real_student_id)\n)comment &#39;待办表格&#39;;\n-- 待办表测试数据\ninsert into tasks(task_id, real_student_id, description, status, create_time, update_time) values (1, &#39;202225220503&#39;, &#39;完成Java实验任务&#39;, 0, now(), now()),\n                                                                                                  (2, &#39;202225220503&#39;, &#39;完成C语言实验任务&#39;, 1, now(), now()),\n                                                                                                  (3, &#39;202225220504&#39;, &#39;完成数据结构课程设计&#39;, 0, now(), now()),\n                                                                                                  (4, &#39;202225220504&#39;, &#39;完成Java实验任务&#39;, 1, now(), now()),\n                                                                                                  (5, &#39;202225220901&#39;, &#39;完成高等数学周末作业&#39;, 0, now(), now()),\n                                                                                                  (6, &#39;202325220904&#39;, &#39;完成大学英语周末作业&#39;, 0, now(), now()),\n                                                                                                  (7, &#39;202225310902&#39;, &#39;完成数据库实验任务&#39;, 1, now(), now()),\n                                                                                                  (8, &#39;202225310902&#39;, &#39;完成Java实验任务&#39;, 0, now(), now());二.接口文档1.课程管理1.1 课程列表查询1.1.1 基本信息​\t\t| 请求路径：&#x2F;courses&#x2F;{realStudentId}\n​        | 请求方式：GET\n​        | 接口描述：该接口用于根据学号进行学生课表数据查询\n1.1.2 请求参数参数格式：路径参数\n参数说明：\n\n\n\n参数名\n类型\n是否必须\n备注\n\n\n\nrealStudentId\nstring\n必须\n学号\n\n\n请求参数样例：\ntxt/courses/2022252205031.1.3响应数据参数格式： application&#x2F;json\n参数说明：\n\n\n\n参数名\n类型\n是否必须\n备注\n\n\n\ncode\nnumber\n必须\n响应码，1代表成功，0代表失败\n\n\nmsg\nstring\n非必须\n提示信息\n\n\ndata\nobject\n非必须\n返回的数据\n\n\n|- courseId\nnumber\n非必须\n课程id\n\n\n|- name\nstring\n非必须\n课程名称\n\n\n|- teacher\nstring\n非必须\n老师名称\n\n\n|- time\nstring\n非必须\n上课时间\n\n\n|- location\nstring\n非必须\n上课地点\n\n\n|- dayOfWeek\nnumber\n非必须\n上课时间是星期几\n\n\n响应数据样例：\ntxt&#123;\n    &quot;code&quot;: 1,\n    &quot;msg&quot;: &quot;success&quot;,\n    &quot;data&quot;: [\n        &#123;\n            &quot;courseId&quot;: 101,\n            &quot;name&quot;: &quot;数据结构&quot;,\n            &quot;teacher&quot;: &quot;张老师&quot;,\n            &quot;time&quot;: &quot;周一第1-2节&quot;,\n            &quot;location&quot;: &quot;4201&quot;,\n            &quot;dayOfWeek&quot;: 1\n        &#125;,\n        &#123;\n            &quot;courseId&quot;: 102,\n            &quot;name&quot;: &quot;数据库&quot;,\n            &quot;teacher&quot;: &quot;陈老师&quot;,\n            &quot;time&quot;: &quot;周三第1-2节&quot;,\n            &quot;location&quot;: &quot;4311&quot;,\n            &quot;dayOfWeek&quot;: 3\n        &#125;,\n        &#123;\n            &quot;courseId&quot;: 103,\n            &quot;name&quot;: &quot;面向对象程序设计&quot;,\n            &quot;teacher&quot;: &quot;王老师&quot;,\n            &quot;time&quot;: &quot;周四第3-4节&quot;,\n            &quot;location&quot;: &quot;4403&quot;,\n            &quot;dayOfWeek&quot;: 4\n        &#125;,\n        &#123;\n            &quot;courseId&quot;: 106,\n            &quot;name&quot;: &quot;大学英语&quot;,\n            &quot;teacher&quot;: &quot;冯老师&quot;,\n            &quot;time&quot;: &quot;周一第7-8节&quot;,\n            &quot;location&quot;: &quot;3311&quot;,\n            &quot;dayOfWeek&quot;: 1\n        &#125;,\n        &#123;\n            &quot;courseId&quot;: 107,\n            &quot;name&quot;: &quot;数据结构&quot;,\n            &quot;teacher&quot;: &quot;张老师&quot;,\n            &quot;time&quot;: &quot;周三第1-2节&quot;,\n            &quot;location&quot;: &quot;4301&quot;,\n            &quot;dayOfWeek&quot;: 3\n        &#125;,\n        &#123;\n            &quot;courseId&quot;: 109,\n            &quot;name&quot;: &quot;数字电路&quot;,\n            &quot;teacher&quot;: &quot;王老师&quot;,\n            &quot;time&quot;: &quot;周二第1-2节&quot;,\n            &quot;location&quot;: &quot;3301&quot;,\n            &quot;dayOfWeek&quot;: 2\n        &#125;\n    ]\n&#125;2.待办管理1.1查询待办1.1.1基本信息​        | 请求路径：&#x2F;tasks&#x2F;{realStudentId}\n​        | 请求方式：GET\n​        | 接口描述：该接口用于根据学号进行待办事项数据查询\n1.1.2请求参数参数格式：路径参数\n参数说明：\n\n\n\n参数名\n类型\n是否必须\n备注\n\n\n\nrealStudentId\nstring\n必须\n学号\n\n\n请求参数样例：\ntxt/tasks/2022252205031.1.3响应数据参数格式： application&#x2F;json\n参数说明：\n\n\n\n参数名\n类型\n是否必须\n备注\n\n\n\ncode\nnumber\n必须\n响应码，1代表成功，0代表失败\n\n\nmsg\nstring\n非必须\n提示信息\n\n\ndata\nobject\n非必须\n返回的数据\n\n\n|- taskId\nnumber\n非必须\n待办id\n\n\n|- description\nstring\n非必须\n待办内容\n\n\n|- status\nnumber\n非必须\n完成状态，0代表未完成，1代表完成\n\n\n|- createTime\nstring\n非必须\n创建时间\n\n\n|- updateTime\nstring\n非必须\n更新时间\n\n\n响应数据样例：\ntxt&#123;\n    &quot;code&quot;: 1,\n    &quot;msg&quot;: &quot;success&quot;,\n    &quot;data&quot;: [\n        &#123;\n            &quot;taskId&quot;: 1,\n            &quot;description&quot;: &quot;完成Java实验任务&quot;,\n            &quot;status&quot;: 0,\n            &quot;createTime&quot;: &quot;2023-11-05T21:36:43&quot;,\n            &quot;updateTime&quot;: &quot;2023-11-05T21:36:43&quot;\n        &#125;,\n        &#123;\n            &quot;taskId&quot;: 2,\n            &quot;description&quot;: &quot;完成C语言实验任务&quot;,\n            &quot;status&quot;: 1,\n            &quot;createTime&quot;: &quot;2023-11-05T21:36:43&quot;,\n            &quot;updateTime&quot;: &quot;2023-11-05T21:36:43&quot;\n        &#125;\n    ]\n&#125;1.2 删除待办1.2.1 基本信息​\t\t| 请求路径： &#x2F;tasks&#x2F;{taskId}\n​        | 请求方式：DELETE\n​        | 接口描述：该接口用于根据待办事项ID删除待办事项数据\n1.2.2 请求参数参数格式：路径参数\n参数说明：\n\n\n\n参数名\n类型\n是否必须\n备注\n\n\n\ntaskId\nnumber\n必须\n待办事项ID\n\n\n请求参数样例：\ntxt/tasks/91.2.3 响应数据参数格式：application&#x2F;json\n参数说明：\n\n\n\n参数名\n类型\n是否必须\n备注\n\n\n\ncode\nnumber\n必须\n响应码，1代表成功，0代表失败\n\n\nmsg\nstring\n非必须\n提示信息\n\n\ndata\nobject\n非必须\n返回的数据\n\n\n响应数据样例：\ntxt&#123;\n    &quot;code&quot;: 1,\n    &quot;msg&quot;: &quot;success&quot;,\n    &quot;data&quot;: null\n&#125;1.3 添加待办1.3.1 基本信息​\t\t| 请求路径： &#x2F;tasks\n​        | 请求方式：POST\n​        | 接口描述：该接口用于添加待办事项数据\n1.3.2 请求参数参数格式：application&#x2F;json\n参数说明：\n\n\n\n参数名\n类型\n是否必须\n备注\n\n\n\nrealStudentId\nstring\n必须\n学号，必须是student表里有的学号\n\n\ndescription\nstring\n必须\n待办事项\n\n\nstatus\nnumber\n必须\n完成状态，0代表未完成，1代表完成\n\n\n请求参数样例：\ntxt&#123;\n   &quot;realStudentId&quot;: &quot;202225220503&quot;,\n   &quot;description&quot;: &quot;完成Java实验任务&quot;,\n   &quot;status&quot;: 0\n&#125;1.3.3 响应数据参数格式：application&#x2F;json\n参数说明：\n\n\n\n参数名\n类型\n是否必须\n备注\n\n\n\ncode\nnumber\n必须\n响应码，1代表成功，0代表失败\n\n\nmsg\nstring\n非必须\n提示信息\n\n\ndata\nobject\n非必须\n返回的数据\n\n\n响应数据样例：\ntxt&#123;\n    &quot;code&quot;: 1,\n    &quot;msg&quot;: &quot;success&quot;,\n    &quot;data&quot;: null\n&#125;1.4 修改待办1.4.1 基本信息​\t\t| 请求路径： &#x2F;tasks&#x2F;{taskId}\n​        | 请求方式：PUT\n​        | 接口描述：该接口用于修改待办事项数据\n1.4.2 请求参数参数格式：application&#x2F;json\n参数说明：\n\n\n\n参数名\n类型\n是否必须\n备注\n\n\n\nrealStudentId\nstring\n必须\n学号，必须是student表里有的学号\n\n\ndescription\nstring\n必须\n待办事项\n\n\nstatus\nnumber\n必须\n完成状态，0代表未完成，1代表完成\n\n\n请求参数样例：\ntxt&#123;\n   &quot;realStudentId&quot;: &quot;202225220503&quot;,\n   &quot;description&quot;: &quot;完成Java实验任务&quot;,\n   &quot;status&quot;: 0\n&#125;,1.4.3 响应数据参数格式：application&#x2F;json\n参数说明：\n\n\n\n参数名\n类型\n是否必须\n备注\n\n\n\ncode\nnumber\n必须\n响应码，1代表成功，0代表失败\n\n\nmsg\nstring\n非必须\n提示信息\n\n\ndata\nobject\n非必须\n返回的数据\n\n\n响应数据样例：\ntxt&#123;\n    &quot;code&quot;: 1,\n    &quot;msg&quot;: &quot;success&quot;,\n    &quot;data&quot;: null\n&#125;3.学生管理3.1 添加学生3.1.1 基本信息​\t\t| 请求路径： &#x2F;students\n​        | 请求方式：POST\n​        | 接口描述：该接口用于添加待办事项数据\n3.1.2 请求参数参数格式：application&#x2F;json\n参数说明：\n\n\n\n参数名\n类型\n是否必须\n备注\n\n\n\nrealStudentId\nstring\n必须\n学号\n\n\nname\nstring\n必须\n学生姓名\n\n\ncollege\nstring\n必须\n学院\n\n\nmajor\nstring\n必须\n专业\n\n\nclassNum\nnumber\n必须\n班级\n\n\ngrade\nnumber\n必须\n年级\n\n\n请求参数样例：\ntxt&#123;\n   &quot;realStudentId&quot;: &quot;202225220505&quot;,\n   &quot;name&quot;: &quot;何泳泳&quot;,\n   &quot;college&quot;: &quot;软件学院&quot;,\n   &quot;major&quot;: &quot;软件工程&quot;,\n   &quot;classNum&quot;: 5,\n   &quot;grade&quot;: 2022\n&#125;3.1.3响应数据参数格式：application&#x2F;json\n参数说明：\n\n\n\n参数名\n类型\n是否必须\n备注\n\n\n\ncode\nnumber\n必须\n响应码，1代表成功，0代表失败\n\n\nmsg\nstring\n非必须\n提示信息\n\n\ndata\nobject\n非必须\n返回的数据\n\n\n响应数据样例：\ntxt&#123;\n    &quot;code&quot;: 1,\n    &quot;msg&quot;: &quot;success&quot;,\n    &quot;data&quot;: null\n&#125;","slug":"基于uni-app框架开发的校园课表微信小程序","date":"2023-11-06T05:28:12.000Z","categories_index":"Blog","tags_index":"学习,Java","author_index":"Fioransh"},{"id":"452d114e7a0301edf39e3da31eb54488","title":"6神，启动！","content":"本文旨在测试博客图片上传功能，为了解决博客上传图片失败问题努力了几个小时后终于发现了问题所在，在hexo中的 hexo-asset-image 图片模块和 hexo-abbrlink 不兼容导致。\n解决方法：在node_modules&#x2F;hexo-asset-image&#x2F;index.js中将代码中的”var endPos &#x3D; link.length - 1”改为”-5”即可解决。\n\n6神，启动！\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"6神，启动！","date":"2023-09-09T16:00:00.000Z","categories_index":"Blog","tags_index":"黄怡慈","author_index":"Fioransh"},{"id":"a5170803adaf724d5767bb183841fa47","title":"SCAU软件工程经济学知识点","content":"SCAU软件工程经济学知识点*有哪些分类，有哪些方法，有哪些特点*\n第一章\n1.软件的定义：它是包括程序、数据及其相关文档的完整集合。\n2.按软件功能分类：系统、支撑、应用。\n3.按规模分类：微型、小型、中型、大型、超大型、极大型。\n4.按标准化程度分类：标准化、半定制、软件服务（定制软件）。\n5.按硬件或软件关联分类：嵌入型、组织型、半独立型。\n6.按工作方式：实时处理、多用户分时处理、交互式、批处理。\n7.软件特点：信息产品、从头开始生产、知识结晶、手工方式生产、无需库存成本、壁垒低、对用户有粘性。\n8.软件产业是指软件产品和软件服务相关的一切经济活动和关系的总称。\n9.软件产业特点：高技术高附加值高效益、高度关联性、国际化、专业化分工、规模化经济效益。\n10.发展模式：“全面领先”技术与服务领导型——美国，“整机带动”嵌入式系统开发型——日韩，“软件集散”生产本地化型——爱尔兰，“外包服务”国际加工服务型——印度。\n11.产业不足：关键核心缺乏、自主创新能力弱、企业规模小、产权保护力度弱。\n12.软件企业：分为软件产品企业和软件服务企业。\n13.软件工程生产过程方法论：技术学、经济学、管理学。 \n14.软件生产周期：从概念形成开始，经过开发、使用和维护，直到最后退役的全过程。\n15.计算题：功能点计算方法\n\nW为加权系数，d为基本信息量。\nwd为题目表格中数据相乘后相加。\nFi环境复杂度参数（题目给出）\n16.衡量产品质量高低的指标：技术性能指标（处理能力）和可靠性指标（持久能力）。\n17.软件的可靠性是关系到系统成败的重要因素。\n18.软件工程经济学四个部分：\n\n第二章\n1.沉没成本：已经发生的不可收回的支出。\n2.任何对软件项目的工程经济分析与研究都必须从实体维、时间维和要素维等三个维度展开。\n3.经济活动分析与评价特征：系统分析的目的是为了提高工程经济活动的经济效果，经济效果大多与“未来”有关，系统分析强调的是在技术可行性基础上的经济分析，系统评价是通过“比较”来完成的，统评价应是各利益主体目标的相互协调与均衡。\n4.投资：实现目标而进行资金投放或运行的经济活动。\n5.投资活动包括：生产性投资（保证生产运行）和非生产性投资（证券投资）。\n6.建设项目投资包括：固定资产投资（设备）、流动资金投资（工资原材料）、无形资产投资（使用权）。\n7.筹资和资金运用、项目可行性、市场调查。\n8.项目的可行性分析：必要性、可实现性、效果性与风险性。\n9.总成本费用：生产成本、管理费用、财务费用和销售费用。\n10.收入：销售收入、劳务收入、使用费收入、股利收入及利息收入。\n11.税金：增值税（增值额）、营业税、企业所得税（生产经营）、城乡维护建设税（维护公共设施）、教育费附加。\n12.所得税：企业所得税与个人所得税。\n13.利润：\n\n14.资金的时间价值：绝对金额随时间转移后其增加或减少的金额部分。\n15.计算题：年利率（本利和）的计算。\n\n16.现金流量图：箭头向上者表示现金流入(或正现金流)，箭头向下者表示现金流出(或负现金流)。注意现金流量图对象！\n17.计算题：初值和本利的计算。\n\n例题：\n\n\n\n\n18.***计算题：等额系列现金流。\n\n\nA为每年等额偿还&#x2F;存储的金额。Sn为最后一年金额。P0为首年金额。\nA&#x3D;P0 × CRF（偿还）\nA&#x3D;Sn × SFF （存储）\n例题：\n\n\n19.招标与投标的特征：组织性（招标特有）、公开性、一次性决定、公平性。\n20.招标类型：按公开程度和参加人数的限制条件分类，可划分为竞争性招标（公开招标）和有限招标（邀请招标），按合同的条件分类，可分为自动条件招标、随机条件招标、谈判招标。\n 第三章\n1.成本的经济内容：劳动资料方面的消耗、劳动对象方面的消耗、人工方面的消费的消耗。\n2.成本的特点：消耗性、补偿性、目的性、综合性、代偿性。\n3.成本的分类：按企业主要经营活动——研究与开发成本、采购成本、生产成本、经营成本、管理费用。按成本与产量的对应关系——变动成本与固定成本。按成本的确定时间——预测成本、定额成本、计划成本、实际成本。\n4.软件成本构成：硬件购置费用、网络通信费用、软件购置费用、基建费用、人力资源费用、硬件生产测试费、软件开发&#x2F;测试费用、水、电、运输费用、消耗材料及废品损失费用、培训费用、系统营销费用、管理费用、其他费用。\n5.减少成本测算误差的策略。\n6.计算题：功能分解法（不考大题）\n最小可能值ai、最大可能值bi、最可能值mi、平均规模Ej\n\n成本费用Coi、劳动生产率Eoi、各子系统模块成本Ci、各子系统工作量Mi\n软件总成本Cs、总工作量Es（Ms）\n\n\n例题：习题三第3题\n7.计算题：影响因子法与COCOMO模型\nU为综合影响要素\n\n\nCs软件开发成本、a工时费用率、Ms修正工作量、Mo基本工作量\nL软件开发规模、Td工期、rkhd形式参数（根据类型判断）。\n组织性：程序规模较小；嵌入型：硬件软件限制条件下运行；半独立型：规模较大。\n例题：\n\n\n8.计算题：类比法估计目标软件成本\n改变调整系数AAF、原软件开发规模La、新软件开发规模Lb\nDM设计修改百分比、CM代码修改百分比、IM集成修改百分比\n\nW1 &#x3D; 0.4、 W2 &#x3D; W3 &#x3D; 0.3\n\n9.ABC分类法\n\n\n成本控制的重点研究对象：ABC分类（从大到小排序）\n10.计算题：挣值管理法\n四个关键指标：总预算成本TBC、累计预算成本CBC、累计实现成本CAC、累计实现价值CEV。\n四个绩效评价参数：成本偏差CV：CV&#x3D;CEV-CAC、成本绩效CPI：CPI&#x3D;CEV&#x2F;CAC、进度偏差SV：SV&#x3D;CEV-CBC、进度绩效SPI：SPI&#x3D;CEV&#x2F;CBC。\n完工预测成本FCAC：FCAC&#x3D;TBC&#x2F;CPI、FCAC&#x3D;CAC+(TBC-CEV)、FCAC&#x3D;CAC+重估剩余工程预算。\n11.软件产品的定价和营销是软件生存周期中的两项重要工程经济活动。\n12.产品价格是由其价值所决定的。\n13.软件价格的影响因素：用户需求、产品成本、市场竞争和垄断及环境因素。\n14.软件的定价目标：利润导向、收益导向、销售导向、竞争导向、品牌导向、维持生存导向。\n15.软件的定价方法：成本导向定价法、需求导向定价法、竞争导向定价法。\n16.软件的定价策略：撇脂和渗透定价策略，捆绑定价策略，免费使用策略，歧视定价策略。\n17.软件的市场营销过程一般包括： ① 目标市场定位 ② 确定产品策略③ 确定定价策略④ 确定(销售)渠道策略 ⑤ 确定促销策略⑥ 确定服务策略。\n第四章\n1.项目评价：净现值法、内部收益率法和投资回收期法。\n2.计算题：净现值法NPV\n\nBt寿命期内收益、Ct支出（成本）、Dt残值、Kt投资额、i基准贴现率、N使用年限\nNPV&gt;0 投资可行 NPV&lt;&#x3D;0投资不可行\n3.计算题：内部收益法（不要求计算）了解原理：求NPV(IRR)（对分法）。\n4.计算题：投资回收期法\n\n5.计算题：净现值法进行多方案比较\n\n6.计算题：净年值法进行多方案比较\nCRF资金回收系数\n\n7.计算题：研究期法（是否承认未使用价值）\n\n8.计算题：费用现值法\n\n9.计算题：年费用现值法\n\n10.效益的分类：成本与支出费用的节省、社会财富的增加、服务水平的提高、管理水平的提高。\n11.对软件项目实际效益与预测效益评价常采用系统运行前后对比法和参数估计法。\n12.软件的社会效益评价：系统评价以定性分析为主、社会评价无通用方法、对社会的贡献以间接效益、无形效果和外部效果为主。\n13.软件项目的风险：\n\n第五章（略）\n第六章\n1.软件的开发的产品目标：质量、成本、进度和团队。\n2.计划网络图与关键路径！！！\n特征：有向性和不可逆转性、连通性、封闭性。\n当计划网络出现多个起始结点或多个终止结点时，应引入虚活动。\n\n\n\n\n3.软件开发团队的组织建设\n\n\n\n","slug":"SCAU软件工程经济学","date":"2023-06-28T18:28:12.000Z","categories_index":"Blog","tags_index":"学习","author_index":"Fioransh"},{"id":"bc926e4a66038b5c73c00f3880f05287","title":"响应状态码","content":"一、状态码大类\n\n\n状态码分类\n说明\n\n\n\n1xx\n响应中——临时状态码，表示请求已经接受，告诉客户端应该继续请求或者如果它已经完成则忽略它\n\n\n2xx\n成功——表示请求已经被成功接收，处理已完成\n\n\n3xx\n重定向——重定向到其它地方：它让客户端再发起一个请求以完成整个处理。\n\n\n4xx\n客户端错误——处理发生错误，责任在客户端，如：客户端的请求一个不存在的资源，客户端未被授权，禁止访问等\n\n\n5xx\n服务器端错误——处理发生错误，责任在服务端，如：服务端抛出异常，路由出错，HTTP版本不支持等\n\n\n二、常见的响应状态码\n\n\n状态码\n英文描述\n解释\n\n\n\n&#x3D;&#x3D;200&#x3D;&#x3D;\nOK\n客户端请求成功，即处理成功，这是我们最想看到的状态码\n\n\n302\nFound\n指示所请求的资源已移动到由Location响应头给定的 URL，浏览器会自动重新访问到这个页面\n\n\n304\nNot Modified\n告诉客户端，你请求的资源至上次取得后，服务端并未更改，你直接用你本地缓存吧。隐式重定向\n\n\n400\nBad Request\n客户端请求有语法错误，不能被服务器所理解\n\n\n403\nForbidden\n服务器收到请求，但是拒绝提供服务，比如：没有权限访问相关资源\n\n\n&#x3D;&#x3D;404&#x3D;&#x3D;\nNot Found\n请求资源不存在，一般是URL输入有误，或者网站资源被删除了\n\n\n405\nMethod Not Allowed\n请求方式有误，比如应该用GET请求方式的资源，用了POST\n\n\n428\nPrecondition Required\n服务器要求有条件的请求，告诉客户端要想访问该资源，必须携带特定的请求头\n\n\n429\nToo Many Requests\n指示用户在给定时间内发送了太多请求（“限速”），配合 Retry-After(多长时间后可以请求)响应头一起使用\n\n\n431\n Request Header Fields Too Large\n请求头太大，服务器不愿意处理请求，因为它的头部字段太大。请求可以在减少请求头域的大小后重新提交。\n\n\n&#x3D;&#x3D;500&#x3D;&#x3D;\nInternal Server Error\n服务器发生不可预期的错误。服务器出异常了，赶紧看日志去吧\n\n\n503\nService Unavailable\n服务器尚未准备好处理请求，服务器刚刚启动，还未初始化好\n\n\n状态码大全：https://cloud.tencent.com/developer/chapter/13553 \n","slug":"响应状态码","date":"2023-03-14T05:28:12.000Z","categories_index":"Blog","tags_index":"学习,网络","author_index":"Fioransh"}]